<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Meta.Numerics</name>
    </assembly>
    <members>
        <member name="T:Meta.Numerics.Analysis.EvaluationResult">
            <summary>
            Represents the result of a function analysis.
            </summary>
            <remarks>
            <para>This is the base class for all function analysis result classes.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Analysis.EvaluationResult.EvaluationCount">
            <summary>
            Gets the number of function evaluations performed.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.EvaluationResult.Settings">
            <summary>
            Gets the settings used for the analysis.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Analysis.EvaluationSettings">
            <summary>
            Contains settings controling the evaluation of a function.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.EvaluationSettings.#ctor">
            <summary>
            Initializes a new set of default evaulation settings.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.EvaluationSettings.EvaluationBudget">
            <summary>
            Gets or sets the total number of evaluations allowed.
            </summary>
            <value>The total number of evaluations allowed, which must be non-negative.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.EvaluationSettings.RelativePrecision">
            <summary>
            Gets or sets targeted relative precision.
            </summary>
            <value>The relative precision to which the result should be evaluated, which must be between 0 and 1.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.EvaluationSettings.AbsolutePrecision">
            <summary>
            Gets or sets the targeted absolute precision.
            </summary>
            <value>The absolute precision to which the result should be evaluated, which must be non-negative.</value>
        </member>
        <member name="T:Meta.Numerics.Analysis.Extremum">
            <summary>
            Represents a maximum or minimum of a function of one variable.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.Extremum.Location">
            <summary>
            Gets the location (x-value) of the extremum.
            </summary>
            <remarks>
            <para>Note that numerical methods for finding typical a maximum or minimum cannot usually determine
            its location to full floating-point precision. Near a quadratic extremum, a change in x of ~&#x3B5; will
            change f(x) by ~&#x3B5;<sup>2</sup>. Thus the smallest detectable change in f(x) will
            typically correspond to a change in x of order of the square root of full precision. Full
            <see cref="T:System.Double"/> precision being ~16 digits, you should expect the location to
            be accurate only to ~8 digits.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Analysis.Extremum.Value">
            <summary>
            Gets the function value (y-value) at the extremum.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.Extremum.Curvature">
            <summary>
            Gets the curvature at the extremum.
            </summary>
            <remarks>
            <para>The curvature is the second derivative of the function at the extremum.</para>
            <para>At a typical extremum, where the function has vanishing first derivative, the second derivative will be a number
            whose magnitude characterizes the "steepness" with which the function increases as one moves away from the extremum.</para>
            <para>At an atypical extremum, for example at an interval boundary or of a non-smooth function, this
            value may be meaningless.</para>
            <para>Even in the case of a typical extremum, the value of the curvature property will typically be accurate only
            to a handfull of digits. If you require a highly accurate determination of the curvature,
            you should compute the second derivative of the minimzed function explicitly.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Analysis.FunctionMath">
            <summary>
            Contains methods for the analysis of functions.
            </summary>
            <remarks>
            <para>Function analysis includes integration, finding maxima and minima, and finding roots.</para>
            <para>This class contains methods for the analysis of functions that both accept a single real argument and return a single real value.
            For the analysis of multi-dimensional functions, see the <see cref="T:Meta.Numerics.Analysis.MultiFunctionMath"/> class.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Solves a conservative second order ordinary differential equation initial value problem.
            </summary>
            <param name="rhs">The right hand side function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function variable.</param>
            <param name="yPrime0">The intial value of the function derivative.</param>
            <param name="x1">The final value of the independent variable.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="rhs"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting the maximum allowed number of <paramref name="rhs"/> evaluations.</exception>
            <remarks>
            <para>For information on integrating conservative ODEs, see
            <see cref="M:Meta.Numerics.Analysis.FunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)"/>.</para>
            <para>This overload uses default values for precision and evaluation budget. It targets a relative precision of
            about 10<sup>-12</sup> and an absolute precision of about 10<sup>-24</sup> with an evaluation budget of about 8000.
            </para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)">
            <summary>
            Solves a conservative second order ordinary differential equation initial value problem using the given settings.
            </summary>
            <param name="rhs">The right hand side function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function variable.</param>
            <param name="yPrime0">The intial value of the function derivative.</param>
            <param name="x1">The final value of the independent variable.</param>
            <param name="settings">The settings to use when solving the problem.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="rhs"/> or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting the maximum allowed number of <paramref name="rhs"/> evaluations.</exception>
            <remarks>
            <para>A conservative ODE is an ODE of the form</para>
            <img src="../images/ConservativeODE.png" />
            <para>where the right-hand-side depends only on x and y, not on the derivative y'. ODEs of this form are called conservative because
            they exhibit conserved quantities: combinations of y and y' that maintain the same value as the system evolves. Many forms of
            Newtonian equations of motion, for example, are conservative ODEs, with conserved quantities such as energy, momentum, and
            angular momentum. Our specialized conservative ODE integrator is not only more efficient for conservative ODEs, but does a
            better job of maintaining the conserved quantities.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.IntegrateOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
            Solves an ordinary differential equation initial value problem.
            </summary>
            <param name="rhs">The right hand side function, which returns the value of the derivative given
            the values of the indepdent variable and the function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function.</param>
            <param name="x1">The final value of the independent variable.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="rhs"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting the maximum allowed number of <paramref name="rhs"/> evaluations.</exception>
            <remarks>
            <para>For information on integrating ODEs, see
            <see cref="M:Meta.Numerics.Analysis.FunctionMath.IntegrateOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)"/>.</para>
            <para>This overload uses default values for precision and evaluation budget. It targets a relative precision of
            about 10<sup>-12</sup> and an absolute precision of about 10<sup>-24</sup> with an evaluation budget of about 8000.
            </para>
            </remarks>
            <seealso href="https://en.wikipedia.org/wiki/Ordinary_differential_equation"/>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.IntegrateOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)">
            <summary>
            Solves an ordinary differential equation initial value problem.
            </summary>
            <param name="rhs">The right hand side function, which returns the value of the derivative given
            the values of the indepdent variable and the function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function.</param>
            <param name="x1">The final value of the independent variable.</param>
            <param name="settings">The settings to use when solving the problem.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="rhs"/> or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting the maximum allowed number of <paramref name="rhs"/> evaluations.</exception>
            <remarks>
            <para>An ordinary differential equation (ODE) has the form:</para>
            <img src="../images/ODE.png" />
            <para>The function specifying the derivative as a function of x and y is called the right-hand-side (RHS).</para>
            <para>The integration of an ODE consists of specifying the value of y at some initial x and computing its value
            at a different x in accordance with the differential equation. The terms "initial" and "final" are derived from
            the common case where the indepdent variable is time, but the technique applies whether the independent variable
            repsents a time, a location, or a completely non-physical quantity, as long as the problem has the form of an ODE.</para>
            <para>ODEs involving multiple, coupled dependent variables can be integrated using the
            <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Double,Meta.Numerics.Analysis.MultiOdeEvaluationSettings)"/>
            method. Higher order ODEs can be integrated by representing them as coupled ODEs in which the zeroth component
            is the desired y, the first component is y', the second component is y'', etc. So-called conservative second order
            ODEs should be integrated using the
            <see cref="M:Meta.Numerics.Analysis.FunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)"/>
            method. If your ODE's RHS depends only on x, the problem reduces to a simple integral, which can be solved more rapidly and
            accurately using the <see cref="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)"/> method.
            Analytic techniques can also be used to reduce several other kinds of ODEs to simple integrals or lower-order ODEs.</para>
            </remarks>
            <seealso href="https://en.wikipedia.org/wiki/Ordinary_differential_equation"/>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindZero(System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Isolates a root in the vicinity of a given point.
            </summary>
            <param name="f">The function whoose zero is sought.</param>
            <param name="x">A ordinate believed to be near the sought zero.</param>
            <returns>An ordinate at which the function has a zero.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindZero(System.Func{System.Double,System.Double},Meta.Numerics.Interval)">
            <summary>
            Isolates a root within a given interval.
            </summary>
            <param name="f">The function whoose zero is sought.</param>
            <param name="bracket">An interval bracketing the root.</param>
            <returns>An ordinate within the bracket at which the function has a zero.</returns>
            <exception cref="T:System.InvalidOperationException">The function does not change sign across the given interval.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMaximum(System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Maximizes a function in the vicinity of a given point.
            </summary>
            <param name="f">The function.</param>
            <param name="x">A point suspected to be near the maximum. The search begins at this point.</param>
            <returns>The maximum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a maximum being determined.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMaximum(System.Func{System.Double,System.Double},System.Double,Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Maximizes a function in the vicinity of a given point, subject to the given evaluation settings.
            </summary>
            <param name="f">The function.</param>
            <param name="x">A point suspected to be near the maximum. The search begins at this point.</param>
            <param name="settings">The settings to use when searching for the maximum.</param>
            <returns>The maximum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a maximum being determined to the prescribed precision.</exception>
            <remarks>
            <para>When you supply <paramref name="settings"/>, note that the supplied <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.RelativePrecision"/> and <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.AbsolutePrecision"/>
            values refer to argument (i.e. x) values, not function (i.e. f) values. Note also that, for typical functions, the best attainable relative precision is of the order of the
            square root of machine precision (about 10<sup>-7</sup>), i.e. half the number of digits in a <see cref="T:System.Double"/>. This is because to identify an extremum we need to resolve changes
            in the function value, and near an extremum  &#x3B4;f &#x223C; (&#x3B4;x)<sup>2</sup>, so changes in the function value &#x3B4;f &#x223C; &#x3B5; correspond to changes in the
            argument value &#x3B4;x &#x223C; &#x221A;&#x3B5;. If you supply zero values for both precision settings, the method will adaptively approximate the best attainable precision for
            the supplied function and locate the extremum to that resolution. This is our suggested practice unless you know that you require a less precise determination.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Minimizes a function in the vicinity of a given point.
            </summary>
            <param name="f">The function.</param>
            <param name="x">A point suspected to be near the minimum. The search begins at this point.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a minimum being determined.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double,System.Double},System.Double,Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Minimizes a function in the vicinity of a given point subject to the given evaluation settings.
            </summary>
            <param name="f">The function.</param>
            <param name="x">A point suspected to be near the minimum. The search begins at this point.</param>
            <param name="settings">The settings to use when searching for the minimum.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a minimum being determined to the prescribed precision.</exception>
            <remarks>
            <para>When you supply <paramref name="settings"/>, note that the supplied <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.RelativePrecision"/> and <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.AbsolutePrecision"/>
            values refer to argument (i.e. x) values, not function (i.e. f) values. Note also that, for typical functions, the best attainable relative precision is of the order of the
            square root of machine precision (about 10<sup>-7</sup>), i.e. half the number of digits in a <see cref="T:System.Double"/>. This is because to identify an extremum we need to resolve changes
            in the function value, and near an extremum  &#x3B4;f &#x223C; (&#x3B4;x)<sup>2</sup>, so changes in the function value &#x3B4;f &#x223C; &#x3B5; correspond to changes in the
            argument value &#x3B4;x &#x223C; &#x221A;&#x3B5;. If you supply zero values for both precision settings, the method will adaptively approximate the best attainable precision for
            the supplied function and locate the extremum to that resolution. This is our suggested practice unless you know that you require a less precise determination.</para>
            <para>Since the search algorithm begins by evaluating <paramref name="f"/> at points near <paramref name="x"/>, it can fail if <paramref name="x"/> is near a singularity
            or other point at which the evaluation of <paramref name="f"/> could fail. If you can reliably bracket an extremum, the <see cref="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)"/>
            overload of this method is safer and, if your bracket is any good, usually slightly faster.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMaximum(System.Func{System.Double,System.Double},Meta.Numerics.Interval)">
            <summary>
            Maximizes a function on the given interval.
            </summary>
            <param name="f">The function.</param>
            <param name="r">The interval.</param>
            <returns>The maximum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a minimum being determined.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMaximum(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Maximizes a function on the given interval, subject to the given evaluation settings.
            </summary>
            <param name="f">The function.</param>
            <param name="r">The interval.</param>
            <param name="settings">The settings used when searching for the maximum.</param>
            <returns>The maximum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a maximum being determined to the prescribed precision.</exception>
            <remarks>
            <para>When you supply <paramref name="settings"/>, note that the supplied <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.RelativePrecision"/> and <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.AbsolutePrecision"/>
            values refer to argument (i.e. x) values, not function (i.e. f) values. Note also that, for typical functions, the best attainable relative precision is of the order of the
            square root of machine precision (about 10<sup>-7</sup>), i.e. half the number of digits in a <see cref="T:System.Double"/>. This is because to identify an extremum we need to resolve changes
            in the function value, and near an extremum  &#x3B4;f &#x223C; (&#x3B4;x)<sup>2</sup>, so changes in the function value &#x3B4;f &#x223C; &#x3B5; correspond to changes in the
            argument value &#x3B4;x &#x223C; &#x221A;&#x3B5;. If you supply zero values for both precision settings, the method will adaptively approximate the best attainable precision for
            the supplied function and locate the extremum to that resolution. This is our suggested practice unless you know that you require a less precise determination.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double,System.Double},Meta.Numerics.Interval)">
            <summary>
            Minimizes a function on the given interval.
            </summary>
            <param name="f">The function.</param>
            <param name="r">The interval.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a minimum being determined.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Minimizes a function on the given interval, subject to the given evaluation settings.
            </summary>
            <param name="f">The function.</param>
            <param name="r">The interval.</param>
            <param name="settings">The settings used when searching for the minimum.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> is null or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">More than the maximum allowed number of function evaluations occured without a minimum being determined to the prescribed precision.</exception>
            <remarks>
            <para>When you supply <paramref name="settings"/>, note that the supplied <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.RelativePrecision"/> and <see cref="P:Meta.Numerics.Analysis.EvaluationSettings.AbsolutePrecision"/>
            values refer to argument (i.e. x) values, not function (i.e. f) values. Note also that, for typical functions, the best attainable relative precision is of the order of the
            square root of machine precision (about 10<sup>-7</sup>), i.e. half the number of digits in a <see cref="T:System.Double"/>. This is because to identify an extremum we need to resolve changes
            in the function value, and near an extremum  &#x3B4;f &#x223C; (&#x3B4;x)<sup>2</sup>, so changes in the function value &#x3B4;f &#x223C; &#x3B5; correspond to changes in the
            argument value &#x3B4;x &#x223C; &#x221A;&#x3B5;. If you supply zero values for both precision settings, the method will adaptively approximate the best attainable precision for
            the supplied function and locate the extremum to that resolution. This is our suggested practice unless you know that you require a less precise determination.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval)">
            <summary>
            Evaluates a definite integral.
            </summary>
            <param name="integrand">The function to be integrated.</param>
            <param name="range">The range of integration.</param>
            <returns>A numerical estimate of the given integral.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="integrand"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The maximum number of function evaluations was exceeded before the integral
            could be determined to the required precision.</exception>
            <remarks>
            <para>By default, integrals are evaluated to a relative precision of about 10<sup>-15</sup>, about a digit short of full
            precision, using a budget of about 5000 evaulations. To specify different evaluation settings use
            <see cref="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)"/>.</para>
            <para>See <see cref="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)"/> for detailed remarks on
            numerical integration.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Evaluates a definite integral with the given evaluation settings.
            </summary>
            <param name="integrand">The function to be integrated.</param>
            <param name="range">The range of integration.</param>
            <param name="settings">The settings which control the evaulation of the integal.</param>
            <returns>The result of the integral, which includes an estimated value and an estimated uncertainty of that value.</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="integrand"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The maximum number of function evaluations was exceeded before the integral
            could be determined to the required precision.</exception>
            <remarks>
            <para>To do integrals over infinite regions, simply set the lower bound of the <paramref name="range"/>
            to <see cref="F:System.Double.NegativeInfinity"/> or the upper bound to <see cref="F:System.Double.PositiveInfinity"/>.</para>
            <para>Our numerical integrator uses a Gauss-Kronrod rule that can integrate efficiently,
            combined with an adaptive strategy that limits function
            evaluations to those regions required to achieve the desired accuracy.</para>
            <para>Our integrator handles smooth functions extremely efficiently. It handles integrands with
            discontinuities, or discontinuities of derivatives, at the price of slightly more evaluations
            of the integrand. It can handle oscilatory functions, as long as not too many periods contribute
            significantly to the integral. It can integrate logarithmic and mild power-law singularities.</para>
            <para>Strong power-law singularities will cause the alrorighm to fail with a <see cref="T:Meta.Numerics.NonconvergenceException"/>.
            This is unavoidable for essentially any double-precision numerical integrator. Consider, for example,
            the integrable singularity 1/&#x221A;x. Since
            &#x3B5; = &#x222B;<sub>0</sub><sup>&#x3B4;</sup> x<sup>-1/2</sup> dx = 2 &#x3B4;<sup>1/2</sup>,
            points within &#x3B4; &#x223C; 10<sup>-16</sup> of the end-points, which as a close as you can get to
            a point in double precision without being on top of it, contribute at the &#x3B5; &#x223C; 10<sup>-8</sup>
            level to our integral, well beyond limit that nearly-full double precision requires. Said differently,
            to know the value of the integral to &#x3B5; &#x223C; 10<sup>-16</sup> prescision, we would need to
            evaluate the contributions of points within &#x3B4; &#x223C; 10<sup>-32</sup> of the endpoints,
            which is far closer than we can get.</para>
            <para>If you need to evaluate an integral with such a strong singularity, make an analytic
            change of variable to absorb the singularity before attempting numerical integration. For example,
            to evaluate I = &#x222B;<sub>0</sub><sup>b</sup> f(x) x<sup>-1/2</sup> dx, substitute y = x<sup>1/2</sup>
            to obtain I = 2 &#x222B;<sub>0</sub><sup>&#x221A;b</sup> f(y<sup>2</sup>) dy.</para>
            <para>To do multi-dimensional integrals, use
            <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.Integrate(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double[],System.Double},System.Double[])">
            <summary>
            Minimizes a function on a multi-dimensional space in the vicinity of a given point. 
            </summary>
            <param name="f">The function.</param>
            <param name="x">The starting point for the search.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> or <paramref name="x"/> is null</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The minimum was not found to the required precision within the budgeted number of function evaluations.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.FunctionMath.FindMinimum(System.Func{System.Double[],System.Double},System.Double[],Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Minimizes a function on a multi-dimensional space in the vicinity of a given point, subject to the given settings. 
            </summary>
            <param name="f">The function.</param>
            <param name="x">The starting point for the search.</param>
            <param name="settings">The evaluation settings.</param>
            <returns>The minimum.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/>, <paramref name="x"/>, or <paramref name="settings"/> is null.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The minimum was not found to the required precision within the budgeted number of function evaluations.</exception>
        </member>
        <member name="T:Meta.Numerics.Analysis.IntegrationResult">
            <summary>
            Represents the result of a numerical integration.
            </summary>
            <remarks>
            <para>This class is returned by various numerical integration methods, including
            <see cref="M:Meta.Numerics.Analysis.FunctionMath.Integrate(System.Func{System.Double,System.Double},Meta.Numerics.Interval,Meta.Numerics.Analysis.EvaluationSettings)"/>
            and <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.Integrate(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)"/>.
            In addition to an estimate of the integral and the associated uncertainty, it gives a count of the number of function evaluations
            that were required and the <see cref="T:Meta.Numerics.Analysis.EvaluationSettings"/> that were used for the integration.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Analysis.IntegrationResult.Estimate">
            <summary>
            Gets the estimated value of the integral and its associated error bar.
            </summary>
            <remarks>
            <para>Note that the associated error estimate represents an expected deviation, not
            a definitive bound on the deviation.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Analysis.IntegrationResult.Value">
            <summary>
            Gets the estimated value of the integral.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.IntegrationResult.Precision">
            <summary>
            Gets the estimated precision of the evaluated value.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Analysis.MultiExtremum">
            <summary>
            Represents a minimum or maximum of a multidimensional function.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiExtremum.Dimension">
            <summary>
            Gets the dimension of the space on which the function is defined.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiExtremum.Location">
            <summary>
            Gets the location of the extremum.
            </summary>
            <value>A read-only vector of the coordinates at which the function reaches its extremum.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiExtremum.Value">
            <summary>
            Gets the value of the function at the extremum.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiExtremum.Precision">
            <summary>
            Gets the estimated precision of the function value.
            </summary>
            <remarks>
            <para>This should be understood as an estimate of the accuracy of <see cref="P:Meta.Numerics.Analysis.MultiExtremum.Value"/> as an estimate of the extremum value. It should not
            be intrepreted as a two-sided error bar, because the true minimum (maximum) value, if different, can only be smaller (larger).</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiExtremum.HessianMatrix">
            <summary>
            Gets the Hessian matrix at the extremum.
            </summary>
            <value>A read-only matrix of approximate second partial derivaties at the extremum, or null if the algorithm does not provide one.</value>
            <remarks>
            <para>These values, if present, should be considered very approximate. If you require a more precise estimate of second derivatives,
            use numerical differentiation.</para>
            <para>The Hessian matrix is symmetric because the order of differentiation does not affect the result.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Analysis.MultiFunctionMath">
            <summary>
            Contains methods for the analysis of multi-dimensional functions.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval})">
            <summary>
            Finds the minimum of a function within the given volume.
            </summary>
            <param name="function">The function.</param>
            <param name="volume">The volume to search.</param>
            <returns>The global minimum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Finds the minimum of a function within the given volume, subject to the given evaluation constraints.
            </summary>
            <param name="function">The function.</param>
            <param name="volume">The volume to search.</param>
            <param name="settings">The evaluation constraints to apply.</param>
            <returns>The global minimum.</returns>
            <remarks>
            <para>This algorithm attempts to find the global minimum of the given function within the entire given hyper-cube. It generally
            requires many more function evaluations than <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)"/>,
            but is much more likely to find a global minimum in situations where multiple local minima exist.</para>
            <para>Unlike <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)"/>,
            this method does not return an approximate Hessian matrix near the minimum.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> or <paramref name="volume"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The minimum could not be found within the given evaluation budget.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMaximum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval})">
            <summary>
            Finds the maximum of a function within the given volume.
            </summary>
            <param name="function">The function.</param>
            <param name="volume">The volume to search.</param>
            <returns>The global maximum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMaximum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Finds the maximum of a function within the given volume, subject to the given evaluation constraints.
            </summary>
            <param name="function">The function.</param>
            <param name="volume">The volume to search.</param>
            <param name="settings">The evaluation constraints to apply.</param>
            <returns>The global maximum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindLocalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Finds a local minimum of a multi-dimensional function in the vincinity of the given starting location.
            </summary>
            <param name="function">The multi-dimensional function to minimize.</param>
            <param name="start">The starting location for the search.</param>
            <returns>The local minimum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindLocalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{System.Double},Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Finds a local minimum of a multi-dimensional function in the vincinity of the given starting location, subject to the given evaluation constraints.
            </summary>
            <param name="function">The multi-dimensional function to minimize.</param>
            <param name="start">The starting location for the search.</param>
            <param name="settings">The evaluation settings that govern the search for the minimum.</param>
            <returns>The local minimum.</returns>
            <remarks>
            <para>The Hessian (matrix of second derivatives) returned with the minimum is an approximation that is constructed in the course of search. It should be
            considered a crude approximation, and may not even be that if the minimum is highly non-quadratic.</para>
            <para>If you have a constrained minimization problem, require a high-precision solution, and do not have a good initial guess, consider first feeding
            your constrained problem into <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.FindGlobalMinimum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)"/>, which supports constraints but gives relatively lower precision solutions, then
            feeding the result of that method into this method, which finds relatively precise solutions but does not support constraints.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/>, <paramref name="start"/>, or <paramref name="settings"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The number of function evaluations required exceeded the evaluation budget.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindLocalMaximum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Finds a local maximum of a multi-dimensional function in the vincinity of the given starting location.
            </summary>
            <param name="function">The multi-dimensional function to maximize.</param>
            <param name="start">The starting location for the search.</param>
            <returns>The local maximum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindLocalMaximum(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{System.Double},Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Finds a local maximum of a multi-dimensional function in the vincinity of the given starting location, subject to the given evaluation constraints.
            </summary>
            <param name="function">The multi-dimensional function to maximize.</param>
            <param name="start">The starting location for the search.</param>
            <param name="settings">The evaluation settings that govern the search for the maximum.</param>
            <returns>The local maximum.</returns>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.Integrate(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval})">
            <summary>Estimates a multi-dimensional integral.</summary>
            <param name="function">The function to integrate.</param>
            <param name="volume">The volume over which to integrate.</param>
            <returns>A numerical estimate of the multi-dimensional integral.</returns>
            <remarks>
            <para>By default, our multidimensional integration system targets a relative accuracy of about 10<sup>-7</sup> (close to full single precision) for d=2, falling gradually
            to about 10<sup>-2</sup> (1%) for d=12. To achieve that accuracy, it allows up to about 10<sup>5</sup> evaluations of the integrand for d=2, rising
            up to about 10<sup>8</sup> evaluations for d=12.</para>
            <para>You can change the accuracy demands and evaluation budget by passing an <see cref="T:Meta.Numerics.Analysis.EvaluationSettings"/> object to the integration method. By decreasing
            the accuracy you require or increasing the evaluation budget, you may be able to successfully complete integrals that would fail for the default settings.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.Integrate(System.Func{System.Collections.Generic.IList{System.Double},System.Double},System.Collections.Generic.IList{Meta.Numerics.Interval},Meta.Numerics.Analysis.EvaluationSettings)">
            <summary>
            Estimates a multi-dimensional integral using the given evaluation settings.
            </summary>
            <param name="function">The function to be integrated.</param>
            <param name="volume">The volume over which to integrate.</param>
            <param name="settings">The integration settings.</param>
            <returns>A numerical estimate of the multi-dimensional integral.</returns>
            <remarks>
            <para>Note that the integration function must not attempt to modify the argument passed to it.</para>
            <para>Note that the integration volume must be a hyper-rectangle. You can integrate over regions with more complex boundaries by specifying the integration
            volume as a bounding hyper-rectangle that encloses your desired integration region, and returing the value 0 for the integrand outside of the desired integration
            region. For example, to find the volume of a unit d-sphere, you can integrate a function that is 1 inside the unit d-sphere and 0 outside it over the volume
            [-1,1]<sup>d</sup>. You can integrate over infinite volumes by specifing volume endpoints of <see cref="F:System.Double.PositiveInfinity"/> and/or
            <see cref="F:System.Double.NegativeInfinity"/>. Volumes with dimension greater than 12 are not currently supported.</para>
            <para>Integrals with hard boundaries (like our hyper-sphere volume problem) typically require more evaluations than integrals of smooth functions to achieve the same accuracy.
            Integrals with canceling positive and negative contributions also typically require more evaluations than integtrals of purely positive functions.</para>
            <para>Numerical multi-dimensional integration is computationally expensive. To make problems more tractable, keep in mind some rules of thumb:</para>
            <ul>
              <li>Reduce the required accuracy to the minimum required. Alternatively, if you are willing to wait longer, increase the evaluation budget.</li>
              <li>Exploit symmetries of the problem to reduce the integration volume. For example, to compute the volume of the unit d-sphere, it is better to
              integrate over [0,1]<sup>d</sup> and multiply the result by 2<sup>d</sup> than to simply integrate over [-1,1]<sup>d</sup>.</li>
              <li>Apply analytic techniques to reduce the dimension of the integral. For example, when computing the volume of the unit d-sphere, it is better
              to do a (d-1)-dimesional integral over the function that is the height of the sphere in the dth dimension than to do a d-dimensional integral over the
              indicator function that is 1 inside the sphere and 0 outside it.</li>
            </ul>
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="function"/>, <paramref name="volume"/>, or <paramref name="settings"/> are null, or
            the dimension of <paramref name="volume"/> is larger than 12.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The prescribed accuracy could not be achieved with the given evaluation budget.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Solves a set of coupled, conservative second order ordinary differential equation initial value problems.
            </summary>
            <param name="rhs">The right hand side function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial values of the functions.</param>
            <param name="yPrime0">The intial values of the functions' derivatives.</param>
            <param name="x1">The final value of the independent variable.</param>
            <returns>The solution, including the final value of the functions and their derivatives.</returns>
            <remarks>
            <para>For information on integrating coupled, conservative ODEs, see
            <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double,Meta.Numerics.Analysis.MultiOdeEvaluationSettings)"/>.</para>
            <para>This overload uses default settings for precision and evaluation budget. It targets a relative precision of
            about 10<sup>-12</sup> and an absolute precision of about 10<sup>-24</sup> with an evaluation budget of about 8000.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/>, <paramref name="y0"/>, or <paramref name="yPrime0"/>
            is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException"><paramref name="y0"/> and <paramref name="yPrime0"/> do not have the same
            dimension.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting
            the maximum allowed number of <paramref name="rhs"/>evaluations.</exception>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double,Meta.Numerics.Analysis.MultiOdeEvaluationSettings)">
            <summary>
            Solves a set of coupled, conservative second order ordinary differential equation initial value problems using the given settings.
            </summary>
            <param name="rhs">The right hand side function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial values of the functions.</param>
            <param name="yPrime0">The intial values of the functions' derivatives.</param>
            <param name="x1">The final value of the independent variable.</param>
            <param name="settings">The settings to use when solving the problem.</param>
            <returns>The solution, including the final value of the functions and their derivatives.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/>, <paramref name="y0"/>, <paramref name="yPrime0"/>,
            or <paramref name="settings"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException"><paramref name="y0"/> and <paramref name="yPrime0"/> do not have the same
            dimension.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting
            the maximum allowed number of <paramref name="rhs"/>evaluations.</exception>
            <remarks>
            <para>For information on conservative ODEs, see <see cref="M:Meta.Numerics.Analysis.FunctionMath.IntegrateConservativeOde(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,Meta.Numerics.Analysis.OdeEvaluationSettings)"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Solves a set of coupled ordinary differential equation initial value problems.
            </summary>
            <param name="rhs">The right hand side function, which returns the value of the derivative given
            the values of the indepdent variable and the function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function.</param>
            <param name="x1">The final value of the independent variable.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/> or <paramref name="y0"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting
            the maximum allowed number of <paramref name="rhs"/> evaluations.</exception>
            <remarks>
            <para>For infomration about integrating coupled ODEs, see
            <see cref="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Double,Meta.Numerics.Analysis.MultiOdeEvaluationSettings)"/>.</para>
            <para>This overload uses default settings for precision and evaluation budget. It targets a relative precision of
            about 10<sup>-12</sup> and an absolute precision of about 10<sup>-24</sup> with an evaluation budget of about 8000.
            </para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.IntegrateOde(System.Func{System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Double,System.Collections.Generic.IList{System.Double},System.Double,Meta.Numerics.Analysis.MultiOdeEvaluationSettings)">
            <summary>
            Solves a set of coupled ordinary differential equation initial value problems.
            </summary>
            <param name="rhs">The right hand side function, which returns the value of the derivative given
            the values of the indepdent variable and the function.</param>
            <param name="x0">The initial value of the independent variable.</param>
            <param name="y0">The initial value of the function.</param>
            <param name="x1">The final value of the independent variable.</param>
            <param name="settings">The settings to use when solving the problem.</param>
            <returns>The solution, including the final value of the function and its derivative.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/>, <paramref name="y0"/>, or <paramref name="settings"/>
            is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The ODE could not be integrated to the required precision before exhausting
            the maximum allowed number of <paramref name="rhs"/>evaluations.</exception>
            <remarks>
            <para>This method integrates a set of coupled ordinary differential equations. The dependent variable y is a vector
            with any number of components, and the right-hand-side is a vector-valued function that gives the derivative
            of each component. Each component's derivative may depend itself and any other components, as well as on the independent variable.
            The independent variable x still takes only a single real value.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiFunctionMath.FindZero(System.Func{System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double}},System.Collections.Generic.IList{System.Double})">
            <summary>
            Finds a vector argument which makes a vector function zero.
            </summary>
            <param name="f">The vector function.</param>
            <param name="x0">The vector argument.</param>
            <returns>The vector argument which makes all components of the vector function zero.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> or <paramref name="x0"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="f"/> is not equal to the
            dimension of <paramref name="x0"/>.</exception>
        </member>
        <member name="T:Meta.Numerics.Analysis.MultiOdeEvaluationSettings">
            <summary>
            Contains settings used to solve a set of coupled ordinary differential equations.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.MultiOdeEvaluationSettings.#ctor">
            <summary>
            Initializes a new instance of evaluation settings for coupled ODEs.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiOdeEvaluationSettings.Listener">
            /// <summary>
            Gets or sets the handler that is called to report on progress toward the solution.
            </summary>
            <remarks>
            <para>As the ODE is integrated, the specified handler is called for each integration
            step. This allows the handler to monitor progress toward the solution and to
            obtain intermediate values via interpolation.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Analysis.MultiOdeResult">
            <summary>
            Represents the result of the integration of a set of couple ordinary differential equations.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiOdeResult.X">
            <summary>
            The value of the independent variable.
            </summary>
            <value>The value of the ordinate.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiOdeResult.Y">
            <summary>
            The value of the dependent variable.
            </summary>
            <value>The value of the abcissa.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.MultiOdeResult.YPrime">
            <summary>
            The value of the derivative.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Analysis.OdeEvaluationSettings">
            <summary>
            Contains settings controlling the integration of an ordinary differential equation.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.OdeEvaluationSettings.#ctor">
            <summary>
            Initializes a new instance of ODE evaluation settings.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.OdeEvaluationSettings.Listener">
            <summary>
            Gets or sets the handler that is called to report on progress toward the solution.
            </summary>
            <remarks>
            <para>As the ODE is integrated, the specified handler is called for each integration
            step. This allows the handler to monitor progress toward the solution and to
            obtain intermediate values via interpolation.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Analysis.OdeResult">
            <summary>
            Represents the result of the integration of an ordinary differential equation.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Analysis.OdeResult.X">
            <summary>
            The value of the independent variable.
            </summary>
            <value>The value of the ordinate.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.OdeResult.Y">
            <summary>
            The value of the dependent variable.
            </summary>
            <value>The value of the abcissa.</value>
        </member>
        <member name="P:Meta.Numerics.Analysis.OdeResult.YPrime">
            <summary>
            The value of the derivative.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Analysis.SpaceExtremum">
            <summary>
            Represents a maximum or minimum of a function on a multi-dimensional space.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.SpaceExtremum.Location">
            <summary>
            Gets the location of the extremum.
            </summary>
            <returns>The coordinates of the extremum.</returns>
        </member>
        <member name="P:Meta.Numerics.Analysis.SpaceExtremum.Value">
            <summary>
            Gets the value of the function at the extremum.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Analysis.SpaceExtremum.Curvature">
            <summary>
            Gets the curvature matrix at the extremum.
            </summary>
            <returns>The curvature matrix.</returns>
        </member>
        <member name="P:Meta.Numerics.Analysis.SpaceExtremum.Dimension">
            <summary>
            Gets the dimension of the space on which the function is defined. 
            </summary>
        </member>
        <member name="T:Meta.Numerics.Complex">
            <summary>Represents a complex number.</summary>
            <remarks>
            <para>Version 4.0 of the .NET Framework introduced a Complex structure equivalent to this one. To maintain compatibility
            with earlier versions of the .NET Framework, Meta.Numerics maintains its own Complex structure.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Complex.Re">
            <summary>
            Gets the real part of the complex number.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Complex.Im">
            <summary>
            Gets the imaginary part of the complex number.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Complex.Conjugate">
            <summary>
            Gets the complex conjugate of the complex number.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Complex.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new complex number.
            </summary>
            <param name="re">The real part of the complex number.</param>
            <param name="im">The imaginary part of the complex number.</param>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Explicit(Meta.Numerics.Complex)~System.Double">
            <summary>
            Converts the complex number to a double-precision real number.
            </summary>
            <param name="z">The complex number to covert.</param>
            <returns>The corresponding double-precision real number.</returns>
            <remarks><para>This explicit cast will fail if the complex number has a non-zero imaginary part.
            If you just want to obtain the real part of a complex number, use the <see cref="P:Meta.Numerics.Complex.Re" /> property.</para></remarks>
            <exception cref="T:System.InvalidCastException">z.Im &#x2260; 0</exception>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Implicit(System.Double)~Meta.Numerics.Complex">
            <summary>
            Converts a double-precision real number to a complex number.
            </summary>
            <param name="x">The double-precision real number to convert.</param>
            <returns>The corresponding complex number.</returns>
            <remarks><para>The complex number output has a zero imaginary part and real part equal to the input number.</para>
            <para>This is an implicit cast; the compiler will apply it automatically whenever a real number is given in a situation
            where a complex number is required.</para></remarks>
        </member>
        <member name="M:Meta.Numerics.Complex.ToString">
            <summary>
            Produces a string representation of the complex number.
            </summary>
            <returns>A string represenation of the complex number.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_UnaryNegation(Meta.Numerics.Complex)">
            <summary>
            Negates a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The argument times -1.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Equality(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Tests the equality of two complex numbers.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>True if the two complex numbers are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Inequality(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Tests the inequality of two complex numbers.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>False if the two complex numbers are equal, otherwise true.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.Equals(System.Object)">
            <summary>
            Determines whether the given object represents the same complex number.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if the object represents the same complex number, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.Equals(Meta.Numerics.Complex)">
            <summary>
            Determines whether the given complex number is the same.
            </summary>
            <param name="other">The complex number to compare.</param>
            <returns>True if the complex number is the same, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.GetHashCode">
            <summary>
            Returns a hash code for the complex number.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Addition(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Adds two complex numbers.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>The sum of the complex numbers.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Subtraction(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Subtracts the second complex number from the first.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>The difference of the complex numbers.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Multiply(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Multiplies two complex numbers.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>The product of the two complex numbers.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Division(Meta.Numerics.Complex,Meta.Numerics.Complex)">
            <summary>
            Divides two complex numbers.
            </summary>
            <param name="z1">The first complex number.</param>
            <param name="z2">The second complex number.</param>
            <returns>The quotient of the two complex numbers.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Multiply(System.Double,Meta.Numerics.Complex)">
            <summary>
            Multiplies a complex number by a real number.
            </summary>
            <param name="a">The real number.</param>
            <param name="z">The complex number.</param>
            <returns>The product az.</returns>
        </member>
        <member name="M:Meta.Numerics.Complex.op_Multiply(Meta.Numerics.Complex,System.Double)">
            <summary>
            Multiplies a real number by a complex number.
            </summary>
            <param name="z">The complex number.</param>
            <param name="a">The real number.</param>
            <returns>The product za.</returns>
        </member>
        <member name="F:Meta.Numerics.Complex.Zero">
            <summary>
            Gets the complex value of zero.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Complex.One">
            <summary>
            Gets the complex value of one.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Complex.I">
            <summary>
            Gets the square root of negative one.
            </summary>
        </member>
        <member name="T:Meta.Numerics.ComplexMath">
            <summary>
            Provides simple functions of complex arguments. 
            </summary>
        </member>
        <member name="P:Meta.Numerics.ComplexMath.I">
            <summary>
            Gets the unit imaginary number I.
            </summary>
            <value>The unit imaginary number.</value>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Abs(Meta.Numerics.Complex)">
            <summary>
            Computes the absolute value of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of |z|.</returns>
            <remarks>
            <para>The absolute value of a complex number is the distance of the number from the origin
            in the complex plane. This is a compatible generalization of the definition of the absolute
            value of a real number.</para>
            </remarks>
            <seealso cref="M:System.Math.Abs(System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Arg(Meta.Numerics.Complex)">
            <summary>
            Computes the phase of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of arg(z).</returns>
            <remarks>
            <para>The phase of a complex number is the angle between the line joining it to the origin and the real axis of the complex plane.</para>
            <para>The phase of complex numbers in the upper complex plane lies between 0 and &#x3C0;. The phase of complex numbers
            in the lower complex plane lies between 0 and -&#x3C0;. The phase of a positive real number is zero.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Exp(Meta.Numerics.Complex)">
            <summary>
            Computes e raised to the power of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of e<sup>z</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Log(Meta.Numerics.Complex)">
            <summary>
            Computes the natrual logarithm of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of ln(z).</returns>
            <remarks>
            <para>The image below shows the complex log function near the origin, using domain coloring.</para>
            <img src="../images/ComplexLogPlot.png" />
            <para>You can see the zero at (0, 1) and the branch cut extending along the negative real axis from the pole at the origin.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Sqr(Meta.Numerics.Complex)">
            <summary>
            Computes the square of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of z<sup>2</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Sqrt(Meta.Numerics.Complex)">
            <summary>
            Computes the square root of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The square root of the argument.</returns>
            <remarks>
            <para>The image below shows the complex square root function near the origin, using domain coloring.</para>
            <img src="../images/ComplexSqrtPlot.png" />
            <para>You can see the branch cut extending along the negative real axis from the zero at the origin.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Sin(Meta.Numerics.Complex)">
            <summary>
            Computes the sine of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of sin(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Sinh(Meta.Numerics.Complex)">
            <summary>
            Computes the hyperbolic sine of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of sinh(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Cos(Meta.Numerics.Complex)">
            <summary>
            Computes the cosine of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of cos(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Cosh(Meta.Numerics.Complex)">
            <summary>
            Computes the hyperbolic cosine of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of cosh(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Tan(Meta.Numerics.Complex)">
            <summary>
            Computes the tangent of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of tan(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Tanh(Meta.Numerics.Complex)">
            <summary>
            Computes the hyperbolic tangent of a complex number.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of tanh(z).</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Pow(Meta.Numerics.Complex,System.Double)">
            <summary>
            Raises a complex number to an arbitrary real power.
            </summary>
            <param name="z">The argument.</param>
            <param name="p">The power.</param>
            <returns>The value of z<sup>p</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Pow(System.Double,Meta.Numerics.Complex)">
            <summary>
            Raises a real number to an arbitrary complex power.
            </summary>
            <param name="x">The real base, which must be non-negative.</param>
            <param name="z">The complex exponent.</param>
            <returns>The value of x<sup>z</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.ComplexMath.Pow(Meta.Numerics.Complex,System.Int32)">
            <summary>
            Raises a complex number to an integer power.
            </summary>
            <param name="z">The argument.</param>
            <param name="n">The power.</param>
            <returns>The value of z<sup>n</sup>.</returns>
        </member>
        <member name="T:Meta.Numerics.NonconvergenceException">
            <summary>
            The exception that is thrown when an algorithm fails to converge.
            </summary>
        </member>
        <member name="M:Meta.Numerics.NonconvergenceException.#ctor">
            <summary>
            Initializes a new nonconvergence exception.
            </summary>
        </member>
        <member name="M:Meta.Numerics.NonconvergenceException.#ctor(System.String)">
            <summary>
            Inititalizes a new nonconvergence exception with the given exception message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:Meta.Numerics.NonconvergenceException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new nonconvergence exception with the given exception message and inner exception.
            </summary>
            <param name="message">The exeption message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Meta.Numerics.DimensionMismatchException">
            <summary>
            The exception that is thrown when attempting an operation on objects with incompatible dimensions.
            </summary>
        </member>
        <member name="M:Meta.Numerics.DimensionMismatchException.#ctor">
            <summary>
            Initializes a new dimension mismatch exception.
            </summary>
        </member>
        <member name="M:Meta.Numerics.DimensionMismatchException.#ctor(System.String)">
            <summary>
            Inititalizes a new dimension mismatch exception with the given exception message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:Meta.Numerics.DimensionMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new dimension mismatch exception with the given exception message and inner exception.
            </summary>
            <param name="message">The exeption message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Meta.Numerics.Interval">
            <summary>
            Represents an interval on the real number line.
            </summary>
            <remarks>
            <para>Use the static methods <see cref="M:Meta.Numerics.Interval.FromEndpoints(System.Double,System.Double)"/>, <see cref="M:Meta.Numerics.Interval.FromMidpointAndWidth(System.Double,System.Double)"/>,
            and <see cref="M:Meta.Numerics.Interval.FromEndpointAndWidth(System.Double,System.Double)"/> to instantiate intervals.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Interval.LeftEndpoint">
            <summary>
            Gets the left (lower) endpoint of the interval.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Interval.RightEndpoint">
            <summary>
            Gets the right (upper) endpoint of the interval.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Interval.OpenContains(System.Double)">
            <summary>
            Determines whether the argument lies in the open interval.
            </summary>
            <param name="x">The argument.</param>
            <returns>True if <paramref name="x"/> lies in (a,b), otherwise False.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.ClosedContains(System.Double)">
            <summary>
            Determines whether the argument lies in the closed interval.
            </summary>
            <param name="x">The argument.</param>
            <returns>True if <paramref name="x"/> lies in [a,b], otherwise False.</returns>
        </member>
        <member name="P:Meta.Numerics.Interval.Width">
            <summary>
            Gets the width of the interval.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Interval.Midpoint">
            <summary>
            Gets the mid-point of the interval.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Interval.FromEndpoints(System.Double,System.Double)">
            <summary>
            Creates a new interval, given its endpoints.
            </summary>
            <param name="a">The left (lower) endpoint of the interval.</param>
            <param name="b">The right (upper) endpoint of the interval.</param>
            <returns>The specified interval.</returns>
            <remarks>If width of the interval is very much smaller than its endpoint values, accuracy will be better maintained by constructing the interval using one endpoint and its width.</remarks>
        </member>
        <member name="M:Meta.Numerics.Interval.FromEndpointAndWidth(System.Double,System.Double)">
            <summary>
            Creates a new interval, given its lower endpoint and width.
            </summary>
            <param name="endpoint">The left (lower) endpoint of the interval.</param>
            <param name="width">The width of the interval.</param>
            <returns>The specified interval.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.FromMidpointAndWidth(System.Double,System.Double)">
            <summary>
            Creates a new interval, given its midpoint and width.
            </summary>
            <param name="midpoint">The midpoint of the interval.</param>
            <param name="width">The width of the interval.</param>
            <returns>The specified interval.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.op_Equality(Meta.Numerics.Interval,Meta.Numerics.Interval)">
            <summary>
            Determines whether two intervals are equal.
            </summary>
            <param name="i1">The first interval.</param>
            <param name="i2">The second interval.</param>
            <returns>True if <paramref name="i1"/> and <paramref name="i2"/> are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.op_Inequality(Meta.Numerics.Interval,Meta.Numerics.Interval)">
            <summary>
            Determines whether two intervals are not equal.
            </summary>
            <param name="i1">The first interval.</param>
            <param name="i2">The second interval.</param>
            <returns>True if <paramref name="i1"/> and <paramref name="i2"/> are not equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.Equals(System.Object)">
            <summary>
            Determines whether a given object is an equal interval.
            </summary>
            <param name="obj">An object.</param>
            <returns>True if <paramref name="obj"/> is an equal <see cref="T:Meta.Numerics.Interval"/>, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Interval.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Interval.ToString">
            <summary>
            Produces a string representation of the interval.
            </summary>
            <returns>A string representation of the interval.</returns>
        </member>
        <member name="T:Meta.Numerics.MoreMath">
            <summary>
            Contains additional basic math operations.
            </summary>
            <remarks>
            <para>The <see cref="T:System.Math"/> class defines many basic math operations, but a few that are important for optimal numerical
            practice are missing. They are defined by this class.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Pow(System.Double,System.Int32)">
            <summary>
            Rasises an argument to an integer power.
            </summary>
            <param name="x">The argument.</param>
            <param name="n">The power.</param>
            <returns>The value of x<sup>n</sup>.</returns>
            <remarks>
            <para>Low integer powers can be computed by optimized algorithms much faster than the general
            alrogithm for an arbitrary real power employed by <see cref="M:System.Math.Pow(System.Double,System.Double)"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Hypot(System.Double,System.Double)">
            <summary>
            Computes the length of a right triangle's hypotenuse.
            </summary>
            <param name="x">The length of one side.</param>
            <param name="y">The length of another side.</param>
            <returns>The length of the hypotenuse, sqrt(x<sup>2</sup> + y<sup>2</sup>).</returns>
            <remarks>
            <para>The length is computed accurately, even in cases where
            x<sup>2</sup> or y<sup>2</sup> would overflow.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.ExpMinusOne(System.Double)">
            <summary>
            Computes e<sup>x</sup>-1.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of e<sup>x</sup>-1.</returns>
            <remarks>
            <para>If x is close to 0, then e<sup>x</sup> is close to 1, and computing e<sup>x</sup>-1 by by subtracting one from
            e<sup>x</sup> as computed by the <see cref="M:System.Math.Exp(System.Double)"/> function will be subject to severe loss of significance due to
            cancelation. This method maintains full precision for all values of x by switching to a series expansion for values of
            x near zero.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.LogOnePlus(System.Double)">
            <summary>
            Computes log(1+x).
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of log(1+x).</returns>
            <remarks>
            <para>If x is close to 0, computing log(1+x) by first adding one and then taking the log can result in a loss of accuracy.
            This function maintains full precision of all values of x by switching to a series expansion for values of x near zero.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Sqr(System.Double)">
            <summary>
            Computes x<sup>2</sup>.
            </summary>
            <param name="x">The argument.</param>
            <returns>The square of the argument.</returns>
            <remarks>
            <para>There is nothing numericaly sophisticated inside this function; it exists simply for programmers' convenience. Given a complicated expression
            that needs to be squared, it is nice to be able to wrap it in a simple call to this function instead of explicitly assigning its value to a new variable and then,
            in a seperate statement, multiplying that variable by itself. Even if you are hyper-vigilant about function call overhead, you should not worry
            about using this function, because even the most basic optimizing compiler will optimize away the call.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Sin(System.Double)">
            <summary>
            Computes the sine of the given value to full significance over the full range of arguments.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of sin(x).</returns>
            <remarks>
            <para>This method addresses several subtle shortcommings of the <see cref="M:System.Math.Sin(System.Double)" /> method.
            One shortcoming, quite striking but rarely encountered, is that <see cref="M:System.Math.Sin(System.Double)"/> returns entirely wrong results very large
            arguments -- for x larger than about 10<sup>20</sup>, it simply returns the argument as the function value!
            (I have no idea
            why the base class library designers did not at least choose to return <see cref="F:System.Double.NaN"/>, so as to signal to the caller
            that the result should not be trusted. No floating point standard specifies this crazy behavior.)
            Another shortcomming, more commonly encountered but often unnoticed, is that for large but not necessarily very large arguments,
            function values loose precision, particularly near zeros of the function.</para>
            <para>
            One way to view these shortcommings is that they are justified by the uncertainty inherent in floating point representations. In this
            view, any <see cref="T:System.Double"/> should be seen as an uncertain value with a relative error of ~10<sup>-16</sup>. If the
            number is very large, then the absolute size of this error can be as large or larger than 2&#x3C0;; in this circumstance we should not
            expect to be able to say anything about the value (except, of course, that it is between -1 and +1, which is violated by the designers' crazy
            choice to return the argument as the value). Even if the absolute error is just a non-negligable faction of 2&#x3C0;, there is a non-neglible fraction
            of the values between -1 and +1 in the corresponding range of function values; any of these values is as possible as any other as a value
            for the sine of our uncertain argument, so we should be satisfied with any returned value in this non-negligible range.
            </para>
            <para>A different view is that it is better regard every representable floating point value as some exact rational number, and
            when computing functions of floating point numbers, to always strive to return the representable floating point value nearest
            to the actual function of that exact rational.
            Callers are unlikely to complain if we are careful in the regard, and this behavior is particularly
            useful when the argument is an intermediate result that the programmer may not even realize has become large.</para>
            <para>For typical arguments, say between 10<sup>-4</sup> and 10<sup>4</sup>, the extra cost of calling this function instead of
            <see cref="M:System.Math.Sin(System.Double)"/> is just a couple of comparisons and a single floating point operation; less than 0.1% of
            arguments in this range are then routed to our much slower, high-accuracy algorithm. We therefore suggest that,
            for general use, you prefer this method over <see cref="M:System.Math.Sin(System.Double)"/>; only in very unusual situations where (i) you are guaranteed
            never to encounter very large arguments, (ii) full precision values are not required, and (iii) the run-time of your
            application is critical and dominated by trigonometric calculations, should you prefer the base class library method.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Cos(System.Double)">
            <summary>
            Computes the cosine of the given value to full significance over the full range of arguments.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of sin(x).</returns>
            <remarks>
            <para>For an explanaition of this method, see the remarks for the <see cref="M:Meta.Numerics.MoreMath.Sin(System.Double)"/> method.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.MoreMath.Mod(System.Int64,System.Int64)">
            <summary>
            Returns the value of n mod m.
            </summary>
            <param name="n">The argument.</param>
            <param name="m">The modulus.</param>
            <returns>The value of n mod m.</returns>
            <remarks>The modulus operator in .NET languages (n % m in C#, n Mod m in VB) returns
            a negative remainder for negative n.
            This is not consistent with the mathematical conventions of modular arithmetic,
            which require that 0 &#x2264; n mod m &lt; m. For example, in C# -7 % 4 returns -3
            (which is simply the negative of 7 % 4), while mathematically -7 mod 4 = 1, as can
            seen by extending the repeating 0, 1, 2, 3 pattern to negative integers. In cases
            where it is important to obtain results consistent mathematical conventions,
            you should call this method, which fixes the .NET result.</remarks>
        </member>
        <member name="T:Meta.Numerics.XY">
            <summary>
            Represents a two-dimensional point.
            </summary>
        </member>
        <member name="M:Meta.Numerics.XY.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new point with the given coordinates.
            </summary>
            <param name="x">The X-corrdinate.</param>
            <param name="y">The Y-coordinate.</param>
        </member>
        <member name="P:Meta.Numerics.XY.X">
            <summary>
            Gets the X-coordinate of the point.
            </summary>
        </member>
        <member name="P:Meta.Numerics.XY.Y">
            <summary>
            Gets the Y-coordinate of the point.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Polynomial">
            <summary>
            Represents a polynomial with real coefficients.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Polynomial.FromCoefficients(System.Double[])">
            <summary>
            Initializes a new polynomial with the given coefficients.
            </summary>
            <param name="coefficients">The coefficients of the polynomial.</param>
            <returns>The specified polynomial.</returns>
            <remarks>
            <para>Coefficients should be arranged from low to high order, so that the kth entry is the coefficient of x<sup>k</sup>. For example,
            to specify the polynomial 5 - 6 x + 7 x<sup>2</sup>, give the values 5, -6, 7.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Polynomial.FromPoints(System.Double[0:,0:])">
            <summary>
            Initializes a new polynomial that passes through the given points.
            </summary>
            <param name="points">An N X 2 array whose first column contains the x values of points and whose second column contains the corresponding y values.</param>
            <returns>A polynomial of degree N-1 that passes through all the given points.</returns>
        </member>
        <member name="M:Meta.Numerics.Polynomial.FromPoints(System.Collections.Generic.ICollection{Meta.Numerics.XY})">
            <summary>
            Initializes a new polynomial that passes through the given points.
            </summary>
            <param name="points">A collection of points.</param>
            <returns>A polynomial that passes through all the given points.</returns>
        </member>
        <member name="P:Meta.Numerics.Polynomial.Degree">
            <summary>
            Gets the degree of the polynomial.
            </summary>
            <remarks>
            <para>The degree of a polynomial is the highest power of the variable that appears. For example, the degree of 5 + 6 x + 7 x<sup>2</sup> is 2.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Polynomial.Coefficient(System.Int32)">
            <summary>
            Gets the specificed coefficient.
            </summary>
            <param name="n">The power of the variable for which the coefficient is desired.</param>
            <returns>The coefficient of x<sup>n</sup>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Polynomial.Evaluate(System.Double)">
            <summary>
            Evaluates the polynomial for the given input value.
            </summary>
            <param name="x">The value of the variable.</param>
            <returns>The value of the polynomial.</returns>
        </member>
        <member name="M:Meta.Numerics.Polynomial.Differentiate">
            <summary>
            Differentiates the polynomial.
            </summary>
            <returns>The derivative of the polynomail.</returns>
        </member>
        <member name="M:Meta.Numerics.Polynomial.Integrate(System.Double)">
            <summary>
            Integrates the polynomail.
            </summary>
            <param name="C">The integration constant.</param>
            <returns>The integral of the polynomial.</returns>
        </member>
        <member name="M:Meta.Numerics.Polynomial.ToString">
            <summary>
            Generates a string representation of the polynomial.
            </summary>
            <returns>A string representation of the polynomial.</returns>
        </member>
        <member name="M:Meta.Numerics.Polynomial.op_UnaryNegation(Meta.Numerics.Polynomial)">
            <summary>
            Negates a polynomial.
            </summary>
            <param name="p">The polynomial.</param>
            <returns>The addative inverse of the polynomial.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is null.</exception>
        </member>
        <member name="M:Meta.Numerics.Polynomial.op_Addition(Meta.Numerics.Polynomial,Meta.Numerics.Polynomial)">
            <summary>
            Computes the sum of two polynomials.
            </summary>
            <param name="p1">The first polynomial.</param>
            <param name="p2">The second polynomial.</param>
            <returns>The sum polynomial.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="p1"/> or <paramref name="p2"/> is null.</exception>
        </member>
        <member name="M:Meta.Numerics.Polynomial.op_Subtraction(Meta.Numerics.Polynomial,Meta.Numerics.Polynomial)">
            <summary>
            Computes the difference of two polynomials.
            </summary>
            <param name="p1">The first polynomial.</param>
            <param name="p2">The second polynomial.</param>
            <returns>The difference polynomial.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="p1"/> or <paramref name="p2"/> is null.</exception>
        </member>
        <member name="M:Meta.Numerics.Polynomial.op_Multiply(Meta.Numerics.Polynomial,Meta.Numerics.Polynomial)">
            <summary>
            Computes the product of two polynomials.
            </summary>
            <param name="p1">The first polynomial.</param>
            <param name="p2">The second polynomial.</param>
            <returns>The product polynomial.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="p1"/> or <paramref name="p2"/> is null.</exception>
        </member>
        <member name="M:Meta.Numerics.Polynomial.Divide(Meta.Numerics.Polynomial,Meta.Numerics.Polynomial,Meta.Numerics.Polynomial@)">
            <summary>
            Computes the quotient of two polynomials.
            </summary>
            <param name="p1">The dividend polynomial.</param>
            <param name="p2">The divisor polynomial.</param>
            <param name="remainder">The remainder polynomial.</param>
            <returns>The quotient polynomial.</returns>
            <remarks>
            <para>p<sub>1</sub> = q p<sub>2</sub> + r</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.UncertainMath">
            <summary>
            Contains methods for computing basic mathematical functions of uncertain values.
            </summary>
            <remarks><para>The methods in this static class perform the same basic mathematical operations as the methods of
            the <see cref="T:System.Math"/> class, accounting for the uncertainty in the inputs to produce a corresponding
            uncertainty in the output.</para>
            <para>As with operations on uncertain values, the methods assume that the uncertainty in input parameters represents the
            standard deviation of a distribution of measurements, and produce a value for the uncertainty in the output which
            represent a corresponding standard deviation, under the assumption that the standard deviations are small relative to
            the best values.</para></remarks>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Sqrt(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the square root of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The square root of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Sin(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the sine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The sine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Cos(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the cosine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The cosine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Tan(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the tangent of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The tanget of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Asin(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the arcsine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The arcsine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Acos(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the arccosine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The arccosine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Atan(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the arctangent of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The arctanget of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Atan2(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Computes the arctangent of the ratio of two uncertain values.
            </summary>
            <param name="x">The argument of the numerator.</param>
            <param name="y">The argument of the denominator.</param>
            <returns>The arctangent of the quotient.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Exp(Meta.Numerics.UncertainValue)">
            <summary>
            Computes e to the power of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of e^<sup>x1</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Log(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the natural logarithm of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of ln(x1).</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Pow(Meta.Numerics.UncertainValue,System.Double)">
            <summary>
            Computes an uncertain value raised to an arbitrary power.
            </summary>
            <param name="x">The argument.</param>
            <param name="p">The power.</param>
            <returns>The argument raised to the specified power.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Sinh(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the hyperbolic sine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The hyperbolic sine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Cosh(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the hyperbolic cosine of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The hyperbolic cosine of the argument.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainMath.Tanh(Meta.Numerics.UncertainValue)">
            <summary>
            Computes the hyperbolic tangent of an uncertain value.
            </summary>
            <param name="x">The argument.</param>
            <returns>The hyperbolic tanget of the argument.</returns>
        </member>
        <member name="T:Meta.Numerics.UncertainValue">
            <summary>
            Represents a value with an associated uncertainty.
            </summary>
        </member>
        <member name="P:Meta.Numerics.UncertainValue.Value">
            <summary>
            Gets the best estimate.
            </summary>
        </member>
        <member name="P:Meta.Numerics.UncertainValue.Uncertainty">
            <summary>
            Gets the uncertainty.
            </summary>
        </member>
        <member name="P:Meta.Numerics.UncertainValue.RelativeUncertainty">
            <summary>
            Gets the relative uncertainty.
            </summary>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.ConfidenceInterval(System.Double)">
            <summary>
            Returns a confidence interval.
            </summary>
            <param name="P">The required confidence level.</param>
            <returns>The associated confidence interval.</returns>
            <remarks><para>This method assumes that the value is normally distributed with a mean equal to <see cref="P:Meta.Numerics.UncertainValue.Value"/>
            and a standard deviation equal to <see cref="P:Meta.Numerics.UncertainValue.Uncertainty"/>.</para></remarks>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new uncertain value.
            </summary>
            <param name="value">The best estimate of the value.</param>
            <param name="uncertainty">The uncertainty in the value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="uncertainty"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.ToString">
            <summary>
            Creates a string representation of the uncertain value.
            </summary>
            <returns>A string of the format <i>value</i> &#x00B1; <i>uncertainty</i>.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Equality(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Determines whether two uncertain values are equal.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>True if the two uncertain values are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Inequality(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Determines whether two uncertain values are not equal.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>True if the two uncertain values not are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.Equals(System.Object)">
            <summary>
            Determines whether the given object represents the same uncertain value.
            </summary>
            <param name="obj">The object.</param>
            <returns>True if the object represents the same reference point, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.GetHashCode">
            <summary>
            Computes a hash code for the uncertain value.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_UnaryNegation(Meta.Numerics.UncertainValue)">
            <summary>
            Negates an uncertain value.
            </summary>
            <param name="x">The uncertain value.</param>
            <returns>The negative of the uncertain value.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Addition(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Adds two uncertain values.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>The sum of the two uncertain values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Subtraction(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Subtracts two uncertain values.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>The difference of the two uncertain values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Multiply(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Multiplies two uncertain values.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>The product of the two uncertain values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Division(Meta.Numerics.UncertainValue,Meta.Numerics.UncertainValue)">
            <summary>
            Divides two uncertain values.
            </summary>
            <param name="v1">The first uncertain value.</param>
            <param name="v2">The second uncertain value.</param>
            <returns>The quotient of the two uncertain values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Addition(System.Double,Meta.Numerics.UncertainValue)">
            <summary>
            Adds an uncertain value to an certain value.
            </summary>
            <param name="v1">The certain value.</param>
            <param name="u2">The uncertain value.</param>
            <returns>The sum of the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Addition(Meta.Numerics.UncertainValue,System.Double)">
            <summary>
            Adds a certain value to an uncertain value.
            </summary>
            <param name="u1">The uncertain value.</param>
            <param name="v2">The certain value.</param>
            <returns>The sum of the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Subtraction(Meta.Numerics.UncertainValue,System.Double)">
            <summary>
            Subtracts a certain value from an uncertain value.
            </summary>
            <param name="u1">The uncertain value.</param>
            <param name="v2">The certain value.</param>
            <returns>The difference between the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Subtraction(System.Double,Meta.Numerics.UncertainValue)">
            <summary>
            Subtracts an uncertain value from a certain value.
            </summary>
            <param name="v1">The certain value.</param>
            <param name="u2">The uncertain vlaue.</param>
            <returns>The difference between the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Multiply(System.Double,Meta.Numerics.UncertainValue)">
            <summary>
            Multiplies a certain value by an uncertain value.
            </summary>
            <param name="v1">The certain value.</param>
            <param name="u2">The uncertain value.</param>
            <returns>The product of the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Multiply(Meta.Numerics.UncertainValue,System.Double)">
            <summary>
            Multiplies an uncertain value by a certain value.
            </summary>
            <param name="u1">The uncertain value.</param>
            <param name="v2">The certain value.</param>
            <returns>The product of the two values.</returns>
        </member>
        <member name="M:Meta.Numerics.UncertainValue.op_Division(Meta.Numerics.UncertainValue,System.Double)">
            <summary>
            Divides an uncertain value by a certain value.
            </summary>
            <param name="u1">The uncertain value.</param>
            <param name="v2">The certain value.</param>
            <returns>The quotient of the two values.</returns>
        </member>
        <member name="T:Meta.Numerics.Functions.AdvancedIntegerMath">
            <summary>
            Contains methods that compute advanced functions of integer arguments.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.Factorial(System.Int32)">
            <summary>
            Computes the factorial of an integer.
            </summary>
            <param name="n">The argument, which must be non-negative.</param>
            <returns>The value of n!.</returns>
            <remarks>
            <para>The factorial of an integer n is the product of all integers from 1 to n. For example, 4! = 4 * 3 * 2 * 1 = 24.</para>
            <para>n! also has a combinatorial intrepretation as the number of permutations of n objects. For example, a set of 3
            objects (abc) has 3! = 6 permutations: (abc), (bac), (cba), (acb), (cab), (bca).</para>
            <para>Because n! grows extremely quickly with increasing n, we return the result as a double, even though
            the value is always an integer. (13! would overlow an int, 21! would overflow a long, 171! overflows even a double.)</para>
            <para>In order to deal with factorials of larger numbers, you can use the <see cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.LogFactorial(System.Int32)"/> method, which
            returns accurate values of ln(n!) even for values of n for which n! would overflow a double.</para>
            <para>The factorial is generalized to non-integer arguments by the &#x393; function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>).</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.LogFactorial(System.Int32)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Factorial"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.LogFactorial(System.Int32)">
            <summary>
            Computes the logrithm of the factorial of an integer.
            </summary>
            <param name="n">The argument, which must be non-negative.</param>
            <returns>The value of ln(n!).</returns>
            <remarks>
            <para>This function provides accurate values of ln(n!) even for values of n which would cause n! to overflow.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.Factorial(System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>
            Computes a binomial coefficient.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <param name="m">The lower argument, which must be non-negative and less than or equal to <paramref name="n"/>.</param>
            <returns>The binomial coefficient C(n, m).</returns>
            <remarks>
            <para>The binomial coefficient C(n, m) is the coefficient of x<sup>m</sup> in the expansion of (1+x)<sup>n</sup>:</para>
            <img src="../images/BinomialExpansion.png" />
            <para>Writing n over m in parenthesis, as in the expression above, is by far the most common notation for binomial
            coefficients, even though it is difficult to write inline.</para>
            <para>C(n,m) can also be given a combinatoric intrepretation as the total number of ways to pick m items from a set of
            n distinct items. For this reason, it is often read as "n choose m".</para>
            <para>For example C(4,2) = 6. This can be seen by expanding (1+x)<sup>4</sup> = 
            1 + 4 x + 6 x<sup>2</sup> + 4 x<sup>3</sup> + x<sup>4</sup> and noting that the coefficient of the x<sup>2</sup> term is 6.
            It can also be seen by considering the four-member set (abcd) and noting that there are 6 possible two-member subests:
            (ab), (ac), (ad), (bc), (bd), (cd).</para>
            <para>Pascal's triangle is a classic graphical representation of binomial coefficients:</para>
            <img src="..\images\PascalsTriangle.png" />
            <para>The nth row of Pascal's triangle consists of the binomial coefficients C(n, 0) to C(n, n). Because of the triangular
            arrangement, the identity C(n+1, m) = C(n, m-1) + C(n, m) corresponds to a rule that each entry is the sum of
            the two neighboring entries from the row above. This rule makes it easy to generate additional rows.
            (Proceeding in this fashion from C(0, 0) to the desired C(n, m) would be a very inefficient algorithm
            for generating C(n, m). It is not how this method is implemented.) Pascal's triangle exhibits many other
            fascinating patterns that arise from various binomial coefficient identities.</para>
            <para>If you need multiple sequential binomial coefficients from a row of Pascal's triangle,
            that is mutiple C(n, m) with the same n and increasing m, it is much more efficient to use
            <see cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.BinomialCoefficients(System.Int32)"/>, which generates the coefficients iteratively, than to call this
            method independently for each one.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative, or <paramref name="m"/> lies outside [0,<paramref name="n"/>].</exception>
            <seealso href="http://en.wikipedia.org/wiki/Binomial_coefficient"/>
            <seealso href="https://en.wikipedia.org/wiki/Pascal's_triangle"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.BinomialCoefficients(System.Int32)">
            <summary>
            Enumerates the binomial coefficients of a given order.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <returns>An enumeration of the binomial coefficients in the nth row of Pascal's triangle.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.BinomialCoefficient(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.DoubleFactorial(System.Int32)">
            <summary>
            Computes the double factorial of the given integer.
            </summary>
            <param name="n">The argument, which must be positive.</param>
            <returns>The value of n!!.</returns>
            <remarks>
            <para>The double factorial of an integer is the product all integers of the same parity, up to and including the integer.
            Thus 5! = 5 * 3 * 1 = 15 and 6! = 6 * 4 * 2 = 48.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso href="http://mathworld.wolfram.com/DoubleFactorial.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.LogDoubleFactorial(System.Int32)">
            <summary>
            Computes the natural logarithm of the double factorial of the given number.
            </summary>
            <param name="n">The argument.</param>
            <returns>The value of ln(n!!).</returns>
            <remarks>
            <para>This return value of this method will not overflow even for values of n for which n!!
            would overflow a <see cref="T:System.Double"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.DoubleFactorial(System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.HarmonicNumber(System.Int32)">
            <summary>
            Computes the given harmonic number.
            </summary>
            <param name="n">The index of the harmonic number to compute, which must be non-negative.</param>
            <returns>The harmonic number H<sub>n</sub>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <remarks>
            <para>H<sub>n</sub> is the nth partial sum of the harmonic series.</para>
            <img src="..\images\HarmonicSeries.png" />
            <para>Since the harmonic series diverges, H<sub>n</sub> grows without bound as n increases, but
            it does so extremely slowly, approximately as log(n).</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.FibonacciNumber(System.Int32)">
            <summary>
            Computes a Fibonacci number.
            </summary>
            <param name="n">The index of the Fibonacci number to compute, which must be non-negative.</param>
            <returns>The nth Fibonacci number F<sub>n</sub>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <see href="http://en.wikipedia.org/wiki/Fibonacci_number"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.BernoulliNumber(System.Int32)">
            <summary>
            Computes the given Bernoulli number.
            </summary>
            <param name="n">The index of the Bernoulli number to compute, which must be non-negative.</param>
            <returns>The Bernoulli number B<sub>n</sub>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <remarks>
            <para>B<sub>n</sub> vanishes for all odd n except n=1. For n about 260 or larger, B<sub>n</sub> overflows a double.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Bernoulli_number"/>
            <seealso href="http://mathworld.wolfram.com/BernoulliNumber.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.StirlingNumber1(System.Int32,System.Int32)">
            <summary>
            Computes a Stirling number of the first kind.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <param name="k">The lower argument, which must lie between 0 and n.</param>
            <returns>The value of the unsigned Stirling number of the first kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative, or <paramref name="k"/>
            lies outside [0, n].</exception>
            <seealso href="https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.StirlingNumbers1(System.Int32)">
            <summary>
            Computes a row of Sterling numbers of the first kind.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <returns>An array with n+1 elements. The element with (zero-based) index k contains the
            unsigned Sterling number of the first kind with upper argument n and lower argument k.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.StirlingNumber2(System.Int32,System.Int32)">
            <summary>
            Computes a Stirling number of the second kind.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <param name="k">The lower argument, which must lie between 0 and n.</param>
            <returns>The value of the Stirling number of the second kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative, or <paramref name="k"/>
            lies outside [0, n].</exception>
            <seealso href="https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.StirlingNumbers2(System.Int32)">
            <summary>
            Computes a row of Stirling numbers of the second kind.
            </summary>
            <param name="n">The upper argument, which must be non-negative.</param>
            <returns>An array with n+1 elements. The element with (zero-based) index k contains the
            Stirling number of the second kind with upper argument n and lower argument k.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.BellNumber(System.Int32)">
            <summary>
            Computes the given Bell number.
            </summary>
            <param name="n">The index of the Bell number to compute, which must be non-negative.</param>
            <returns>The Bell number B<sub>n</sub>.</returns>
            <seealso href="http://en.wikipedia.org/wiki/Bell_number"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.GCF(System.Int64,System.Int64)">
            <summary>
            Computes the greatest common factor of two integers.
            </summary>
            <param name="u">The first integer.</param>
            <param name="v">The second integer.</param>
            <returns>The greatest common factor of <paramref name="u"/> and <paramref name="v"/>.</returns>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.LCM(System.Int64,System.Int64)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.LCM(System.Int64,System.Int64)">
            <summary>
            Computes the least common multiple of two integers.
            </summary>
            <param name="u">The first integer.</param>
            <param name="v">The second integer.</param>
            <returns>The least common multiple of <paramref name="u"/> and <paramref name="v"/>.</returns>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.GCF(System.Int64,System.Int64)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.PowMod(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes a power of an integer in modular arithmetic.
            </summary>
            <param name="b">The base, which must be positive.</param>
            <param name="e">The exponent, which must be positive.</param>
            <param name="m">The modulus, which must be positive.</param>
            <returns>The value of b<sup>e</sup> mod m.</returns>
            <remarks>
            <para>Modular exponentiation is used in many number-theory applications, including
            primality testing, prime factorization, and cryptography.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="b"/>,  <paramref name="e"/>, or <paramref name="m"/> is not positive.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Modular_exponentiation"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.Partitions(System.Int32)">
            <summary>
            Enumerates all partitions of the given integer
            </summary>
            <param name="n">The integer to partition, which must be positive.</param>
            <returns>An enumeration of all partitions of the given integer.</returns>
            <remarks>
            <para>Integer partitions are ways to write an integer as a sum of smaller integers. For example, the integer 4 has 5 partitions: 4,
            3 + 1, 2 + 2, 2 + 1 + 1, and 1 + 1 + 1 + 1.</para>
            <para>Integer partitions appear in combinatoric problems and solutions to problems that may be mapped into combinatoric problems.
            For example, the terms which appear in <a href="http://en.wikipedia.org/wiki/Fa%C3%A0_di_Bruno%27s_formula">Faà di Bruno's formula</a>
            correspond to integer partitions.</para>
            <para>The number of partitions grows very rapidly with n. Since enumerating through partitions does not require us to count them,
            no overflows will occur even for large values of <paramref name="n"/>. However, completing the enumeration of
            such a large number of paritions will take a long time, even though our algorithm produces each partition very quickly. For
            example, there are about two hundred million partitions of the integer 100.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is not positive.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Integer_partition"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedIntegerMath.IsPrime(System.Int32)">
            <summary>
            Determines whether the given integer is prime.
            </summary>
            <param name="n">The integer, which must be positive.</param>
            <returns>True if the integer is prime, otherwise false.</returns>
            <seealso href="http://en.wikipedia.org/wiki/Prime_number"/>
            <seealso href="http://mathworld.wolfram.com/PrimeNumber.html"/>
        </member>
        <member name="T:Meta.Numerics.Functions.AdvancedMath">
            <summary>
            Contains methods that compute advanced functions with real arguments.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.BesselJ(System.Int32,System.Double)">
            <summary>
            Computes the regular Bessel function for integer orders.
            </summary>
            <param name="n">The order parameter.</param>
            <param name="x">The argument.</param>
            <returns>The value of J<sub>n</sub>(x).</returns>
            <remarks>
            <para>For information on the cylindrical Bessel functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Bessel_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.BesselY(System.Int32,System.Double)">
            <summary>
            Computes the irregular Bessel function for integer orders.
            </summary>
            <param name="n">The order parameter.</param>
            <param name="x">The argument.</param>
            <returns>The value of Y<sub>n</sub>(x).</returns>
            <remarks>
            <para>For information on the cylindrical Bessel functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Bessel_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.BesselJ(System.Double,System.Double)">
            <summary>
            Computes the regular Bessel function for real orders.
            </summary>
            <param name="nu">The order parameter.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of J<sub>&#x3BD;</sub>(x).</returns>
            <remarks>
            <para>For information on the cylindrical Bessel functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Bessel_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.BesselY(System.Double,System.Double)">
            <summary>
            Computes the irregual Bessel function for real orders.
            </summary>
            <param name="nu">The order parameter.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of Y<sub>&#x3BD;</sub>(x).</returns>
            <remarks>
            <para>For information on the cylindrical Bessel functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Bessel_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)">
            <summary>
            Computes both solutions of the Bessel differential equation.
            </summary>
            <param name="nu">The order, which must be non-negative.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The values of J<sub>nu</sub>(x), J'<sub>nu</sub>(x), Y<sub>nu</sub>(x), and Y'<sub>nu</sub>(x).</returns>
            <remarks>
            <para>Bessel functions often occur in the analysis of physical phenomena with cylindrical symmetry.
            They satisfy the differential equation:</para>
            <img src="../images/BesselODE.png" />
            <para>Since this is a second order linear equation, it has two linearly independent solutions. The regular Bessel function
            J<sub>&#x3BD;</sub>(x), which is finite at the origin, and the irregular Bessel function Y<sub>&#x3BD;</sub>(x), which diverges
            at the origin. Far from the origin, both functions are oscilatory.</para>
            <para>This method simultaneously computes both Bessel functions and their derivatives. If you need both J and Y, it is faster to call this method once than to call
            <see cref="M:Meta.Numerics.Functions.AdvancedMath.BesselJ(System.Double,System.Double)"/> and <see cref="M:Meta.Numerics.Functions.AdvancedMath.BesselY(System.Double,System.Double)"/> seperately. If on, the other hand, you need only J or only Y, it is faster to
            call the appropriate method to compute the one you need.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="nu"/> or <paramref name="x"/> is negative.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Bessel_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.SphericalBesselJ(System.Int32,System.Double)">
            <summary>
            Computes the regular spherical Bessel function of integer order.
            </summary>
            <param name="n">The order parameter.</param>
            <param name="x">The argument.</param>
            <returns> The value of j<sub>n</sub>(x).</returns>
            <remarks>
            <para>The spherical Bessel functions occur in solutions to the wave equations with spherical symmetry. The
            regular sperhical Bessel functions are finite at the origin, and thus occur in situations where the wave equation is satisfied
            at the origin.</para>
            <para>The regular spherical Bessel functions are related to the regular Bessel functions of half-integer order by
            j<sub>n</sub>(x) = Sqrt(&#x3C0;/2x) J<sub>n+1/2</sub>(x).</para></remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.SphericalBesselY(System.Int32,System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.BesselJ(System.Double,System.Double)"/>
            <seealso href="http://mathworld.wolfram.com/SphericalBesselFunctionoftheFirstKind.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.SphericalBesselY(System.Int32,System.Double)">
            <summary>
            Computes the irregular spherical Bessel function of integer order.
            </summary>
            <param name="n">The order parameter.</param>
            <param name="x">The argument.</param>
            <returns>The value of y<sub>n</sub>(x).</returns>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.SphericalBesselJ(System.Int32,System.Double)"/>
            <seealso href="http://mathworld.wolfram.com/SphericalBesselFunctionoftheSecondKind.html" />
        </member>
        <member name="F:Meta.Numerics.Functions.AdvancedMath.GoldenRatio">
            <summary>
            The golden ratio.
            </summary>
            <remarks><para>The golden ratio &#x3C6; = 1.1618...</para></remarks>
            <seealso href="http://en.wikipedia.org/wiki/Golden_ratio"/>
            <seealso href="http://mathworld.wolfram.com/GoldenRatio.html" />
        </member>
        <member name="F:Meta.Numerics.Functions.AdvancedMath.EulerGamma">
            <summary>
            The Euler constant.
            </summary>
            <remarks><para>The Euler constant &#x3B3; = 0.5772...</para></remarks>
            <seealso href="http://en.wikipedia.org/wiki/Euler_gamma"/>
            <seealso href="http://mathworld.wolfram.com/Euler-MascheroniConstant.html" />
        </member>
        <member name="F:Meta.Numerics.Functions.AdvancedMath.Catalan">
            <summary>
            Catalan's constant.
            </summary>
            <remarks><para>Catalan's constant 0.9159...</para></remarks>
            <seealso href="http://en.wikipedia.org/wiki/Catalan_constant"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Coulomb(System.Int32,System.Double,System.Double)">
            <summary>
            Computes the regular and irregular Coulomb wave functions and their derivatives.
            </summary>
            <param name="L">The angular momentum number, which must be non-negative.</param>
            <param name="eta">The charge parameter, which can be postive or negative.</param>
            <param name="rho">The radial distance parameter, which must be non-negative.</param>
            <returns>The values of F, F', G, and G' for the given parameters.</returns>
            <remarks>
            <para>The Coulomb wave functions are the radial wave functions of a non-relativistic particle in a Coulomb
            potential.</para>
            <para>They satisfy the differential equation:</para>
            <img src="../images/CoulombODE.png" />
            <para>A repulsive potential is represented by &#x3B7; &gt; 0, an attractive potential by &#x3B7; &lt; 0.</para>
            <para>F is oscilatory in the region beyond the classical turning point. In the quantum tunneling region inside
            the classical turning point, F is exponentially supressed and vanishes at the origin, while G grows exponentially and
            diverges at the origin.</para>
            <para>Many numerical libraries compute Coulomb wave functions in the quantum tunneling region using a WKB approximation,
            which accurately determine only the first handfull of digits; our library computes Coulomb wave functions even in this
            computationaly difficult region to nearly full precision -- all but the last 3-4 digits can be trusted.</para>
            <para>The irregular Coulomb wave functions G<sub>L</sub>(&#x3B7;,&#x3C1;) are the complementary independent solutions
            of the same differential equation.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="L"/> or <paramref name="rho"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.CoulombF(System.Int32,System.Double,System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.CoulombG(System.Int32,System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Coulomb_wave_function" />
            <seealso href="http://mathworld.wolfram.com/CoulombWaveFunction.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.CoulombF(System.Int32,System.Double,System.Double)">
            <summary>
            Computes the regular Coulomb wave function.
            </summary>
            <param name="L">The angular momentum number, which must be non-negative.</param>
            <param name="eta">The charge parameter, which can be postive or negative.</param>
            <param name="rho">The radial distance parameter, which must be non-negative.</param>
            <returns>The value of F<sub>L</sub>(&#x3B7;,&#x3C1;).</returns>
            <remarks>
            <para>For information on the Coulomb wave functions, see the remarks on <see cref="M:Meta.Numerics.Functions.AdvancedMath.Coulomb(System.Int32,System.Double,System.Double)" />.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="L"/> or <paramref name="rho"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Coulomb(System.Int32,System.Double,System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.CoulombG(System.Int32,System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Coulomb_wave_function" />
            <seealso href="http://mathworld.wolfram.com/CoulombWaveFunction.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.CoulombG(System.Int32,System.Double,System.Double)">
            <summary>
            Computes the irregular Coulomb wave function.
            </summary>
            <param name="L">The angular momentum number, which must be non-negative.</param>
            <param name="eta">The charge parameter, which can be postive or negative.</param>
            <param name="rho">The radial distance parameter, which must be non-negative.</param>
            <returns>The value of G<sub>L</sub>(&#x3B7;,&#x3C1;).</returns>
            <remarks>
            <para>For information on the Coulomb wave functions, see the remarks on <see cref="M:Meta.Numerics.Functions.AdvancedMath.Coulomb(System.Int32,System.Double,System.Double)" />.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="L"/> or <paramref name="rho"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Coulomb(System.Int32,System.Double,System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.CoulombF(System.Int32,System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Coulomb_wave_function" />
            <seealso href="http://mathworld.wolfram.com/CoulombWaveFunction.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.CarlsonF(System.Double,System.Double,System.Double)">
            <summary>
            Computes the Carslon elliptic integral R<sub>F</sub>.
            </summary>
            <param name="x">The first parameter, which must be non-negative.</param>
            <param name="y">The second parameter, which must be non-negative.</param>
            <param name="z">The third parameter, which must be non-negative.</param>
            <returns>The value of R<sub>F</sub>(x,y,z).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/>, <paramref name="y"/>, or
            <paramref name="z"/> is negative.</exception>
            <remarks>
            <para>The Carlson F integral is:</para>
            <img src="../images/CarlsonFIntegral.png" />
            <para>As can be seen from the integral, all three parameters are equivilent, so R<sub>F</sub> is symmetric with respect to any
            permutation of the parameters.</para>
            <para>The Carlson integrals can be used to express integrals of rational functions. In that sense, they are replacements for
            the Legendre elliptic functions.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticK(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticF(System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Carlson_symmetric_form"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.CarlsonD(System.Double,System.Double,System.Double)">
            <summary>
            Computes the Carlson integral R<sub>D</sub>.
            </summary>
            <param name="x">The first parameter, which must be non-negative.</param>
            <param name="y">The second parameter, which must be non-negative.</param>
            <param name="z">The third parameter, which must be non-negative.</param>
            <returns>The value of R<sub>D</sub>(x, y, z)</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/>, <paramref name="y"/>, or
            <paramref name="z"/> is negative.</exception>
            <remarks>
            <para>The Carlson D integral is:</para>
            <img src="../images/CarlsonDIntegral.png" />
            <para>It is symmetric with respect to the interchange of the first two parameters, but not the third parameter.</para>
            <para>The Carlson integrals can be used to express integrals of rational functions. In that sense, they are replacements for
            the Legendre elliptic functions.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Carlson_symmetric_form"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.CarlsonG(System.Double,System.Double,System.Double)">
            <summary>
            Computes the Carlson integral R<sub>G</sub>.
            </summary>
            <param name="x">The first argument, which must be non-negative.</param>
            <param name="y">The second argument, which must be non-negative.</param>
            <param name="z">The third argument, which must be non-negative.</param>
            <returns>The value of R<sub>G</sub>(x, y, z).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/>, <paramref name="y"/>, or
            <paramref name="z"/> is negative.</exception>
            <remarks>
            <para>The Carlson G integral is:</para>
            <img src="..\images\CarlsonGIntegral.png" />
            <para>As can be seen from the definition, it is symmetric with respect to interchanges of any of its arguments.</para>
            <para>The Carlson integrals can be used to express integrals of rational functions. In that sense, they are replacements for
            the Legendre elliptic functions.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.EllipticK(System.Double)">
            <summary>
            Computes the complete elliptic integral of the first kind.
            </summary>
            <param name="k">The elliptic modulus, which must lie between zero and one.</param>
            <returns>The value of the Legendre integral K(k).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="k"/> lies outside [0, 1].</exception>
            <remarks>
            <para>K(k) is defined as the complete elliptic integral:</para>
            <img src="../images/EllipticKIntegral.png" />
            <para>It appears in the Legendre reduction of integrals of rational funtions.</para>
            <para>Be aware that some authors use the the parameter m = k<sup>2</sup> instead of the modulus k.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticF(System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Elliptic_integral"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.EllipticF(System.Double,System.Double)">
            <summary>
            Computes the incomplete elliptic integral of the first kind.
            </summary>
            <param name="phi">The amplitude (in radians).</param>
            <param name="k">The elliptic modulus, which must lie between zero and one.</param>
            <returns>The value of the Legendre integral F(k).</returns>
            <remarks>
            <para>Legendre's first incomplete elliptic integral is:</para>
            <img src="../images/EllipticFIntegral.png" />
            <para>When the integral angle is &#x3C0;, this function reduces to the complete elliptic integral of the
            first kind (<see cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticK(System.Double)"/>.</para>
            <para>Be aware that some authors use the the parameter m = k<sup>2</sup> instead of the modulus k.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticK(System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.EllipticE(System.Double)">
            <summary>
            Computes the complete elliptic integral of the second kind.
            </summary>
            <param name="k">The elliptic modulus, which must lie between zero and one.</param>
            <returns>The value of the Legendre integral E(k).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="k"/> lies outside [0, 1].</exception>
            <remarks>
            <para>E(k) is defined as the complete elliptic integral:</para>
            <img src="../images/EllipticEIntegral.png" />
            <para>It appears in the Legendre reduction of integrals of rational funtions.</para>
            <para>The perimeter of an ellipse with major axis a and eccentricity e is 4 a E(e).</para>
            <para>Be aware that some authors use the the parameter m = k<sup>2</sup> instead of the modulus k.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticE(System.Double,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Elliptic_integral"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.EllipticE(System.Double,System.Double)">
            <summary>
            Computes the incomplete elliptic integral of the second kind.
            </summary>
            <param name="phi">The amplitude (in radians).</param>
            <param name="k">The elliptic modulus, which must lie between zero and one.</param>
            <returns>The value of E(phi,k).</returns>
            <remarks>
            <para>The incomplete elliptic integral of the second kind is:</para>
            <img src="../images/EllipticEIncompleteIntegral.png" />
            <para>It appears in the Legendre reduction of integrals of rational funtions.</para>
            <para>Be aware that some authors use the the parameter m = k<sup>2</sup> instead of the modulus k.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.EllipticE(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Elliptic_integral"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)">
            <summary>
            Computes the error function.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of erf(x).</returns>
            <remarks>
            <para>The error function can be defined as a Gaussian integral.</para>
            <img src="../images/ErfIntegral.png" />
            <para>The area under a bell curve (<see cref="T:Meta.Numerics.Statistics.Distributions.NormalDistribution"/>) within &#x2213;z
            standard deviations of the mean is given by erf(z/&#x221A;2).</para>
            <para>For large values of x, erf(x) &#x2248; 1 to within floating-point accuracy. To obtain accurate values of erfc(x) = 1 - erf(x)
            in this range, use the <see cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)" /> function.</para>
            <para>The inverse of the error function is available as <see cref="M:Meta.Numerics.Functions.AdvancedMath.InverseErf(System.Double)"/>.</para>
            <para>Values of the error function for complex arguments can be obtained using <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Erf(Meta.Numerics.Complex)"/> method, or using the
            equivalent but re-parameterized <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)"/> function.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Error_function" />
            <seealso href="http://mathworld.wolfram.com/Erf.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)">
            <summary>
            Computes the complementary error function.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of erfc(<paramref name="x"/>) = 1 - erf(<paramref name="x"/>).</returns>
            <remarks>
            <para>The complementary error function can be defined by an integral, or by its relation to the error function.</para>
            <img src="../images/ErfcIntegral.png" />
            <para>The area in the tails of a bell curve ((<see cref="T:Meta.Numerics.Statistics.Distributions.NormalDistribution"/>)
            beyond &#x2213;z standard deviations from the mean is given by erfc(z/&#x221A;2).</para>
            <para>For small values of x, erfc(x) &#x2248; 1 to within floating-point accuracy. To obtain accurate values of erf(x) = 1 - erfc(x)
            in this region, use the <see cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)" /> function.</para>
            <para>The inverse of the complementary error function is available as <see cref="M:Meta.Numerics.Functions.AdvancedMath.InverseErfc(System.Double)"/>.</para>
            <para>Values of the complementary error function for complex arguments can be obtained using the
            <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)"/> function.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)" />
            <seealso href="http://mathworld.wolfram.com/Erfc.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.InverseErfc(System.Double)">
            <summary>
            Computes the inverse complementary error function.
            </summary>
            <param name="y">The value of erfc(x), which must lie between 0 and 1.</param>
            <returns>The corresponding argument x.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="y"/> lies outside [0,1].</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.InverseErf(System.Double)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.InverseErf(System.Double)">
            <summary>
            Computes the inverse error function.
            </summary>
            <param name="y">The error function value erf(x), which must lie between -1 and 1.</param>
            <returns>The corresponding argument x.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="y"/> is outside [-1,1].</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.InverseErfc(System.Double)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Dawson(System.Double)">
            <summary>
            Computes the Dawson integral.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of F(x).</returns>
            <remarks>
            <para>The Dawson function is defined by the integral:</para>
            <img src="../images/DawsonIntegral.png" />
            <para>It is related to the error function for purely imaginary arguments.</para>
            <img src="../images/DawsonErfRelation.png" />
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Dawson_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.FresnelC(System.Double)">
            <summary>
            Computes the Fresnel cosine integral.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of C(x).</returns>
            <remarks>
            <para>The Fresnel cosine integral is defined as:</para>
            <img src="../images/FresnelCIntegral.png" />
            <para>It appears in wave optics in the calculation of diffraction patterns.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.FresnelS(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Fresnel(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Fresnel_integral"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.FresnelS(System.Double)">
            <summary>
            Computes the Fresnel sine integral.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of S(x).</returns>
            <remarks>
            <para>The Fresnel sine integral is defined as:</para>
            <img src="../images/FresnelSIntegral.png" />
            <para>It appears in wave optics in the calculation of diffraction patterns.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.FresnelC(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Fresnel(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Fresnel_integral"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Fresnel(System.Double)">
            <summary>
            Computes the Fresnel cosine and sine integrals.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value C(x) + i S(x).</returns>
            <remarks>
            <para>A plot of all values of this function in the complex plane as x ranges from
            negative infinity to positive infinity is called a Cornu spiral.</para>
            <para>The Fresnel function can be related to the complex error function along the line (1-&#x1D456;).</para>
            <img src="../images/FresnelErfRelation.png" />
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.FresnelS(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.FresnelC(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Fresnel_integral"/>
            <seealso href="http://mathworld.wolfram.com/CornuSpiral.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.IntegralEi(System.Double)">
            <summary>
            Computes the principal value of the exponential integral.
            </summary>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of Ei(x).</returns>
            <remarks>
            <para>The function Ei(x) appears in the evaluation of some indefinite integrals involving exponents and in
            number theory in the approximation li(x) = Ei(ln x) to the cumulative distribution of primes.</para>
            <para>Ei(x) is related to the real part of E<sub>1</sub>(x) for negative arguments by:</para>
            <img src="../images/E1EiRelation.png" />
            <para>To compute Ei(z) in the entire complex plane, use <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Ein(Meta.Numerics.Complex)"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.IntegralE(System.Int32,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.IntegralE(System.Int32,System.Double)">
            <summary>
            Computes the generalized exponential integral.
            </summary>
            <param name="n">The order parameter.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of E<sub>n</sub>(x).</returns>
            <remarks>
            <para>The generalized exponential integral is defined as:</para>
            <img src="../images/EIntegral.png" />
            <para>It is related to the incomplete Gamma function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double,System.Double)"/>)
            for negative, integer shape parameters.</para>
            <img src="../images/EnGammaRelation.png" />
            <para>For n=1, it expressible as a simple power series.</para>
            <img src="../images/E1Series.png" />
            <para>For negative x, E<sub>1</sub>(x) develops an imaginary part, but its real part is given by the Ei(x) function
            (<see cref="M:Meta.Numerics.Functions.AdvancedMath.IntegralEi(System.Double)"/>).</para>
            <img src="../images/E1EiRelation.png" />
            <para>To compute E<sub>1</sub>(z) in the entire complex plane, use <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Ein(Meta.Numerics.Complex)"/>.</para>
            <para>Sometimes the function E<sub>1</sub>(z) is called the exponential integral, and sometimes that name is used
            for Ei(x). In hydrology, E<sub>1</sub>(x) is sometimes called the Well function.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso href="http://mathworld.wolfram.com/En-Function.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.IntegralCi(System.Double)">
            <summary>
            Computes the cosine integral.
            </summary>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of Ci(x).</returns>
            <remarks>
            <para>The cosine integral is defined as:</para>
            <img src="../images/CiIntegral.png" />
            <para>The cosine integral diverges logrithmically to negative inifity at the origin and executes a damped oscilation arround zero as its argument increases.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.IntegralSi(System.Double)">
            <summary>
            Computes the sine integral.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of Si(x).</returns>
            <remarks>
            <para>The sine integral is defined as:</para>
            <img src="../images/SiIntegral.png" />
            <para>The sine integral is zero at the origin and executes a damped oscilation arround &#x3C0;/2 as its argument increases.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.IntegralTi(System.Double)">
            <summary>
            Computes the inverse tangent integral.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of Ti<sub>2</sub>(x).</returns>
            <remarks>
            <para>The inverse tanget integral is defined by:</para>
            <img src="..\images\IntegralTi.png" />
            </remarks>
            <seealso href="http://mathworld.wolfram.com/InverseTangentIntegral.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.LogGamma(System.Double)">
            <summary>
            Computes the natural logrithm of the Gamma function.
            </summary>
            <param name="x">The argument, which must be positive.</param>
            <returns>The log Gamma function ln(&#x393;(x)).</returns>
            <remarks>
            <para>Because &#x393;(x) grows rapidly for increasing positive x, it is often necessary to
            work with its logarithm in order to avoid overflow. This function returns accurate
            values of ln(&#x393;(x)) even for values of x which would cause &#x393;(x) to overflow.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative or zero.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)">
            <summary>
            Computes the Gamma function.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of &#x393;(x).</returns>
            <remarks>
            <para>The Gamma function is a generalization of the factorial (see <see cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.Factorial(System.Int32)"/>) to arbitrary real values.</para>
            <img src="../images/GammaIntegral.png" />
            <para>For positive integer arguments, this integral evaluates to &#x393;(n+1)=n!, but it can also be evaluated for non-integer z.</para>
            <para>Because &#x393;(x) grows beyond the largest value that can be represented by a <see cref="T:System.Double" /> at quite
            moderate values of x, you may find it useful to work with the <see cref="M:Meta.Numerics.Functions.AdvancedMath.LogGamma(System.Double)" /> method, which returns ln(&#x393;(x)).</para>
            <para>To evaluate the Gamma function for a complex argument, use <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Gamma(Meta.Numerics.Complex)" />.</para>
            <h2>Domain, Range, and Accuracy</h2>
            <para>The function is defined for all x. It has poles at all negative integers and at zero; the method returns <see cref="F:System.Double.NaN"/> for these arguments. For positive
            arguments, the value of the function increases rapidly with increasing argument. For values of x greater than about 170, the value of the function exceeds
            <see cref="F:System.Double.MaxValue"/>; for these arguments the method returns <see cref="F:System.Double.PositiveInfinity"/>. The method is accurate to full precision over its entire
            domain.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.Factorial(System.Int32)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.LogGamma(System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Gamma(Meta.Numerics.Complex)" />
            <seealso href="http://en.wikipedia.org/wiki/Gamma_function" />
            <seealso href="http://mathworld.wolfram.com/GammaFunction.html" />
            <seealso href="http://dlmf.nist.gov/5">DLMF on the Gamma Function</seealso>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Psi(System.Double)">
            <summary>
            Computes the digamma function.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value of &#x3C8;(x).</returns>
            <remarks>
            <para>The psi function, also called the digamma function, is the logrithmic derivative of the &#x393; function.</para>
            <img src="../images/DiGamma.png" />
            <para>To evaluate the Psi function for complex arguments, use <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Psi(Meta.Numerics.Complex)" />.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Psi(Meta.Numerics.Complex)"/>
            <seealso href="http://en.wikipedia.org/wiki/Digamma_function" />
            <seealso href="http://mathworld.wolfram.com/DigammaFunction.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Psi(System.Int32,System.Double)">
            <summary>
            Computes the polygamma function.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument.</param>
            <returns>The value of &#968;<sub>n</sub>(x).</returns>
            <remarks>
            <para>The polygamma function gives higher logarithmic derivatives of the Gamma function.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Polygamma_function"/>
            <seealso href="http://mathworld.wolfram.com/PolygammaFunction.html"/>
            <seealso href="http://dlmf.nist.gov/5.15">DLMF on the Polygamma Function</seealso>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Beta(System.Double,System.Double)">
            <summary>
            Computes the Beta function.
            </summary>
            <param name="a">The first parameter, which must be positive.</param>
            <param name="b">The second parameter, which must be positive.</param>
            <returns>The beta function B(a,b).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="a"/> or <paramref name="b"/> is non-positive.</exception>
            <remarks>
            <para>The Beta function can be defined by the integral:</para>
            <img src="..\images\BetaIntegral.png" />
            <para>Equivalently, it can be defined as a commonly occuring ratio of Gamma functions:</para>
            <img src="..\images\BetaGammaRelation.png" />
            <para>When evaluating such a ratio of Gamma functions, it is better to use this method than to call
            <see cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/> three times and form the ratio explicitly. One reason is that this method
            will be faster. Another reason is that, for many values, the individual Gamma functions will overflow
            even though the Beta function does not; this method will not overflow in such cases. There are still
            other cases in which the value of Beta does overflow or underflow a <see cref="T:System.Double"/>; in such cases,
            the method <see cref="M:Meta.Numerics.Functions.AdvancedMath.LogBeta(System.Double,System.Double)"/> will still return an accurate value of its logarithm.</para>
            <para>One place this ratio occurs is in the expression for a binomial coefficient in terms of factorials, so the Beta
            function can used to generalize binomial coefficients (<see cref="M:Meta.Numerics.Functions.AdvancedIntegerMath.BinomialCoefficient(System.Int32,System.Int32)"/>)
            to non-integer values.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Beta_function"/>
            <seealso href="http://mathworld.wolfram.com/BetaFunction.html"/>
            <seealso href="http://dlmf.nist.gov/5.12">DLMF on the Beta Function</seealso>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.LogBeta(System.Double,System.Double)">
            <summary>
            Computes the lograrithm of the Beta function.
            </summary>
            <param name="a">The first parameter, which must be positive.</param>
            <param name="b">The second parameter, which must be positive.</param>
            <returns>The value of ln(B(a,b)).</returns>
            <remarks>
            <para>This function accurately computes ln(B(a,b)) even for values of a and b for which B(a,b) is
            too small or large to be represented by a double.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="a"/> or <paramref name="b"/> is non-positive.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Beta(System.Double,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.LeftRegularizedGamma(System.Double,System.Double)">
            <summary>
            Computes the normalized lower (left) incomplete Gamma function.
            </summary>
            <param name="a">The shape parameter, which must be positive.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of &#x3B3;(a,x)/&#x393;(x).</returns>
            <remarks><para>The incomplete Gamma function is obtained by carrying out the Gamma function integration from zero to some
            finite value x, instead of to infinity. The function is normalized by dividing by the complete integral, so the
            function ranges from 0 to 1 as x ranges from 0 to infinity.</para>
            <para>For large values of x, this function becomes 1 within floating point precision. To determine its deviation from 1
            in this region, use the complementary function <see cref="M:Meta.Numerics.Functions.AdvancedMath.RightRegularizedGamma(System.Double,System.Double)"/>.</para>
            <para>For a=&#x3BD;/2 and x=&#x3C7;<sup>2</sup>/2, this function is the CDF of the &#x3C7;<sup>2</sup> distribution with &#x3BD; degrees of freedom.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="a"/> is negative or zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.RightRegularizedGamma(System.Double,System.Double)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.RightRegularizedGamma(System.Double,System.Double)">
            <summary>
            Computes the normalized upper (right) incomplete Gamma function.
            </summary>
            <param name="a">The shape paraemter, which must be positive.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of &#x393;(a,x)/&#x393;(x).</returns>
            <remarks>
            <para>This function is the complement of the left incomplete Gamma function <see cref="M:Meta.Numerics.Functions.AdvancedMath.LeftRegularizedGamma(System.Double,System.Double)"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="a"/> is negative or zero.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.LeftRegularizedGamma(System.Double,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double,System.Double)">
            <summary>
            Computes the upper incomplete Gamma function.
            </summary>
            <param name="a">The shape parameter, which must be positive.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of &#x393;(a,x).</returns>
            <remarks>
            <para>The incomplete Gamma function is defined by the same integrand as the Gamma function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>),
            but the integral is not taken over the full positive real axis.</para>
            <img src="../images/UpperIncompleteGammaIntegral.png" />
            <para>Like the &#x393; function itself, this function gets large very quickly. For most
            purposes, you will prefer to use the regularized incomplete gamma functions <see cref="M:Meta.Numerics.Functions.AdvancedMath.LeftRegularizedGamma(System.Double,System.Double)"/> and
            <see cref="M:Meta.Numerics.Functions.AdvancedMath.RightRegularizedGamma(System.Double,System.Double)"/>.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Incomplete_Gamma_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Beta(System.Double,System.Double,System.Double)">
            <summary>
            Computes the incomplete Beta function.
            </summary>
            <param name="a">The left shape parameter, which must be non-negative.</param>
            <param name="b">The right shape paraemter, which must be non-negative.</param>
            <param name="x">The integral endpoint, which must lie in [0,1].</param>
            <returns>The value of B<sub>x</sub>(a, b).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="a"/> or <paramref name="b"/> is negative, or
            <paramref name="x"/> lies outside [0, 1].</exception>
            <seealso href="http://mathworld.wolfram.com/IncompleteBetaFunction.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.LeftRegularizedBeta(System.Double,System.Double,System.Double)">
            <summary>
            Computes the regularized incomplete Beta function.
            </summary>
            <param name="a">The left shape parameter, which must be non-negative.</param>
            <param name="b">The right shape paraemter, which must be non-negative.</param>
            <param name="x">The integral endpoint, which must lie in [0,1].</param>
            <returns>The value of I<sub>x</sub>(a, b) = B<sub>x</sub>(a, b) / B(a, b).</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.SphericalHarmonic(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Computes the value of a spherical harmonic function.
            </summary>
            <param name="l">The order, which must be non-negative.</param>
            <param name="m">The sub-order, which must lie between -l and l inclusive.</param>
            <param name="theta">The azimuthal angle &#x3B8;. This angle is usually expressed as between -&#x3C0;/2 and +&#x3C0;/2, with positive values representing the upper hemisphere and negative values representing the lower hemisphere.</param>
            <param name="phi">The cylindrical angle &#x3C6;. This angle is usually expressed as between 0 and 2&#x3C0;, measured counter-clockwise (as seen from above) from the positive x-axis. It is also possible to use negative values to represent clockwise movement. </param>
            <returns>The value of Y<sub>l,m</sub>(&#x3B8;,&#x3C6;).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="l"/> is negative, or <paramref name="m"/> lies outside the range [-l, l].</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.JacobiSn(System.Double,System.Double)">
            <summary>
            Computes the Jacobian elliptic function sn.
            </summary>
            <param name="u">The argument.</param>
            <param name="k">The modulus, which must be between 0 and 1.</param>
            <returns>The value of sn(u,k).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="k"/> lies outside [0, 1].</exception>
            <remarks>
            <para>Be aware that some authors use the parameter m = k^2 instead of the modulus k.</para>
            </remarks>
            <seealso href="https://en.wikipedia.org/wiki/Jacobi_elliptic_functions"/>
            <seealso href="http://mathworld.wolfram.com/JacobiEllipticFunctions.html"/>
            <seealso href="http://dlmf.nist.gov/22"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.JacobiCn(System.Double,System.Double)">
            <summary>
            Compute the Jacobian elliptic function cn.
            </summary>
            <param name="u">The argument.</param>
            <param name="k">The modulus, which must be between 0 and 1.</param>
            <returns>The value of cn(u,k).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="k"/> lies outside [0, 1].</exception>
            <remarks>
            <para>Be aware that some authors use the parameter m = k^2 instead of the modulus k.</para>
            </remarks>
            <seealso href="https://en.wikipedia.org/wiki/Jacobi_elliptic_functions"/>
            <seealso href="http://mathworld.wolfram.com/JacobiEllipticFunctions.html"/>
            <seealso href="http://dlmf.nist.gov/22"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.JacobiDn(System.Double,System.Double)">
            <summary>
            Compute the Jacobian elliptic function dn.
            </summary>
            <param name="u">The argument.</param>
            <param name="k">The modulus, which must be between 0 and 1.</param>
            <returns>The value of dn(u,k).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="k"/> lies outside [0, 1].</exception>
            <remarks>
            <para>Be aware that some authors use the parameter m = k^2 instead of the modulus k.</para>
            </remarks>
            <seealso href="https://en.wikipedia.org/wiki/Jacobi_elliptic_functions"/>
            <seealso href="http://mathworld.wolfram.com/JacobiEllipticFunctions.html"/>
            <seealso href="http://dlmf.nist.gov/22"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.LambertW(System.Double)">
            <summary>
            Computes the Lambert W function.
            </summary>
            <param name="x">The argument, which must be greater than or equal to -1/e.</param>
            <returns>The value W(x).</returns>
            <remarks>
            <para>The Lambert W function solves the transcendental equation W e<sup>W</sup> = x.
            The function appears in a number of contexts, including the solution of differential
            equations and the enumeration of trees.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Lambert_W_function" />
            <seealso href="http://www.apmaths.uwo.ca/~djeffrey/Offprints/W-adv-cm.pdf"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.ModifiedBessel(System.Double,System.Double)">
            <summary>
            Computes modified cylindrical Bessel functions.
            </summary>
            <param name="nu">The order, which must be non-negative.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The values of I, I', K, and K' for the given order and argument.</returns>
            <remarks>
            <para>The modified bessel functions fufill a differential equation similiar to the bessel differential equation.</para>
            <img src="../images/ModifiedBesselODE.png" />
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.ModifiedBesselI(System.Double,System.Double)">
            <summary>
            Computes the regular modified cynlindrical Bessel function.
            </summary>
            <param name="nu">The order parameter.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of I<sub>&#x3BD;</sub>(x).</returns>
            <remarks>
            <para>The modified Bessel functions appear as the solutions of hyperbolic differential equations with
            cylindrical or circular symmetry, for example the conduction of heat through a cylindrical pipe.</para>
            <para>The regular modified Bessel functions are related to the Bessel fuctions with pure imaginary arguments.</para>
            <img src="../images/BesselIBesselJRelation.png" />
            <para>The regular modified Bessel functions increase monotonically and exponentially from the origin.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.ModifiedBesselK(System.Double,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.ModifiedBesselK(System.Double,System.Double)">
            <summary>
            Computes the irregular modified cynlindrical Bessel function.
            </summary>
            <param name="nu">The order parameter.</param>
            <param name="x">The argument.</param>
            <returns>The value of K<sub>&#x3BD;</sub>(x).</returns>
            <remarks>
            <para>The modified Bessel functions are related to the Bessel fuctions with pure imaginary arguments.</para>
            <para>The irregular modified Bessel function decreases monotonically and exponentially from the origin.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.AiryAi(System.Double)">
            <summary>
            Computes the Airy function of the first kind.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value Ai(x).</returns>
            <remarks>
            <para>For information on the Airy functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Airy(System.Double)"/>.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.AiryBi(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Airy_functions" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.AiryBi(System.Double)">
            <summary>
            Computes the Airy function of the second kind.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value Bi(x).</returns>
            <remarks>
            <para>For information on the Airy functions, see <see cref="M:Meta.Numerics.Functions.AdvancedMath.Airy(System.Double)"/>.</para>
            <para>While the notation Bi(x) was chosen simply as a natural complement to Ai(x), it has influenced the common
            nomenclature for this function, which is now often called the "Bairy function".</para>
            </remarks>        
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.AiryAi(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Airy_functions" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Airy(System.Double)">
            <summary>
            Computes both Airy functions and their derivatives.
            </summary>
            <param name="x">The argument.</param>
            <returns>The values of Ai(x), Ai'(x), Bi(x), and Bi'(x).</returns>
            <remarks>
            <para>Airy functions are solutions to the Airy differential equation:</para>
            <img src="../images/AiryODE.png" />
            <para>The Airy functions appear in quantum mechanics in the semiclassical WKB solution to the wave functions in a potential.</para>
            <para>For negative arguments, Ai(x) and Bi(x) are oscilatory. For positive arguments, Ai(x) decreases exponentially and Bi(x) increases
            exponentially with increasing x.</para>
            <para>This method simultaneously computes both Airy functions and their derivatives. If you need both Ai and Bi, it is faster to call
            this method once than to call <see cref="M:Meta.Numerics.Functions.AdvancedMath.AiryAi(System.Double)"/> and <see cref="M:Meta.Numerics.Functions.AdvancedMath.AiryBi(System.Double)"/> seperately. If on, the other hand, you need
            only Ai or only Bi, it is faster to call the appropriate method to compute the one you need.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.AiryAi(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.AiryBi(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Airy_functions" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.DiLog(System.Double)">
            <summary>
            Computes the dilogarathm function, also called Spence's function.
            </summary>
            <param name="x">The argument, which must be less than or equal to unity.</param>
            <returns>The value Li<sub>2</sub>(x).</returns>
            <remarks>
            <para>The dilogarithm can be defined by an infinite sum.</para>
            <img src="../images/DilogSum.png" />
            <para>The function gets is name from the similiarity of this series to the expansion of ln(1-x), the
            difference being that the integer in the denominator is raised to the second power.</para>
            <para>Li<sub>2</sub>(x) is real for -&#x221E; &lt; x &#x2264; 1; for values outside this range,
            use the complex version <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.DiLog(Meta.Numerics.Complex)"/>.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedComplexMath.DiLog(Meta.Numerics.Complex)" />
            <seealso href="http://en.wikipedia.org/wiki/Dilogarithm" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.PolyLog(System.Int32,System.Double)">
            <summary>
            Computes the polylogarithm function.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument, which must be less than or equal to one.</param>
            <returns>The value of Li<sub>n</sub>(x).</returns>
            <remarks>
            <para>The nth polylog of x is defined via the series:</para>
            <img src="..\Images\PolyLogSeries.png" />
            <para>Its name comes from the fact that this is a generalization of the logarithm
            series. For n = 1 it reduces to -log(1-x). For n = 2 it reduces to the <see cref="M:Meta.Numerics.Functions.AdvancedMath.DiLog(System.Double)"/> function.</para>
            <para>The polylogarithm function becomes complex for arguments larger than one.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.Clausen(System.Double)">
            <summary>
            Computes the Clausen integral.
            </summary>
            <param name="t">The argument.</param>
            <returns>The value of Cl<sub>2</sub>(t).</returns>
            <seealso href="http://en.wikipedia.org/wiki/Clausen%27s_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.RiemannZeta(System.Double)">
            <summary>
            Computes the Riemann zeta function.
            </summary>
            <param name="x">The argument.</param>
            <returns>The value &#x3B6;(s).</returns>
            <remarks>
            <para>The Riemann &#x3B6; function can be defined as the sum of the <paramref name="x"/>th inverse power of the natural numbers.</para>
            <img src="../images/ZetaSeries.png" />
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Riemann_zeta_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedMath.DirichletEta(System.Double)">
            <summary>
            Computes the Dirichlet eta function.
            </summary>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value of &#x3B7;(s).</returns>
            <remarks>
            <para>The Dirichlet eta function is the sum of the <paramref name="x"/>th inverse power of the natural numbers,
            with alternating signs.</para>
            <img src="../images/DirichletEtaSeries.png" />
            <para>Because these are just the terms of the Riemann zeta function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.RiemannZeta(System.Double)"/>) with
            alternating signs, it is also called the alternating zeta function.</para>
            <para>It can be related to the Riemann &#x3B6; function.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.RiemannZeta(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Dirichlet_eta_function"/>
        </member>
        <member name="T:Meta.Numerics.Functions.AdvancedComplexMath">
            <summary>
            Contains methods that compute advanced functions of complex arguments.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)">
            <summary>
            Computes the complex Faddeeva function.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The complex value of w(z).</returns>
            <remarks>
            <para>The Faddeeva function w(z) is related to the error function with a complex argument.</para>
            <img src="../images/FaddeevaErfcRelation.png" />
            <para>It also has an integral representation.</para>
            <img src="../images/FaddeevaIntegral.png" />
            <para>For purely imaginary values, it reduces to the complementary error function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)"/>).
            For purely real values, it reduces to Dawson's integral (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Dawson(System.Double)"/>).</para>
            <para>It appears in the computation of the Voigt line profile function V(x;&#x3C3;,&#x3B3;).</para>
            <img src="../images/Voigt.png" />
            <para>Near the origin, w(z) &#x2248; 1. To accurately determine w(z) - 1 in this region, use the <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Erf(Meta.Numerics.Complex)"/>
            function. Away from the origin near the large negative imaginary axis, the magnitude w(z) increases rapidly and
            may overflow.</para>
            <para>The image below shows the complex Faddeeva function near the origin, using domain coloring.</para>
            <img src="../images/ComplexFaddeevaPlot.png" />
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Erf(Meta.Numerics.Complex)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erfc(System.Double)" />
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Dawson(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Voigt_profile" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.Erf(Meta.Numerics.Complex)">
            <summary>
            Computes the complex error function.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The value of erf(z).</returns>
            <remarks>
            <para>This function is the analytic continuation of the error function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)"/>) to the complex plane.</para>
            <para>The image below shows the complex error function near the origin, using domain coloring.</para>
            <img src="../images/ComplexErfPlot.png" />
            <para>The complex error function is entire: it has no poles, cuts, or discontinuities anywhere in the complex plane.</para>
            <para>For pure imaginary arguments, erf(z) reduces to the Dawson integral (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Dawson(System.Double)"/>).</para>
            <para>Away from the origin near the real axis, the real part of erf(z) quickly approaches &#x0b1;1. To accurately determine
            the small difference erf(z) &#8723; 1 in this region, use the <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)"/> function. Away from the origin near
            the imaginary axis, the magnitude of erf(z) increases very quickly. Although erf(z) may overflow in this region, you
            can still accurately determine the value of the product erf(z) exp(z<sup>2</sup>) using the <see cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)"/>
            function.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Erf(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Dawson(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedComplexMath.Faddeeva(Meta.Numerics.Complex)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.Ein(Meta.Numerics.Complex)">
            <summary>
            Computes the entire complex exponential integral.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The value of Ein(z).</returns>
            <remarks>
            <para>The entire exponential integral function can be defined by an integral or an equivalent series.</para>
            <img src="..\images\EinIntegralSeries.png" />
            <para>Both Ei(x) and E<sub>1</sub>(z) can be obtained from Ein(z).</para>
            <img src="..\images\E1EiEinRelation.png" />
            <para>Unlike either Ei(x) or E<sub>1</sub>(z), Ein(z) is entire, that is, it has no poles or cuts anywhere
            in the complex plane.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.IntegralEi(System.Double)"/>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.IntegralE(System.Int32,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.Gamma(Meta.Numerics.Complex)">
            <summary>
            Computes the complex Gamma function.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The complex value of &#x393;(z).</returns>
            <remarks>
            <para>The image below shows the complex &#x393; function near the origin using domain coloring.</para>
            <img src="../images/ComplexGammaPlot.png" />
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Gamma(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Gamma_function" />
            <seealso href="http://mathworld.wolfram.com/GammaFunction.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.LogGamma(Meta.Numerics.Complex)">
            <summary>
            Compute the complex log Gamma function.
            </summary>
            <param name="z">The complex argument, which must have a non-negative real part.</param>
            <returns>The complex value ln(&#x393;(z)).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The real part of <paramref name="z"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.LogGamma(System.Double)" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.Psi(Meta.Numerics.Complex)">
            <summary>
            Computes the complex digamma (&#x3C8;) function.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The value of &#x3C8;(z).</returns>
            <remarks>
            <para>The image below shows the complex &#x3C8; function near the origin using domain coloring.</para>
            <img src="../images/ComplexPsiPlot.png" />
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.Psi(System.Double)" />
            <seealso href="https://en.wikipedia.org/wiki/Digamma_function"/>
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.DiLog(Meta.Numerics.Complex)">
            <summary>
            Computes the complex dilogarithm function, also called Spence's function.
            </summary>
            <param name="z">The complex argument.</param>
            <returns>The value Li<sub>2</sub>(z).</returns>
            <remarks>
            <para>This function is the analyic continuation of the dilogarithm function (<see cref="M:Meta.Numerics.Functions.AdvancedMath.DiLog(System.Double)"/>) into the complex plane.</para>
            <para>The image below shows the complex dilogarithm function near the origin, using domain coloring.</para>
            <img src="../images/ComplexDiLogPlot.png" />
            </remarks>
            <seealso cref="M:Meta.Numerics.Functions.AdvancedMath.DiLog(System.Double)"/>
            <seealso href="http://mathworld.wolfram.com/Dilogarithm.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.AdvancedComplexMath.RiemannZeta(Meta.Numerics.Complex)">
            <summary>
            Computes the Riemann zeta function for complex values.
            </summary>
            <param name="z">The argument.</param>
            <returns>The value of &#x3B6;(z).</returns>
            <remarks>
            <para>As the imaginary part of the argument increases, the computation of the zeta function becomes slower and more difficult.
            The computation time is approximately proprotional to the imaginary part of z. The result also slowly looses accuracy for arguments with
            very large imaginary parts; for arguments with z.Im of order 10^d, approximately the last d digits of the result are suspect.</para>
            <para>The image below shows the complex &#x393; function near the origin using domain coloring. You can see the first non-trivial
            zeros at (1/2, &#177;14.13...) as well as the trivial zeros along the negative real axis.</para>
            <img src="../images/ComplexRiemannZetaPlot.png" />
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Functions.OrthogonalPolynomials">
            <summary>
            Contains methods that compute the values of orthogonal polynomials.
            </summary>
            <remarks>
            <para>Orthogonal polynomials are complete families of polynomials that are orthogonal on a given interval with
            a given integration weight. Because of this property, any function on the interval can be expanded
            in the polynomials in a unique way.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteH(System.Int32,System.Double)">
            <summary>
            Computes the value of a (physicists') Hermite polynomial.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument.</param>
            <returns>The value H<sub>n</sub>(x).</returns>
            <remarks>
            <para>Hermite polynomials are orthogonal on the interval (-&#8734;,+&#8734;) with the
            weight e<sup>-x<sup>2</sup></sup>.</para>
            <img src="../images/HermiteHOrthonormality.png" />
            <para>They appear in the solution of the one-dimensional, quantum mehanical, harmonic oscilator.</para>
            <para>Statisticans' Hermite polynomials (see <see cref="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteHe(System.Int32,System.Double)"/>) are related to physicists' Hermite
            polynomials via H<sub>n</sub>(x) = 2<sup>n</sup>H<sub>n</sub>(x &#x221A;2). Staticians' Hermite polynomials
            do not grow as quickly as physicists', and may therefore be preferable for large values of <paramref name="n"/>
            and <paramref name="x"/> which could overflow <see cref="T:System.Double"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteHe(System.Int32,System.Double)"/>
            <seealso href="http://mathworld.wolfram.com/HermitePolynomial.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteHe(System.Int32,System.Double)">
            <summary>
            Computes the value of a (statisticians') Hermite polynomial.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument.</param>
            <returns>The value He<sub>n</sub>(x).</returns>
            <remarks>
            <para>Hermite polynomials are orthogonal on the interval (-&#8734;,+&#8734;) with a
            weight function equal to the standard normal probability distribution.</para>
            <img src="../images/HermiteHeOrthonormality.png" />
            <para>Their orthonormality relation makes them a useful basis for expressing pertubations
            arround a normal distribution.</para>
            <para>Physicists' Hermite polynomials (see <see cref="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteH(System.Int32,System.Double)"/>) are related to statisticians' Hermite
            polynomials via H<sub>n</sub>(x) = 2<sup>n</sup>H<sub>n</sub>(x &#x221A;2).</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
            <seealso cref="M:Meta.Numerics.Functions.OrthogonalPolynomials.HermiteH(System.Int32,System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Hermite_polynomial" />
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.LaguerreL(System.Int32,System.Double)">
            <summary>
            Computes the value of a Laguerre polynomial.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument, which must be non-negative.</param>
            <returns>The value L<sub>n</sub>(x).</returns>
            <remarks>
            <para>Laguerre functions are orthogonal on the interval [0,+&#8734;) with the weight e<sup>-x</sup>.</para>
            <img src="../images/LaguerreLOrthonormality.png" />
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> or <paramref name="x"/> is negative.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Laguerre_polynomial" />
            <seealso href="http://mathworld.wolfram.com/LaguerrePolynomial.html" />
            <seealso cref="M:Meta.Numerics.Functions.OrthogonalPolynomials.LaguerreL(System.Int32,System.Double,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.LaguerreL(System.Int32,System.Double,System.Double)">
            <summary>
            Computes the value of an associated Laguerre polynomial.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="a">The associated order, which must be greater than -1.</param>
            <param name="x">The argument.</param>
            <returns>The value L<sub>n</sub><sup>a</sup>(x).</returns>
            <remarks>
            <para>The associated Laguerre polynomials are orthonogal on the interval [0,+&#8734;) with the weight
            x<sup>a</sup> e<sup>-x</sup>.</para>
            </remarks>
            <seealso href="http://mathworld.wolfram.com/LaguerrePolynomial.html" />
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.LegendreP(System.Int32,System.Double)">
            <summary>
            Computes the value of a Legendre polynomial.
            </summary>
            <param name="l">The order, which must be non-negative.</param>
            <param name="x">The argument, which must lie on the closed interval between -1 and +1.</param>
            <returns>The value of P<sub>l</sub>(x).</returns>
            <remarks>
            <para>Legendre polynomials are orthogonal on the interval [-1,1].</para>
            <img src="../images/LegendrePOrthonormality.png" />
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="x"/> lies outside [-1,+1].</exception>
            <seealso href="http://en.wikipedia.org/wiki/Legendre_polynomial"/>
            <seealso href="http://mathworld.wolfram.com/LegendrePolynomial.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.LegendreP(System.Int32,System.Int32,System.Double)">
            <summary>
            Computes the value of an associated Legendre polynomial.
            </summary>
            <param name="l">The order, which must be non-negative.</param>
            <param name="m">The associated order, which must lie between -l and l inclusive.</param>
            <param name="x">The argument, which must lie on the closed interval betwen -1 and +1.</param>
            <returns>The value of P<sub>l,m</sub>(x).</returns>
            <remarks>
            <para>Associated Legendre polynomials appear in the definition of the <see cref="M:Meta.Numerics.Functions.AdvancedMath.SphericalHarmonic(System.Int32,System.Int32,System.Double,System.Double)"/> functions.</para>
            <para>For values of l and m over about 150, values of this polynomial can exceed the capacity of double-wide floating point numbers.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Associated_Legendre_polynomials"/>
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.ChebyshevT(System.Int32,System.Double)">
            <summary>
            Computes the value of a Cebyshev polynomial.
            </summary>
            <param name="n">The order, which must be non-negative.</param>
            <param name="x">The argument, which must lie in the closed interval between -1 and +1.</param>
            <returns>The value of T<sub>n</sub>(x).</returns>
            <remarks>
            <para>Chebyshev polynomials are orthogonal on the interval [-1,1] with the weight (1-x<sup>2</sup>)<sup>-1/2</sup>.</para>
            <img src="../images/ChebyshevOrthonormality.png" />
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative, or <paramref name="x"/> lies outside [-1,+1].</exception>
            <seealso href="http://en.wikipedia.org/wiki/Chebyshev_polynomials"/>
            <seealso href="http://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html"/>
        </member>
        <member name="M:Meta.Numerics.Functions.OrthogonalPolynomials.ZernikeR(System.Int32,System.Int32,System.Double)">
            <summary>
            Computes the value of a Zernike polynomial.
            </summary>
            <param name="n">The order paramter, which must be non-negative.</param>
            <param name="m">The index parameter, which must lie between 0 and n.</param>
            <param name="rho">The argument, which must lie between 0 and 1.</param>
            <returns>The value of R<sub>n</sub><sup>m</sup>(&#x3C1;).</returns>
            <remarks>
            <para>Zernike polynomials are orthononal on the interval [0,1] with the weight &#x3C1;.</para>
            <para>They are often used in optics to characterize the imperfections in a lens. In
            this context, the amplitude of each is associated with a name given in the following table.</para>
            <table>
                <tr><th>n</th><th>m</th><th>name</th></tr>
                <tr><td>1</td><td>1</td><td>tilt</td></tr>
                <tr><td>2</td><td>0</td><td>defocus</td></tr>
                <tr><td>2</td><td>2</td><td>astigmatism</td></tr>
                <tr><td>3</td><td>1</td><td>coma</td></tr>
                <tr><td>3</td><td>3</td><td>trefoil</td></tr>
            </table>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Functions.Permutation">
            <summary>
            Represents a permutation.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Permutation"/>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.Dimension">
            <summary>
            Gets the dimension of the permutation.
            </summary>
            <remarks>
            <para>The dimension of a permutation is the number of elements to which the permutation applies.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.IsEven">
            <summary>
            Gets a Boolean value that is true if the permutation is even and false if the permutation is odd.
            </summary>
            <remarks>
            <para>An even permutation moves an even number of elements; an odd permutation moves an odd number of elements.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Even_and_odd_permutations"/>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.ToString">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.ToString(System.String)">
            <summary>
            Converts the permutation to its string representation in the given format.
            </summary>
            <param name="format">A standard or custom permutation format string.</param>
            <returns>The requested string representation of the permutation.</returns>
            <remarks>
            <para>The standard permutation format strings are "M", which produces a map representation, and "C", which produces a cycle representation.
            For explanations of the map and cycle representations of a permutation, see <see cref="M:Meta.Numerics.Functions.Permutation.Parse(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the permutation to its string representation in the given format.
            </summary>
            <param name="format">A standard or custom permutation format string.</param>
            <param name="formatProvider">An object that provides culture-specific formatting information.</param>
            <returns>The requested string represenation of the permutation.</returns>
            <remarks>
            <para>The standard permutation format strings are "M", which produces a map representation, and "C", which produces a cycle representation.
            For explanations of the map and cycle representations of a permutation, see <see cref="M:Meta.Numerics.Functions.Permutation.Parse(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Parse(System.String)">
            <summary>
            Converts a text representation into a permutation.
            </summary>
            <param name="text">A text representation of the permutation.</param>
            <returns>The corresponding permutation.</returns>
            <remarks>
            <para>This method is able to parse both map representations and cycle representations of permutations.</para>
            <para>A map representation of an n-dimensional permutation is a space-seperated list of all integers between 0 and n-1,
            enclosed in square brackets. Each number indicates the index of the location to which the object that appears at
            that location is mapped by the permutation. For example, [2 1 0] denotes the permutation that moves the object
            at index 0 to index 2, does not move the object at index 1, and moves the object at index 2 to index 0. Note
            that the numbers in the map representation are the same as the numbers on the second line of Cauchy's two-line
            notation.</para>
            <para>A cycle representation of an n-dimensional representation is a space-seperated list of all integers between 0 and n-1,
            grouped into cycles by parenthesis. Each cycle indicates that the element at the location with the first index in the cycle is moved to
            the location with the second index in the cycle, the element at the location with the second index in the cycle is moved
            to the location with the third index in the cycle, and so on, until the element at the location with the last index
            is moved to the location with the first index. Thus (0 2)(1) indicates that the elements at locations 0 and 2 change
            places and the element at location 1 is left there.</para>
            <para>Note that (0 2)(1) and [2 1 0] represent the same permutation.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is null.</exception>
            <exception cref="T:System.FormatException"><paramref name="text"/> is not a valid text representation of a permutation.</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.TryParse(System.String,Meta.Numerics.Functions.Permutation@)">
            <summary>
            Attempts to convert a text representation into a permutation.
            </summary>
            <param name="text">A text representaiton of the permutation.</param>
            <param name="output">The corresponding permutation.</param>
            <returns>True if the conversion succeeded, otherwise false.</returns>
            <remarks>
            <para>For information on supported text representations, see <see cref="M:Meta.Numerics.Functions.Permutation.Parse(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Apply``1(System.Collections.Generic.IList{``0})">
            <summary>
            Applies the permutation to a list.
            </summary>
            <typeparam name="T">The type of the list.</typeparam>
            <param name="x">The list.</param>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Inverse">
            <summary>
            Gets the inverse of the permutation.
            </summary>
            <returns>The inverse of the permutation.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.op_Multiply(Meta.Numerics.Functions.Permutation,Meta.Numerics.Functions.Permutation)">
            <summary>
            Multiplies two permutations.
            </summary>
            <param name="a">The first permutation.</param>
            <param name="b">The second permutation.</param>
            <returns>The product permutation ab.</returns>
            <remarks>
            <para>The product ab means first applying b, then applying a. This right-to-left convention arises from the convention that operators are applied to the right.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.Order">
            <summary>
            Gets the order of the permutation.
            </summary>
            <remarks>
            <para>The order of a permutation is the number of times it must be applied in order to return all elements to their original position.
            Stated differently, the order of a permutation is the smallest power to which it must be raised to obtain the identity permutation.</para>
            <para>Some permutations with dimension greater than about 300 have an order larger than <see cref="F:System.Int64.MaxValue"/>; for these permutations
            the returned value will overflow.</para>
            <para>Note that the word order is also used to refer to the number of distinct permutations of a given dimension. That "order" is a property
            of the permutation group. This "order" is a property of each permutation.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.IsIdentity">
            <summary>
            Gets a Boolean value indicating whether the permutation is the identity.
            </summary>
            <value>True if the permutation is the identity, otherwise false.</value>
            <remarks>
            <para>The identity permutation is the permutation that leaves all elements in their original positions.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.IsDerangement">
            <summary>
            Gets a Boolean flag indicating whether the permutation is a derangement.
            </summary>
            <value>True if the permutation is a derangement, otherwise false.</value>
            <remarks>
            <para>A derangement is a permutation that leaves no element in its original position.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.Permutation.IsInvolution">
            <summary>
            Gets a Boolean flag indicating whether the permutation is an involution.
            </summary>
            <value>True if the permutation is an involution, otherwise false.</value>
            <remarks>
            <para>An involution is a permutation that is its own inverse.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Permutations(System.Int32)">
            <summary>
            Generates all permutations of the given dimension.
            </summary>
            <param name="dimension">The number of elements on which the permutations act.</param>
            <returns>All permutations of the given dimension.</returns>
            <remarks>
            <para>The number of permutations of dimension n is n!, which increases very rapidly as n increases. Even in cases
            where n! would overflow a <see cref="T:System.Int32"/> or <see cref="T:System.Int64"/>, we do successfully produce all permutations.
            Of course, in such cases, it will take a long time to enumerate them all.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dimension"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Identity(System.Int32)">
            <summary>
            Returns the identity permutation of the given dimension.
            </summary>
            <param name="dimension">The number of elements on which the permutation acts.</param>
            <returns>The identity permutation of the requested dimension.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.op_Equality(Meta.Numerics.Functions.Permutation,Meta.Numerics.Functions.Permutation)">
            <summary>
            Determines whether two permutations are equal.
            </summary>
            <param name="a">The first permutation.</param>
            <param name="b">The second permutation.</param>
            <returns>True if the two permutations are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.op_Inequality(Meta.Numerics.Functions.Permutation,Meta.Numerics.Functions.Permutation)">
            <summary>
            Determines whether two permutations are not equal.
            </summary>
            <param name="a">The first permutation.</param>
            <param name="b">The second permutation.</param>
            <returns>True if the two permutations are not equal, otherwise true.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Equals(Meta.Numerics.Functions.Permutation)">
            <summary>
            Determines whether the given permutation is equal to the permutation instance.
            </summary>
            <param name="other">The permutation to compare.</param>
            <returns>True if <paramref name="other"/> equals the permutation instance, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.Equals(System.Object)">
            <summary>
            Determines whether the given object is equal to the permutation.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if <paramref name="obj"/> is a permutation equal to the permutation instance, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Functions.Permutation.GetRandomPermutation(System.Int32,System.Random)">
            <summary>
            Get a random permutation.
            </summary>
            <param name="dimension">The number of elements on which the permutation acts.</param>
            <param name="rng">A random number generator.</param>
            <returns>A random permutation of the specified dimension. All permutations of the specified dimension are equally likely.</returns>
        </member>
        <member name="T:Meta.Numerics.Functions.SolutionPair">
            <summary>
            Contains a pair of solutions to a differential equation.
            </summary>
            <remarks>
            <para>Any linear second order differential equation has two independent solutions. For example,
            the Bessel differential equation (<see cref="M:Meta.Numerics.Functions.AdvancedMath.Bessel(System.Double,System.Double)"/>) has solutions J and Y,
            the Coulomb wave equation has solutions F and G,
            and the Airy differential equation has solutions Ai and Bi.</para>
            <para>A solution pair structure contains values for both solutions and for their derivatives. It is often useful to
            have all this information together when fitting boundary conditions.</para>
            <para>Which solution is considered the first and which is considered the second is
            a matter of convention. When one solution is regular (finite) at the origin and the other is not, we take the regular solution
            to be the first.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Functions.SolutionPair.FirstSolutionValue">
            <summary>
            Gets the value of the first solution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.SolutionPair.FirstSolutionDerivative">
            <summary>
            Gets the derivative of the first solution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.SolutionPair.SecondSolutionValue">
            <summary>
            Gets the value of the second solution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.SolutionPair.SecondSolutionDerivative">
            <summary>
            Gets the derivative of the second solution.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Functions.Spin">
            <summary>
            Represents a spinor.
            </summary>
            <remarks>
            <para>From a physicist's point of view, a spinor is an object with a particular quantum-mechanical spin. The quantum state of such
            an object is represented by a <see cref="T:Meta.Numerics.Functions.SpinState"/> object.</para>
            <para>From a mathematician's point of view, a spinor labels an irreducible representation of the SO(3) or SU(2) Lie group.
            Individual vectors within each irreducible representation are represented by <see cref="T:Meta.Numerics.Functions.SpinState"/> objects.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.#ctor(System.Double)">
            <summary>
            Instantiates a new spinor.
            </summary>
            <param name="j">The spin, which must be an integer or half-integer.</param>
        </member>
        <member name="P:Meta.Numerics.Functions.Spin.J">
            <summary>
            Gets the spin of the spinor.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.Spin.SpinZero">
            <summary>
            Gets a spin-0 spinor.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.Spin.SpinOneHalf">
            <summary>
            Gets a spin-1/2 spinor.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.Spin.SpinOne">
            <summary>
            Gets a spin-1 spinor.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.Spin.Dimension">
            <summary>
            Gets the dimension of the spinor.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.States">
            <summary>
            Returns the set of spinor states.
            </summary>
            <returns>An array of spin states that spans the spinor subspace.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.Equals(Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin)">
            <summary>
            Determines whether two spinors are equal.
            </summary>
            <param name="a">The first spin.</param>
            <param name="b">The second spin.</param>
            <returns>True if <paramref name="a"/> and <paramref name="b"/> are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.op_Equality(Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin)">
            <summary>
            Determines whether two spinors are equal.
            </summary>
            <param name="a">The first spin.</param>
            <param name="b">The second spin.</param>
            <returns>True if <paramref name="a"/> and <paramref name="b"/> are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.op_Inequality(Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin)">
            <summary>
            Determines whether two spinors are unequal.
            </summary>
            <param name="a">The first spin.</param>
            <param name="b">The second spin.</param>
            <returns>False if <paramref name="a"/> and <paramref name="b"/> are equal, otherwise true.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.Equals(Meta.Numerics.Functions.Spin)">
            <summary>
            Determines whether the given spinor is equal to this one.
            </summary>
            <param name="s">The spinor to compare.</param>
            <returns>True if <paramref name="s"/> is equal to this one, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.Equals(System.Object)">
            <summary>
            Determines whether the given object represents the same spinor.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if <paramref name="obj"/> is an equal spin, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.GetHashCode">
            <summary>
            Computes a hash function for the spinor.
            </summary>
            <returns>An integer which is guaranteed equal for equal spinors, an unlikely to be equal for unequal spinors.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.Spin.ToString">
            <summary>
            Produces a string representation of the spinor.
            </summary>
            <returns>A string representation of the spinor.</returns>
        </member>
        <member name="T:Meta.Numerics.Functions.SpinMath">
            <summary>
            Contains methods for computing functions of spin and spin states.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinMath.Combine(Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin)">
            <summary>
            Enumerates all the spins that can be obtained by combining two spins.
            </summary>
            <param name="j1">The first spin.</param>
            <param name="j2">The second spin.</param>
            <returns>A list of spins which may be obtained.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinMath.Combine(Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState)">
            <summary>
            Enumerates all spin states that may be obtained by combining two spin states.
            </summary>
            <param name="s1">The first spin state.</param>
            <param name="s2">The second spin state.</param>
            <returns>A list of spin states which may  be obtained.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinMath.ClebschGodron(Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState)">
            <summary>
            Computes a Clebsch-Gordon coefficient.
            </summary>
            <param name="s1">The first spin state.</param>
            <param name="s2">The second spin state.</param>
            <param name="s">The total spin state.</param>
            <returns>The Clebsch-Gordon coefficient measuring the contribution of the given first and
            second spin states to the given total spin state.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinMath.ThreeJ(Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState)">
            <summary>
            Computes a 3j symbol.
            </summary>
            <param name="s1">The first column spin state.</param>
            <param name="s2">The second column spin state.</param>
            <param name="s3">The third column spin state.</param>
            <returns>The 3j symbol.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinMath.SixJ(Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin,Meta.Numerics.Functions.Spin)">
            <summary>
            Computes the value of the 6j symbol for the six given spins.
            </summary>
            <param name="j1">Upper left spin.</param>
            <param name="j2">Upper middle spin.</param>
            <param name="j3">Upper right spin.</param>
            <param name="j4">Lower left spin.</param>
            <param name="j5">Lower middle spin.</param>
            <param name="j6">Lower right spin.</param>
            <returns>The value of {{j1,j2,j3},{j4,j5,j6}}.</returns>
        </member>
        <member name="T:Meta.Numerics.Functions.SpinState">
            <summary>
            Represents the state of a spinor.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.#ctor(System.Double,System.Double)">
            <summary>
            Instantiates a new SpinState with the given spin and magnetic quantum numbers.
            </summary>
            <param name="j">The spin number.</param>
            <param name="m">The magnetic number.</param>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.#ctor(Meta.Numerics.Functions.Spin,System.Double)">
            <summary>
            Instantiates a new SpinState with the given spin and magnetic quantum number.
            </summary>
            <param name="s">The spin.</param>
            <param name="m">The magnetic quantum number.</param>
        </member>
        <member name="P:Meta.Numerics.Functions.SpinState.J">
            <summary>
            Gets the spin value of the spin state.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.SpinState.M">
            <summary>
            Gets the magnetic substate value of the spin state.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Functions.SpinState.Representation">
            <summary>
            Gets the spinor representation to which the spin state belongs.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.op_Equality(Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState)">
            <summary>
            Determines whether two spin states are equal.
            </summary>
            <param name="s1">The first spin state.</param>
            <param name="s2">The second spin state.</param>
            <returns>True if <paramref name="s1"/> and <paramref name="s2"/> are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.op_Inequality(Meta.Numerics.Functions.SpinState,Meta.Numerics.Functions.SpinState)">
            <summary>
            Determines whether two spin states are unequal.
            </summary>
            <param name="s1">The first spin state.</param>
            <param name="s2">The second spin state.</param>
            <returns>False if <paramref name="s1"/> and <paramref name="s2"/> are equal, otherwise true.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.Equals(System.Object)">
            <summary>
            Determines whether the given object represents the same spin state.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if <paramref name="obj"/> is an equal spin state, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.GetHashCode">
            <summary>
            Computes a hash function for the spin state.
            </summary>
            <returns>An integer which is guaranteed equal for equal spin states, an unlikely to be equal for unequal spin states.</returns>
        </member>
        <member name="M:Meta.Numerics.Functions.SpinState.ToString">
            <summary>
            Produces a string representation of the spin state.
            </summary>
            <returns>A string representation of the spin state.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.AnyMatrix`1">
            <summary>
            Describes the form of all matrices.
            </summary>
            <typeparam name="T">The type of the matrix entries.</typeparam>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyMatrix`1.#ctor">
            <summary>
            Initializes a new instance of the AnyMatrix class.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnyMatrix`1.RowCount">
            <summary>
            Gets the number of matrix rows.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnyMatrix`1.ColumnCount">
            <summary>
            Gets the number of matrix columns.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnyMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value of a matrix entry.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
            <returns>The value of the <paramref name="r"/>,<paramref name="c"/> matrix entry.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="r"/> or <paramref name="c"/> is
            outside the valid range.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyMatrix`1.Fill(System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Sets all matrix entries according to a supplied fill function.
            </summary>
            <param name="f">The fill function.</param>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyMatrix`1.ToArray">
            <summary>
            Copies the matrix into an array.
            </summary>
            <returns>A two-dimensional .NET array containing the matrix entries.</returns>
            <remarks>
            <para>The output array is independent of the matrix. Changes to its elements will not change
            the elements of the matrix, and changes to the matrix elements will not be reflected in the array.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnyMatrix`1.IsReadOnly">
            <summary>
            Gets a flag indicating whether the matrix is read-only.
            </summary>
            <remarks>
            <para>Although you can't change the values in a read-only matrix, you can make a writable copy of it.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Matrices.AnyRectangularMatrix">
            <summary>
            Describes the form of all real matrices.
            </summary>
            <remarks>
            <para>This is an abstract class that describes any real matrix. If you wish to create a concrete
            instance of a real, non-square matrix, use the <see cref="T:Meta.Numerics.Matrices.RectangularMatrix"/> class. If, on the
            other hand, you wish to write a function that can operate on any real matrix, it's probably a good
            idea to accept a <see cref="T:Meta.Numerics.Matrices.AnyRectangularMatrix"/>, so that any concrete implementation
            can also be passed into your function.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.#ctor">
            <summary>
            Initializes a new instance of the AnyRectangularMatrix class.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.OneNorm">
            <summary>
            Computes the 1-norm of the matrix.
            </summary>
            <returns>||M||<sub>1</sub></returns>
            <remarks>
            <para>The 1-norm of a matrix is the largest column sum.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.InfinityNorm">
            <summary>
            Computes the &#x221E;-norm of the matrix.
            </summary>
            <returns>||M||<sub>&#x221E;</sub></returns>
            <remarks>
            <para>The &#x221E;-norm of a matrix is the largest row sum.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.FrobeniusNorm">
            <summary>
            Computes the Frobenius-norm of the matrix.
            </summary>
            <returns>||M||<sub>F</sub></returns>
            <remarks>
            <para>The Frobenius-norm of a matrix the square root of the sum of the squares
            of all the elements. In the case of a row or column vector, this reduces
            to the Euclidean vector norm.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.Column(System.Int32)">
            <summary>
            Gets a copy of the specified column.
            </summary>
            <param name="c">The (zero-based) column index.</param>
            <returns>An independent copy of the specified column.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.Row(System.Int32)">
            <summary>
            Gets a copy of the specified row.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <returns>An independent copy of the specified row.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Addition(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Adds any two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum matrix A + B.</returns>
            <remarks>
            <para>Matrix addition is an O(N<sup>2</sup>) process.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Subtraction(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Subtracts any two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The difference matrix A - B.</returns>
            <remarks>
            <para>Matrix subtraction is an O(N<sup>2</sup>) process.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Multiply(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Multiplies any two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The product matrix AB.</returns>
            <remarks>
            <para>For matrix multiplication, the column count of the first matrix must equal the row count of the second
            matrix.</para>
            <para>Matrix multiplication is an O(N<sup>3</sup>) process.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.MultiplySelfByTranspose">
            <summary>
            Computes the product of the matrix and its transpose.
            </summary>
            <returns>The product matrix A A<sup>T</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.MultiplyTransposeBySelf">
            <summary>
            Computes the product of the matrix's transpose and itself.
            </summary>
            <returns>The product matrix A<sup>T</sup> A.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Multiplies any real, rectangular matrix by a real constant.
            </summary>
            <param name="alpha">The constant.</param>
            <param name="A">The matrix.</param>
            <returns>The product matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Multiply(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Multiplies any real, rectangular matrix with a real column vector.
            </summary>
            <param name="A">The matrix.</param>
            <param name="v">The column vector.</param>
            <returns>The product column vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Equality(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Determines whether two matrices are equal.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>True if <paramref name="A"/> and <paramref name="B"/> are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.op_Inequality(Meta.Numerics.Matrices.AnyRectangularMatrix,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Determines whether two matrices are not equal.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>False if <paramref name="A"/> and <paramref name="B"/> are equal, otherwise true.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.Equals(Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Determines whether the given matrix equals the current matrix.
            </summary>
            <param name="other">The matrix to compare.</param>
            <returns>True if the <paramref name="other"/> is equal to the current matrix, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.Equals(System.Object)">
            <summary>
            Determines whether the given object is an equal matrix.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if <paramref name="obj"/> is an equal matrix, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnyRectangularMatrix.GetHashCode">
            <summary>
            Not a valid operation.
            </summary>
            <returns>Throws an <see cref="T:System.NotSupportedException"/>.</returns>
            <remarks>
            <para>The <see cref="M:System.Object.GetHashCode"/> method is used to provide a quick equality test when an object
            is used as a key in a <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="!:Hashtable"/>.
            Since a useful hash code of a matrix would need to involve all its elements, it is not possible to make this a fast operation.
            Also, since matrices are not immutable, they should not be used as hash keys. (A matrix might be changed after it
            had already been used as a key.) For these reasons, requesting a hash code for a matrix is not supported.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">This method always throws this exception.</exception>
        </member>
        <member name="T:Meta.Numerics.Matrices.AnySquareMatrix">
            <summary>
            Describes the form of all real, square matrices.
            </summary>
            <remarks>
            <para>This is an abstract class that describes any real, square matrix. If you wish to create a concrete
            instance of a real, non-square matrix, use the <see cref="T:Meta.Numerics.Matrices.SquareMatrix"/> class. If, on the
            other hand, you wish to write a function that can operate on any real, square matrix, it's probably a good
            idea to accept a <see cref="T:Meta.Numerics.Matrices.AnySquareMatrix"/>, so that your function could operate on any concrete implementation.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnySquareMatrix.Dimension">
            <summary>
            Gets or sets the dimension of the square matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.AnySquareMatrix.RowCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.AnySquareMatrix.ColumnCount">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.AnySquareMatrix.Trace">
            <summary>
            Computes the trace of the square matrix.
            </summary>
            <returns>tr(M)</returns>
            <remarks>
            <para>The trace of a square matrix is the sum of its diagonal elements.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnySquareMatrix.op_Addition(Meta.Numerics.Matrices.AnySquareMatrix,Meta.Numerics.Matrices.AnySquareMatrix)">
            <summary>
            Adds any two real, square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum matrix A + B.</returns>
            <remarks>
            <para>Matrix addition is an O(N<sup>2</sup>) process.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnySquareMatrix.op_Subtraction(Meta.Numerics.Matrices.AnySquareMatrix,Meta.Numerics.Matrices.AnySquareMatrix)">
            <summary>
            Subtracts any two real, square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The difference matrix A - B.</returns>
            <remarks>
            <para>Matrix addition is an O(N<sup>2</sup>) process.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.AnySquareMatrix.op_Multiply(Meta.Numerics.Matrices.AnySquareMatrix,Meta.Numerics.Matrices.AnySquareMatrix)">
            <summary>
            Multiplies any two real, square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The product matrix AB.</returns>
            <remarks>
            <para>Matrix multiplication is an O(N<sup>3</sup>) process.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Matrices.CholeskyDecomposition">
            <summary>
            Represents the Cholesky Decomposition of a symmetric, positive definite matrix. 
            </summary>
            <remarks>
            <para>A Cholesky decomposition represents a matrix as the product of a lower-left triangular matrix and its transpose. For example:</para>
            <img src="../images/CholeskyDecomposition.png" />
            <para>The Choleksy decomposition of a symmetric, positive definite matrix can be obtained using the
            <see cref="M:Meta.Numerics.Matrices.SymmetricMatrix.CholeskyDecomposition"/> method of the <see cref="T:Meta.Numerics.Matrices.SymmetricMatrix"/> class.</para>
            </remarks>
            <example>
            <para>Here is an example that uses a Cholesky decomposition to solve a linear algebra problem.</para>
            <code lang="cs">
            // Solve Ax = b via Cholesky decomposition
            CholeskyDecomposition CD = A.CholsekyDecomposition();
            ColumnVector b = new ColumnVector(1.0, 2.0, 3.0);
            ColumnVector x CD.Solve(b);
            </code>
            </example>
            <seealso cref="M:Meta.Numerics.Matrices.SymmetricMatrix.CholeskyDecomposition"/>
        </member>
        <member name="P:Meta.Numerics.Matrices.CholeskyDecomposition.Dimension">
            <summary>
            Gets the dimension of the system.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.CholeskyDecomposition.SquareRootMatrix">
            <summary>
            Returns the Cholesky square root matrix.
            </summary>
            <returns>A lower-left triangular matrix A, such that A A<sup>T</sup> = M.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.CholeskyDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Computes the solution vector that, when multiplied by the original matrix, produces the given left-hand side vector.
            </summary>
            <param name="rhs">The right-hand-side vector.</param>
            <returns>The left-hand-side (solution) vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.CholeskyDecomposition.Inverse">
            <summary>
            Computes the inverse of the original matrix.
            </summary>
            <returns>M<sup>-1</sup></returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.CholeskyDecomposition.Determinant">
            <summary>
            Computes the determinant of the original matrix.
            </summary>
            <returns>det M</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.ColumnVector">
            <summary>
            A column vector of real numbers.
            </summary>
            <remarks>
            <para>An N-dimensional column vector is an N X 1 dimensional matrix.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.#ctor(System.Int32)">
            <summary>
            Initializes a new column vector with the given dimension.
            </summary>
            <param name="dimension">The dimension of the vector, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Initializes a new column vector from the given component list.
            </summary>
            <param name="list">A list of vector components.</param>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.#ctor(System.Double[])">
            <summary>
            Initializes a new column vector with the given components.
            </summary>
            <param name="list">A list of vector components.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.ColumnVector.RowCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.ColumnVector.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.ColumnVector.Item(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.Transpose">
            <summary>
            Returns the transpose of the column vector.
            </summary>
            <returns>An independent row vector with the same components as the column vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.Copy">
            <summary>
            Returns a copy of the column vector.
            </summary>
            <returns>An independent copy of the column vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.op_Addition(Meta.Numerics.Matrices.ColumnVector,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Computes the sum of two column vectors.
            </summary>
            <param name="v1">The first column vector.</param>
            <param name="v2">The second column vector.</param>
            <returns>The sum <paramref name="v1"/> + <paramref name="v2"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.op_Subtraction(Meta.Numerics.Matrices.ColumnVector,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Computes the difference of two column vectors.
            </summary>
            <param name="v1">The first column vector.</param>
            <param name="v2">The second column vector.</param>
            <returns>The difference <paramref name="v1"/> - <paramref name="v2"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.op_Multiply(System.Double,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Multiplies a column vector by a real, scalar constant.
            </summary>
            <param name="alpha">The real, scalar constant.</param>
            <param name="v">The column vector.</param>
            <returns>The product.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.op_Division(Meta.Numerics.Matrices.ColumnVector,System.Double)">
            <summary>
            Divides a column vector by a real, scalar constant.
            </summary>
            <param name="alpha">The real, scalar constant.</param>
            <param name="v">The column vector.</param>
            <returns>The product.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ColumnVector.op_UnaryNegation(Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Negates a column vector.
            </summary>
            <param name="v">The column vector.</param>
            <returns>-v</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.ComplexEigensystem">
            <summary>
            Represents a collection of complex eigenvalues and eigenvectors.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.ComplexEigensystem.Dimension">
            <summary>
            Gets the dimension of the eigensystem.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.ComplexEigensystem.Eigenvalue(System.Int32)">
            <summary>
            Gets the specified eigenvalue.
            </summary>
            <param name="n">The number of the eigenvalue.</param>
            <returns>The <paramref name="n"/>th eigenvalue.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.ComplexEigensystem.Eigenvector(System.Int32)">
            <summary>
            Gets the specified eigenvector.
            </summary>
            <param name="n">The number of the eigenvector.</param>
            <returns>The <paramref name="n"/>th eigenvector.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.QRDecomposition">
            <summary>
            Represents a QR decomposition of a matrix.
            </summary>
            <remarks>
            <para>A QR decomposition represents a rectangular matrix as the product of a square, orthogonal matrix Q and a rectangular,
            right-upper-triangular matrix R. For example:</para>
            <img src="../images/QRDecomposition.png" />
            <para>The method <see cref="M:Meta.Numerics.Matrices.RectangularMatrix.QRDecomposition"/> of the <see cref="T:Meta.Numerics.Matrices.RectangularMatrix"/> class can be used to QR decompose a
            rectangular matrix.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.QRDecomposition.QMatrix">
            <summary>
            The orthogonal matrix Q.
            </summary>
            <returns>The orthogonal matrix Q.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.QRDecomposition.RMatrix">
            <summary>
            The upper-right triangular matrix R.
            </summary>
            <returns>The upper-right triangular matrix R.</returns>
            <remarks>
            <para>The returned matrix is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.RectangularMatrix.Copy"/> to obtain a writable copy.</para>
            </remarks> 
        </member>
        <member name="M:Meta.Numerics.Matrices.QRDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Solve the system A x = b.
            </summary>
            <param name="rhs">The right-hand-side b.</param>
            <returns>The column vector x for which A x is closest to b.</returns>
        </member>
        <member name="P:Meta.Numerics.Matrices.QRDecomposition.RowCount">
            <summary>
            Get the number of rows in the original matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.QRDecomposition.ColumnCount">
            <summary>
            Gets the number of columns in the original matrix.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Matrices.RealEigensystem">
            <summary>
            Represents a collection of real eigenvalues and eigenvectors.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.RealEigensystem.Dimension">
            <summary>
            Gets the dimension of the eigensystem.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.RealEigensystem.Eigenvalue(System.Int32)">
            <summary>
            Gets a specified eigenvalue.
            </summary>
            <param name="n">The (zero-based) index of the eigenvalue.</param>
            <returns>The <paramref name="n"/>th eigenvalue.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RealEigensystem.Eigenvector(System.Int32)">
            <summary>
            Gets a specified eigenvector.
            </summary>
            <param name="n">The (zero-based) index of the eigenvector.</param>
            <returns>The <paramref name="n"/>th eigenvector.</returns>
            <remarks>
            <para>The returned vector is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.ColumnVector.Copy"/> to obtain a writable copy.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Matrices.RealEigensystem.TransformMatrix">
            <summary>
            Gets the transformation matrix that diagonalizes the original matrix.
            </summary>
            <value>The orthogonal matrix V such that V<sup>T</sup>AV = D, where A is the orignal matrix and D is diagonal.</value>
            <remarks>
            <para>The returned matrix is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.SquareMatrix.Copy"/> to obtain a writable copy.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.RealEigensystem.Sort(Meta.Numerics.Matrices.OrderBy)">
            <summary>
            Sort the eigenvalues as specified.
            </summary>
            <param name="order">The desired ordering.</param>
        </member>
        <member name="T:Meta.Numerics.Matrices.OrderBy">
            <summary>
            Describes an ordering of eigenvalues.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Matrices.OrderBy.ValueAscending">
            <summary>
            From most negative to most positive.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Matrices.OrderBy.ValueDescending">
            <summary>
            From most positive to most negative.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Matrices.OrderBy.MagnitudeAscending">
            <summary>
            From smallest absolute value to largest absolute value.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Matrices.OrderBy.MagnitudeDescending">
            <summary>
            From largest absolute value to smallest absolute value.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Matrices.RectangularMatrix">
            <summary>
            A rectangular matrix of real numbers.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a rectangular matrix with the given dimensions.
            </summary>
            <param name="rowCount">The number of rows.</param>
            <param name="columnCount">The number of columns.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="rowCount"/> or <paramref name="columnCount"/>
            is less than one.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Initializes a rectangular matrix from the given 2D array.
            </summary>
            <param name="source">The source 2D array.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.RectangularMatrix.Item(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.RectangularMatrix.RowCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.RectangularMatrix.ColumnCount">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.OneNorm">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.InfinityNorm">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.Column(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.Row(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Addition(Meta.Numerics.Matrices.RectangularMatrix,Meta.Numerics.Matrices.RectangularMatrix)">
            <summary>
            Adds two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum matrix <paramref name="A"/> + <paramref name="B"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Subtraction(Meta.Numerics.Matrices.RectangularMatrix,Meta.Numerics.Matrices.RectangularMatrix)">
            <summary>
            Subtracts two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum matrix <paramref name="A"/> - <paramref name="B"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Multiply(Meta.Numerics.Matrices.RectangularMatrix,Meta.Numerics.Matrices.RectangularMatrix)">
            <summary>
            Multiplies two real, rectangular matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The product matrix AB.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.RectangularMatrix)">
            <summary>
            Multiply a real, rectangular matrix by a real constant.
            </summary>
            <param name="alpha">The constant.</param>
            <param name="A">The matrix.</param>
            <returns>The product aA.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Multiply(Meta.Numerics.Matrices.RectangularMatrix,System.Double)">
            <summary>
            Divides a real, rectangular matrix by a real constant.
            </summary>
            <param name="A">The matrix.</param>
            <param name="alpha">The constant.</param>
            <returns>The quotient A/a.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_UnaryNegation(Meta.Numerics.Matrices.RectangularMatrix)">
            <summary>
            Negates a real, rectangular matrix.
            </summary>
            <param name="A">The matrix.</param>
            <returns>The matrix -A.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.Copy">
            <summary>
            Copies the matrix.
            </summary>
            <returns>An indpendent copy of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.Transpose">
            <summary>
            Returns the transpose of the matrix.
            </summary>
            <returns>M<sup>T</sup></returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.QRDecomposition">
            <summary>
            Computes the QR decomposition of the matrix.
            </summary>
            <returns>The QR decomposition of the matrix.</returns>
            <remarks>
            <para>Only matrices with a number of rows greater than or equal to the number of columns can be QR decomposed. If your
            matrix has more columns than rows, you can QR decompose its transpose.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Matrices.RectangularMatrix.QRDecomposition"/>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.SingularValueDecomposition">
            <summary>
            Computes the singular value decomposition of the matrix.
            </summary>
            <returns>The SVD of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Multiply(Meta.Numerics.Matrices.RectangularMatrix,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Computes the product of a rectangular matrix and a column vector.
            </summary>
            <param name="A">The matrix.</param>
            <param name="v">The column vector.</param>
            <returns>The column vector Av.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="v"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The column count of <paramref name="A"/> is not the same as the dimension of <paramref name="v"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.RectangularMatrix.op_Explicit(Meta.Numerics.Matrices.RectangularMatrix)~Meta.Numerics.Matrices.SquareMatrix">
            <summary>
            Casts a rectangular matrix to a square matrix.
            </summary>
            <param name="A">The matrix to cast, which must have an equal number of rows and columns.</param>
            <returns>A square matrix, not independent of the original matrix.</returns>
            <remarks>
            <para>It can occur that the mode of construction of a RectangularMatrix guarantees that it is
            actually square. For example, if you multiply an N X M rectangular matrix by an M X N rectangular matrix,
            the result is an N X N square matrix. However, when determining the type of the product, the .NET
            compiler considers only the types of the multiplicants. Since a RectangularMatrix times a RectangularMatrix
            yields a RectangularMatrix, it will consider the type of the product to be RetangularMatrix, even though
            its rows and column dimensions will be equal. You can use this explicit cast to obtain a SquareMatrix type.
            </para>
            <para>Note that the output of the cast is not independent of the original matrix. This makes the cast operation
            fast, but changes to the resulting SquareMatrix will also change the original RectangularMatrix. To obtain
            an independent matrix, use the <see cref="M:Meta.Numerics.Matrices.RectangularMatrix.Copy"/> method.</para>
            </remarks>
            <exception cref="T:System.InvalidCastException">The row and column dimensions of the matrix are not equal.</exception>
        </member>
        <member name="T:Meta.Numerics.Matrices.RowVector">
            <summary>
            A row vector of real numbers.
            </summary>
            <remarks>
            <para>An N-dimensional row vector is an 1 X N dimensional matrix.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.#ctor(System.Int32)">
            <summary>
            Initializes a new row vector with the given dimension.
            </summary>
            <param name="dimension">The dimension of the vector, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Initializes a new row vector from the given component list.
            </summary>
            <param name="list">A list of vector components.</param>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.#ctor(System.Double[])">
            <summary>
            Initializes a new row vector with the given components.
            </summary>
            <param name="list">A list of vector components.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.RowVector.RowCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.RowVector.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.RowVector.Item(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.Transpose">
            <summary>
            Returns the transpose of the row vector.
            </summary>
            <returns>An independent column vector with the same components as the row vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.Copy">
            <summary>
            Returns a copy of the row vector.
            </summary>
            <returns>An independent copy of the row vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Addition(Meta.Numerics.Matrices.RowVector,Meta.Numerics.Matrices.RowVector)">
            <summary>
            Computes the sum of two row vectors.
            </summary>
            <param name="v1">The first row vector.</param>
            <param name="v2">The second row vector.</param>
            <returns>The sum <paramref name="v1"/> + <paramref name="v2"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Subtraction(Meta.Numerics.Matrices.RowVector,Meta.Numerics.Matrices.RowVector)">
            <summary>
            Computes the difference of two column vectors.
            </summary>
            <param name="v1">The first column vector.</param>
            <param name="v2">The second column vector.</param>
            <returns>The difference <paramref name="v1"/> - <paramref name="v2"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Multiply(System.Double,Meta.Numerics.Matrices.RowVector)">
            <summary>
            Multiplies a row vector by a real, scalar constant.
            </summary>
            <param name="alpha">The real, scalar constant.</param>
            <param name="v">The row vector.</param>
            <returns>The product.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Division(Meta.Numerics.Matrices.RowVector,System.Double)">
            <summary>
            Divides a row vector by a real, scalar constant.
            </summary>
            <param name="alpha">The real, scalar constant.</param>
            <param name="v">The row vector.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_UnaryNegation(Meta.Numerics.Matrices.RowVector)">
            <summary>
            Negates a row vector.
            </summary>
            <param name="v">The row vector.</param>
            <returns>-v</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Multiply(Meta.Numerics.Matrices.RowVector,Meta.Numerics.Matrices.AnyRectangularMatrix)">
            <summary>
            Multiplies any real, rectangular matrix by a row vector.
            </summary>
            <param name="v">The row vector.</param>
            <param name="A">The matrix.</param>
            <returns>The product row vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.RowVector.op_Multiply(Meta.Numerics.Matrices.RowVector,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Computes the inner (scalar or dot) product of a row and a column vector.
            </summary>
            <param name="v">The row vector.</param>
            <param name="u">The column vector.</param>
            <returns>The value of the scalar product.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.SingularValueDecomposition">
            <summary>
            Stores the singular value decomposition of a matrix.
            </summary>
            <remarks>
            <para>The singular value decomposition of a matrix represents it as a product of a left orthogonal matrix U, a quasi-diagonal
            &#x3A3; matrix, and a right orthogonal matrix V.</para>
            <img src="../images/SVDEquation.png" />
            <para>Any rectangular matrix has an SVD decomposition. The matrix need not be square. If square, it need not be invertable.
            The dimensions of the decomposition factors are illustrated in the following diagram.</para>
            <img src="../images/SVDForm.png" />
            <para>The elements of the &#x3A3; are called the singular values of the original matrix.</para>
            <para>Viewing A as a linear operator, the rows of V<sup>T</sup> (columns of V) form an
            orthonormal basis for the domain of the operator, while the columns of U form an orthonormal
            basis for the range of the operator. These rows and columns are called, respectively, the right and left singular vectors
            of the matrix.</para>
            <para>The right singular vectors corresponding to zero singular values span the nullspace of A, that is the
            set of all x for which Ax = 0. The left singular vectors corresponding to non-zero singular values span the range of A,
            that is the space into which all Ax fall; the left singular vectors corresponding to zero singular values span the
            complementary space into which no Ax fall. The total number of non-zero singular values is the rank of A.</para>
            <para>The SVD can be used to approximate the action of a high-dimensional matrix operator by a lower-rank one. By
            keeping only the largest singular values and setting the remaining ones to zero, one obtains a operator that
            can applied with fewer operations and approximates the properties of the original operator.</para>
            <para>Notice that elements in the last columns of U do not contribute to A since they will be multiplied with elements of zero rows of &#x3A3;.
            Many applications use a "thin" or "reduced" form of the SVD, in which the last columns of U and the last rows of &#x3A3; are omitted;
            this makes U not square (and therefore not orthogonal) and &#x3A3; square (and diagonal). Since the remaining elements are the same, you
            can obtain the thin SVD from this object by simply ignoring the irrelevent elements.</para>
            <para>Use the <see cref="M:Meta.Numerics.Matrices.RectangularMatrix.SingularValueDecomposition"/> of the <see cref="T:Meta.Numerics.Matrices.RectangularMatrix"/> class
            to obtain the SVD of an rectangular matrix, or the corresponding <see cref="M:Meta.Numerics.Matrices.SquareMatrix.SingularValueDecomposition"/>
            method of the <see cref="T:Meta.Numerics.Matrices.SquareMatrix"/> class to obtain the SVD of a square matrix.</para>
            </remarks>
            <see href="http://en.wikipedia.org/wiki/Singular_value_decomposition"/>
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.RowCount">
            <summary>
            Gets the number of rows in the original matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.ColumnCount">
            <summary>
            Gets the number of columns in the original matrix.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.LeftTransformMatrix">
            <summary>
            Returns the left transform matrix.
            </summary>
            <returns>The matrix U, such that A = U S V<sup>T</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.RightTransformMatrix">
            <summary>
            Returns the right transform matrix.
            </summary>
            <returns>The matrix V, such that A = U S V<sup>T</sup>.</returns>
            <remarks>
            <para>The returned matrix is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.SquareMatrix.Copy"/> to obtain a writable copy.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.Dimension">
            <summary>
            Gets the number of singular values.
            </summary>
            <remarks>
            <para>For a square matrix, the number of singular values is equal to the dimension of the matrix.
            For a rectangular matrix with more rows than columns, the number of singular values is equal to
            the number of columns.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.SingularValue(System.Int32)">
            <summary>
            Gets the specificed singular value.
            </summary>
            <param name="n">The (zero-based) index.</param>
            <returns>The <paramref name="n"/>th singular value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> lies outside the range [0, <see cref="P:Meta.Numerics.Matrices.SingularValueDecomposition.Dimension"/> - 1].</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.LeftSingularVector(System.Int32)">
            <summary>
            Returns the specified left singular vector.
            </summary>
            <param name="n">The (zero-based) index.</param>
            <returns>The <paramref name="n"/>th left singular vector.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> lies outside the range [0, <see cref="P:Meta.Numerics.Matrices.SingularValueDecomposition.Dimension"/> - 1].</exception>
            <remarks>
            <para>The returned vector is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.ColumnVector.Copy"/> to obtain a writable copy.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.RightSingularVector(System.Int32)">
            <summary>
            Returns the specified right singular vector.
            </summary>
            <param name="n">The (zero-based) index.</param>
            <returns>The <paramref name="n"/>th right singular vector.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> lies outside the range [0, <see cref="P:Meta.Numerics.Matrices.SingularValueDecomposition.Dimension"/> - 1].</exception>
            <remarks>
            <para>The returned vector is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.ColumnVector.Copy"/> to obtain a writable copy.</para>
            </remarks> 
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.ConditionNumber">
            <summary>
            Returns the condition number of the matrix.
            </summary>
            <remarks>
            <para>The conidition number is the ratio of the largest singular value to smallest singular value. It is therefore always larger than one.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.Tolerance">
            <summary>
            Gets or sets the tolerance with which singular values are distinguished from zero.
            </summary>
            <remarks>
            <para>Some operations offered by singular value decompositions, including rank determination and computation of the pseudo-inverse matrix,
            depend on determining whether or not a singular value is zero. Since floating point numbers are only approximate representations of real
            numbers, singular values will usually not be exactly zero even for matrices for which they should be, but will instead be very tiny
            numbers, on the order of floating point precision (about 10<sup>-16</sup>) as a fraction of the largest singular value. The value
            of this property is used to determine how small a singular value must be, as a fraction of the largest singular value, to be considered
            zero for these purposes. Usually you will want to maintain its default value.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The assigned value is outside the range [0,1).</exception>
        </member>
        <member name="P:Meta.Numerics.Matrices.SingularValueDecomposition.Rank">
            <summary>
            Computes the rank of the original matrix.
            </summary>
            <remarks>
            <para>The rank of a matrix is the dimension of the space of input vectors which produce non-zero output vectors upon multiplication by the original matrix.</para>
            <para>Since this operation depends on identifying zero singular values, the result will depend on the value of the <see cref="P:Meta.Numerics.Matrices.SingularValueDecomposition.Tolerance"/> property.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SingularValueDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Solves the system of equations Ax = b, where A is the original, square matrix.
            </summary>
            <param name="rhs">The right-hand-side vector b.</param>
            <returns>The solution vector x.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException"><paramref name="rhs"/> does not have the same dimension as the original matrix.</exception>
            <exception cref="T:System.InvalidOperationException">The original matrix is not square.</exception>
            <remarks>
            <para>For singular and nearly-singular matrices, this method operates differently than other solution methods like
            <see cref="M:Meta.Numerics.Matrices.SquareQRDecomposition.Solve(System.Collections.Generic.IList{System.Double})"/> and <see cref="M:Meta.Numerics.Matrices.LUDecomposition.Solve(System.Collections.Generic.IList{System.Double})"/>.
            For singular and nearly-singular matrices, those methods
            tend to produce very large or even infinite solution components that delicately cancel to produce the required right-hand-side,
            but have little significance to the problem being modeled because they arise from inverting very small singular values
            of the original matrix that are dominated by floating point rounding errors. The SVD solution discards those singular
            values to obtain a solution vector driven by the dominant, non-singular parts of A. While this solution does not have
            the minimum achievable |Ax - b|, it is often more representative of the desired solution to the problem being modeled.
            </para>
            <para>For original matrices that are not singular or nearly-singular, this method will compute the same solution
            as other methods.</para>
            <para>This method is only available for square original matrices.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Matrices.SparseSquareMatrix">
            <summary>
            Represents a sparse, square matrix.
            </summary>
            <remarks>
            <para>Many applications give rise to very large matrices which consist mostly of zero elements.</para>
            <para>When working with sparse matrices, it is important to keep in mind that many operations do not respect sparsity.
            For example, the product of two sparse matrices is not necessarily sparse, nor is the inverse of a sparse matrix.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new sparse, square matrix.
            </summary>
            <param name="dimension">The dimension of the matrix, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.SparseSquareMatrix.Dimension">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.SparseSquareMatrix.Item(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Matrices.SparseSquareMatrix.FillCount">
            <summary>
            Gets the number of non-zero matrix entries.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.SparseSquareMatrix.FillFraction">
            <summary>
            Gets the fraction of matrix entries that are non-zero.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.Row(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.Column(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.Copy">
            <summary>
            Copies the matrix.
            </summary>
            <returns>An independent copy of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.SparseSquareMatrix)">
            <summary>
            Multiplies a sparse matrix by a real scalar.
            </summary>
            <param name="alpha">The scalar value.</param>
            <param name="A">The sparse matrix.</param>
            <returns>The product sparse matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.op_Multiply(Meta.Numerics.Matrices.SparseSquareMatrix,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Multiplies a column vector by a sparse matrix.
            </summary>
            <param name="A">The matrix.</param>
            <param name="v">The column vector.</param>
            <returns>The product column vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.op_Multiply(Meta.Numerics.Matrices.RowVector,Meta.Numerics.Matrices.SparseSquareMatrix)">
            <summary>
            Multiplies a sparse matrix by a row vector.
            </summary>
            <param name="A">The matrix.</param>
            <param name="v">The row vector.</param>
            <returns>The product row vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SparseSquareMatrix.Solve(Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Solves Ax = b using iterative methods.
            </summary>
            <param name="rhs">The right-hand side vector b.</param>
            <returns>The solution vector x.</returns>
            <remarks>
            <para>In general, neither the inverse nor any decomposition of a sparse matrix is itself sparse. Therefore,
            to solve large, sparse linear systems, iterative methods are employed. An iterative method begins with
            an approximate or guessed solution vector and progresses toward an improved solution. Iterative methods
            are often successful at converging to a sufficiently accurate solution vector, but this is not guaranteed.
            If this method fails to converge, it throws a <see cref="T:Meta.Numerics.NonconvergenceException"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException"><paramref name="rhs"/>'s dimension does not equal the matrix's dimension.</exception>
            <exception cref="T:Meta.Numerics.NonconvergenceException">The method did not converge to a solution.</exception>
        </member>
        <member name="T:Meta.Numerics.Matrices.LUDecomposition">
            <summary>
            Represents the LU decomposition of a square matrix.
            </summary>
            <remarks><para>An LU decomposition is a representation of a matrix M as the product of a lower-left-triagular matrix L and
            and an upper-right-triangular matrix U. To reduce numerical instabilities, we actually decompose a row-wise
            permutation of a matrix, so that we have P A = L U, where P is a permutation matrix.</para>
            <para>For example, here is an LU decomposition of a permutation of a simple 3 X 3 matrix:</para>
            <img src="../images/LUDecomposition.png" />
            <para>Given an LU decomposition of a permutation A, we can solve systems of linear equations or compute the determinant or inverse of A.
            LU decomposition is the fastest way to solve an arbitrary system of linear equations. It is much faster,
            and less subject to rounding errors, to solve Ax=b by LU decomposition than than by inverting A and multiplying A<sup>-1</sup>b.</para>
            <para>You can use the <see cref="M:Meta.Numerics.Matrices.SquareMatrix.LUDecomposition"/> method to obtain the LU decomposition of any non-singular
            square matrix.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Matrices.SquareMatrix"/>
        </member>
        <member name="P:Meta.Numerics.Matrices.LUDecomposition.Dimension">
            <summary>
            Gets the dimension of the system.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.Determinant">
            <summary>
            Computes the determinant of the original matrix.
            </summary>
            <returns>The determinant of the original matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Solves A x = b.
            </summary>
            <param name="rhs">The right-hand side vector b.</param>
            <returns>The solution vector x.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rhs"/> is <c>null</c>.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="rhs"/> is not the same as the dimension of the matrix.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.Inverse">
            <summary>
            Computes the the inverse of the original matrix.
            </summary>
            <returns>The independent inverse of the original matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.LMatrix">
            <summary>
            Gets the L factor.
            </summary>
            <returns>The lower-left trangular factor L of the LU decomposition.</returns>
            <remarks>
            <para>The pivoted LU decomposition algorithm guarantees that the diagonal entries of this matrix are all one, and
            that the magnitudes of the sub-diagonal entries are all less than or equal to one.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.UMatrix">
            <summary>
            Gets the U factor.
            </summary>
            <returns>The upper-right triangular factor U of the LU decomposition.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.LUDecomposition.PMatrix">
            <summary>
            Gets the permutation matrix.
            </summary>
            <returns>The permutation matrix P in the PA = LU decomposition.</returns>
            <remarks>
            <para>A permutation matrix is just a "scrambled" identity matrix: 1 appears exactly once in each row and column, but
            not necessarily in the diagonal position.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Matrices.SquareMatrix">
            <summary>
            Represents a square matrix.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new square matrix.
            </summary>
            <param name="dimension">The dimension of the matrix, which must be positive.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="dimension"/> &lt; 1.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Initializes a new square matrix from the given 2D array.
            </summary>
            <param name="entries">The source 2D array.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="entries"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The first and second dimensions of <paramref name="entries"/> are not equal.</exception>
        </member>
        <member name="P:Meta.Numerics.Matrices.SquareMatrix.Dimension">
            <summary>
            Gets the dimension of the matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.SquareMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets an entry of the matrix.
            </summary>
            <param name="r">The (zero-based) row number.</param>
            <param name="c">The (zero-based) column number.</param>
            <returns>The value of the specified matrix entry M<sub>r c</sub>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.OneNorm">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.InfinityNorm">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Row(System.Int32)">
            <summary>
            Returns a vector representing a given row of the matrix.
            </summary>
            <param name="r">The (zero-based) row number to return.</param>
            <returns>An independent copy of the specified row.</returns>
            <remarks>The returned vector is not linked to the matrix. If an entry in the matrix is updated after this method
            is called, the returned object will continue to represent a row of the original, not the updated, matrix. Similiarly,
            updates to the elements of the returned vector will not update the original matrix.</remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Column(System.Int32)">
            <summary>
            Gets a copy of one column of the the matrix.
            </summary>
            <param name="c">The (zero-based) column number to return.</param>
            <returns>An independent copy of the specificed column.</returns>
            <remarks>The returned vector is not linked to the matrix. If an entry in the matrix is updated after this method
            is called, the returned object will continue to represent a row of the original, not the updated, matrix. Similiarly,
            updates to the elements of the returned vector will not update the original matrix.</remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Copy">
            <summary>
            Copies the matrix.
            </summary>
            <returns>An independent copy of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Transpose">
            <summary>
            Creates a transpose of the matrix.
            </summary>
            <returns>The matrix transpose M<sup>T</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Inverse">
            <summary>
            Computes the inverse of the matrix.
            </summary>
            <returns>The matrix inverse M<sup>-1</sup>.</returns>
            <remarks>
            <para>The inverse of a matrix M is a matrix M<sup>-1</sup> such that M<sup>-1</sup>M = I, whhere I is the identity matrix.</para>
            <para>If the matrix is singular, inversion is not possible. In that case, this method will fail with a <see cref="T:System.DivideByZeroException"/>.</para>
            <para>The inversion of a matrix is an O(N<sup>3</sup>) operation.</para>
            </remarks>
            <exception cref="T:System.DivideByZeroException">The matrix is singular.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.LUDecomposition">
            <summary>
            Computes the LU decomposition of the matrix.
            </summary>
            <returns>The LU decomposition of the matrix.</returns>
            <remarks>
            <para>The LU decomposition of a matrix M is a set of matrices L, U, and P such that LU = PM, where L
            is lower-left triangular, U is upper-right triangular, and P is a permutation matrix (so that PM is
            a row-wise permutation of M).</para>
            <para>The LU decomposition of a square matrix is an O(N<sup>3</sup>) operation.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Eigenvalues">
            <summary>
            Computes the eigenvalues of the matrix.
            </summary>
            <returns>The eigenvalues of the matrix.</returns>
            <seealso cref="M:Meta.Numerics.Matrices.SquareMatrix.Eigensystem"/>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Eigensystem">
            <summary>
            Computes the eigenvalues and eigenvectors of the matrix.
            </summary>
            <returns>A representation of the eigenvalues and eigenvectors of the matrix.</returns>
            <remarks>
            <para>For a generic vector v and matrix M, Mv = u will point in some direction with no particular relationship to v.
            The eigenvectors of a matrix M are vectors z that satisfy Mz = &#x3BB;z, i.e. multiplying an eigenvector by a
            matrix reproduces the same vector, up to a prortionality constant &#x3BB; called the eigenvalue.</para>
            <para>For v to be an eigenvector of M with eigenvalue &#x3BB;, (M - &#x3BB;I)z = 0. But for a matrix to
            anihilate any non-zero vector, that matrix must have determinant, so det(M - &#x3BB;I)=0. For a matrix of
            order N, this is an equation for the roots of a polynomial of order N. Since an order-N polynomial always has exactly
            N roots, an order-N matrix always has exactly N eigenvalues.</para>
            <para>Since a polynomial with real coefficients can still have complex roots, a real square matrix can nonetheless
            have complex eigenvalues (and correspondly complex eigenvectors). However, again like the complex roots of a real
            polynomial, such eigenvalues will always occurs in complex-conjugate pairs.</para>
            <para>Although the eigenvalue polynomial ensures that an order-N matrix has N eigenvalues, it can occur that there
            are not N corresponding independent eigenvectors. A matrix with fewer eigenvectors than eigenvalues is called
            defective. Like singularity, defectiveness represents a delecate balance between the elements of a matrix that can
            typically be disturbed by just an infinitesimal perturbation of elements. Because of round-off-error, then, floating-point
            algorithms cannot reliably identify defective matrices. Instead, this method will return a full set of eigenvectors,
            but some eigenvectors, corresponding to very nearly equal eigenvalues, will be very nearly parallel.</para>
            <para>While a generic square matrix can be defective, many subspecies of square matrices are guaranteed not to be.
            This includes Markov matrices, orthogonal matrices, and symmetric matrices.</para>
            <para>Determining the eigenvalues and eigenvectors of a matrix is an O(N<sup>3</sup>) operation. If you need only the
            eigenvalues of a matrix, the <see cref="M:Meta.Numerics.Matrices.SquareMatrix.Eigenvalues"/> method is more efficient.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.SingularValueDecomposition">
            <summary>
            Computes the singular value decomposition of the square matrix.
            </summary>
            <returns>The singular value decomposition of the matrix.</returns>
            <remarks>
            <para>Singular value decomposition is an advanced matrix decomposition technique that can be applied
            to all matrices, including non-square and singular square matrices.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.QRDecomposition">
            <summary>
            Computes a QR decomposition of the matrix.
            </summary>
            <returns>A QR decomposition of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.Power(System.Int32)">
            <summary>
            Computes the matrix raised to the given power.
            </summary>
            <param name="n">The power to which to raise the matrix, which must be positive.</param>
            <returns>The matrix A<sup>n</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Addition(Meta.Numerics.Matrices.SquareMatrix,Meta.Numerics.Matrices.SquareMatrix)">
            <summary>
            Adds two real, square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum matrix <paramref name="A"/> + <paramref name="B"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="A"/> is not the same as the dimension of <paramref name="B"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Subtraction(Meta.Numerics.Matrices.SquareMatrix,Meta.Numerics.Matrices.SquareMatrix)">
            <summary>
            Computes the difference of two square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The difference <paramref name="A"/> - <paramref name="B"/>.</returns>
            <remarks>
            <para>Matrix subtraction is an O(N<sup>2</sup>) process.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="A"/> is not the same as the dimension of <paramref name="B"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Multiply(Meta.Numerics.Matrices.SquareMatrix,Meta.Numerics.Matrices.SquareMatrix)">
            <summary>
            Computes the product of two square matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The product <paramref name="A"/> * <paramref name="B"/>.</returns>
            <remarks>
            <para>Note that matrix multiplication is not commutative, i.e. M1*M2 is generally not the same as M2*M1.</para>
            <para>Matrix multiplication is an O(N<sup>3</sup>) process.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="A"/> is not the same as the dimension of <paramref name="B"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Multiply(Meta.Numerics.Matrices.SquareMatrix,Meta.Numerics.Matrices.ColumnVector)">
            <summary>
            Computes the product of a square matrix and a column vector.
            </summary>
            <param name="A">The matrix.</param>
            <param name="v">The column vector.</param>
            <returns>The column vector Av.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="v"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="A"/> is not the same as the dimension of <paramref name="v"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.SquareMatrix)">
            <summary>
            Multiply a real, square matrix by a real constant.
            </summary>
            <param name="alpha">The constant.</param>
            <param name="A">The matrix.</param>
            <returns>The product aA.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_Multiply(Meta.Numerics.Matrices.SquareMatrix,System.Double)">
            <summary>
            Divides a real, square matrix by a real constant.
            </summary>
            <param name="A">The matrix.</param>
            <param name="alpha">The constant.</param>
            <returns>The quotient A/a.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareMatrix.op_UnaryNegation(Meta.Numerics.Matrices.SquareMatrix)">
            <summary>
            Negates a real, square matrix.
            </summary>
            <param name="A">The matrix.</param>
            <returns>The matrix -A.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> is null.</exception>
        </member>
        <member name="T:Meta.Numerics.Matrices.SquareQRDecomposition">
            <summary>
            Represents the QR decomposition of a square matrix.
            </summary>
            <remarks>
            <para>A QR decomposition represents a matrix as the product of an orthogonal matrix Q and an upper-right-triangular matrix R.</para>
            <para>Like a LU decomposition (<see cref="T:Meta.Numerics.Matrices.LUDecomposition"/>, a QR decomposition can be used to solve systems of equations,
            or compute a determinant or matrix inverse.</para>
            <para>To obtain the QR decomposition of a square matrix, use the <see cref="M:Meta.Numerics.Matrices.SquareMatrix.QRDecomposition"/> method of the
            <see cref="T:Meta.Numerics.Matrices.SquareMatrix"/> class.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareQRDecomposition.QMatrix">
            <summary>
            The orthogonal matrix Q.
            </summary>
            <returns>The orthogonal matrix Q.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareQRDecomposition.RMatrix">
            <summary>
            The upper-right triangular matrix R.
            </summary>
            <returns>The upper-right triangular matrix R.</returns>
            <remarks>
            <para>The returned matrix is read-only. If you need to make changes to it, you can call <see cref="M:Meta.Numerics.Matrices.SquareMatrix.Copy"/> to obtain a writable copy.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareQRDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Solve the system of equations Ax=b, where A is the original matrix.
            </summary>
            <param name="rhs">The right-hand-side vector b.</param>
            <returns>The solution vector x.</returns>
            <remarks>
            <para>The components of <paramref name="rhs"/> are not modified.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareQRDecomposition.Determinant">
            <summary>
            Computes the determinant of the original matrix.
            </summary>
            <returns>det A</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SquareQRDecomposition.Inverse">
            <summary>
            Computes the inverse of the original matrix.
            </summary>
            <returns>A<sup>-1</sup></returns>
        </member>
        <member name="P:Meta.Numerics.Matrices.SquareQRDecomposition.Dimension">
            <summary>
            Gets the dimension of the original matrix.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Matrices.SymmetricMatrix">
            <summary>
            Represents a symmetric matrix.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new symmetric matrix.
            </summary>
            <param name="dimension">The dimension of the matrix, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.SymmetricMatrix.Dimension">
            <summary>
            Gets the dimension of the matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.SymmetricMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets an element of the matrix.
            </summary>
            <param name="r">The (zero-based) row number.</param>
            <param name="c">The (zero-based) column number.</param>
            <returns>The value of the specified matrix entry M<sub>r c</sub>.</returns>
            <remarks>
            <para>The set operation preserves the symmetry of the matrix; when entry M<sub>r c</sub> is changed, entry
            M<sub>c r</sub> is updated automatically.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Fill(System.Func{System.Int32,System.Int32,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Copy">
            <summary>
            Copies the matrix.
            </summary>
            <returns>An independent copy of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Trace">
            <summary>
            Computes the trace of the matrix.
            </summary>
            <returns>The trace of the matrix tr(M).</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Inverse">
            <summary>
            Computes the inverse of the matrix.
            </summary>
            <returns>The matrix inverse M<sup>-1</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.CholeskyDecomposition">
            <summary>
            Computes the Cholesky decomposition of the matrix.
            </summary>
            <returns>The Cholesky decomposition of the matrix, or null if the matrix is not positive definite.</returns>
            <remarks>
            <para>A Cholesky decomposition is a special decomposition that is possible only for positive definite matrices.
            (A positive definite matrix M has x<sup>T</sup>Mx > 0 for any vector x. Equivilently, M is positive definite if
            all its eigenvalues are positive.)</para>
            <para>The Cholesky decomposition represents M = C C<sup>T</sup>, where C is lower-left triangular (and thus C<sup>T</sup>
            is upper-right triangular. It is basically an LU decomposition where the L and U factors are related by transposition.
            Since the M is produced by multiplying C "by itself", the matrix C is sometimes call the "square root" of M.</para>
            <para>Cholesky decomposition is an O(N<sup>3</sup>) operation. It is about a factor of two faster than LU decomposition,
            so it is a faster way to obtain inverses, determinates, etc. if you know that M is positive definite.</para>
            <para>The fastest way to test whether your matrix is positive definite is attempt a Cholesky decomposition. If this
            method returns null, M is not positive definite.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Matrices.CholeskyDecomposition"/>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Eigensystem">
            <summary>
            Computes the eigenvalues and eigenvectors of the matrix.
            </summary>
            <returns>A representation of the eigenvalues and eigenvectors of the matrix.</returns>
            <remarks>
            <para>For a generic vector v and matrix M, Mv = u will point in some direction with no particular relationship to v.
            The eigenvectors of a matrix M are vectors z that satisfy Mz = &#x3BB;z, i.e. multiplying an eigenvector by a
            matrix reproduces the same vector, up to a prortionality constant &#x3BB; called the eigenvalue.</para>
            <para>For v to be an eigenvector of M with eigenvalue &#x3BB;, (M - &#x3BB;I)z = 0. But for a matrix to
            anihilate any non-zero vector, that matrix must have determinant, so det(M - &#x3BB;I)=0. For a matrix of
            order N, this is an equation for the roots of a polynomial of order N. Since an order-N polynomial always has exactly
            N roots, an order-N matrix always has exactly N eigenvalues.</para>
            <para>An alternative way of expressing the same relationship is to say that the eigenvalues of a matrix are its
            diagonal elements when the matrix is expressed in a basis that diagonalizes it. That is, given Z such that Z<sup>-1</sup>MZ = D,
            where D is diagonal, the columns of Z are the eigenvectors of M and the diagonal elements of D are the eigenvalues.</para>
            <para>Note that the eigenvectors of a matrix are not entirely unique. Given an eigenvector z, any scaled vector &#x3B1;z
            is an eigenvector with the same eigenvalue, so eigenvectors are at most unique up to a rescaling. If an eigenvalue
            is degenerate, i.e. there are two or more linearly independent eigenvectors with the same eigenvalue, then any linear
            combination of the eigenvectors is also an eigenvector with that eigenvalue, and in fact any set of vectors that span the
            same subspace could be taken as the eigenvector set corresponding to that eigenvalue.</para>
            <para>The eigenvectors of a symmetric matrix are always orthogonal and the eigenvalues are always real. The transformation
            matrix Z is thus orthogonal (Z<sup>-1</sup> = Z<sup>T</sup>).</para>
            <para>Finding the eigenvalues and eigenvectors of a symmetric matrix is an O(N<sup>3</sup>) operation.</para>
            <para>If you require only the eigenvalues, not the eigenvectors, of the matrix, the <see cref="M:Meta.Numerics.Matrices.SymmetricMatrix.Eigenvalues"/> method
            will produce them faster than this method.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.Eigenvalues">
            <summary>
            Computes the eigenvalues of the matrix. 
            </summary>
            <returns>An array containing the matrix eigenvalues.</returns>
            <remarks>
            <para>If you require only the eigenvalues of the matrix, not its eigenvectors, this method will return them faster than
            the <see cref="M:Meta.Numerics.Matrices.SymmetricMatrix.Eigensystem"/> method. If you do need the eigenvectors as well as the eigenvalues, use the <see cref="M:Meta.Numerics.Matrices.SymmetricMatrix.Eigensystem"/>
            method instead.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.op_Addition(Meta.Numerics.Matrices.SymmetricMatrix,Meta.Numerics.Matrices.SymmetricMatrix)">
            <summary>
            Adds two symmetric matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The sum <paramref name="A"/> + <paramref name="B"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.op_Subtraction(Meta.Numerics.Matrices.SymmetricMatrix,Meta.Numerics.Matrices.SymmetricMatrix)">
            <summary>
            Subtracts two symmetric matrices.
            </summary>
            <param name="A">The first matrix.</param>
            <param name="B">The second matrix.</param>
            <returns>The difference <paramref name="A"/> - <paramref name="B"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.SymmetricMatrix)">
            <summary>
            Multiplies a symmetric matrix by a real factor.
            </summary>
            <param name="alpha">The factor.</param>
            <param name="A">The matrix.</param>
            <returns>The product of the matrix and the factor.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.SymmetricMatrix.op_UnaryNegation(Meta.Numerics.Matrices.SymmetricMatrix)">
            <summary>
            Negates a symmetric matrix.
            </summary>
            <param name="A">The matrix.</param>
            <returns>The matrix -A.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.TridiagonalMatrix">
            <summary>
            Represents a tridiagonal matrix.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.#ctor(System.Int32)">
            <summary>
            Initializes a new tridiagonal matrix of the given dimension.
            </summary>
            <param name="dimension">The dimension of the matrix, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Matrices.TridiagonalMatrix.Dimension">
            <summary>
            Gets the dimension of the matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.TridiagonalMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a matrix element.
            </summary>
            <param name="r">The (zero-based) row number of the element.</param>
            <param name="c">The (zero-based) column number of the element.</param>
            <returns>M<sub>r,c</sub></returns>
            <remarks>
            <para>Elements on the tridiagonal strip can be set and gotten normally. Other elements
            will always have the value zero, and any attempt to set them to a non-zero value will
            result in an <see cref="T:System.InvalidOperationException"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.Copy">
            <summary>
            Copies the matrix.
            </summary>
            <returns>An independent copy of the matrix.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.Transpose">
            <summary>
            Creates a transpose of the matrix.
            </summary>
            <returns>The matrix transpose M<sup>T</sup>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.Determinant">
            <summary>
            Computes the determinant of the matrxi.
            </summary>
            <returns>The determinant det M.</returns>
            <remarks>
            <para>Computing the determinant of a tridiagonal matrix is an O(N) operation.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.LUDecomposition">
            <summary>
            Computes the LU decomposition of the matrix.
            </summary>
            <returns>The LU decomposition of the matrix.</returns>
            <remarks>
            <para>Computiong the LU decomposition of a tridiagonal matrix is an O(N) operation.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.op_Addition(Meta.Numerics.Matrices.TridiagonalMatrix,Meta.Numerics.Matrices.TridiagonalMatrix)">
            <summary>
            Adds two tridiagonal matrices.
            </summary>
            <param name="T1">The first matrix M<sub>1</sub>.</param>
            <param name="T2">The first matrix M<sub>2</sub>.</param>
            <returns>The sum M<sub>1</sub> + M<sub>2</sub>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.op_Subtraction(Meta.Numerics.Matrices.TridiagonalMatrix,Meta.Numerics.Matrices.TridiagonalMatrix)">
            <summary>
            Subtracts two tridiagonal matrices.
            </summary>
            <param name="T1">The first matrix M<sub>1</sub>.</param>
            <param name="T2">The first matrix M<sub>2</sub>.</param>
            <returns>The difference M<sub>1</sub> - M<sub>2</sub>.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalMatrix.op_Multiply(System.Double,Meta.Numerics.Matrices.TridiagonalMatrix)">
            <summary>
            Multiplies a tridiagonal matrix by a real constant.
            </summary>
            <param name="f">The constant.</param>
            <param name="T">The matrix.</param>
            <returns>The product matrix.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.TridiagonalLUDecomposition">
            <summary>
            Represents the LU decomposition of a tridiagonal matrix.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Matrices.TridiagonalLUDecomposition.Dimension">
            <summary>
            Gets the dimension of the original matrix.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalLUDecomposition.Determinant">
            <summary>
            Computes the determinant of the original matrix.
            </summary>
            <returns>The determinant det M.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalLUDecomposition.Solve(System.Collections.Generic.IList{System.Double})">
            <summary>
            Solves a tridiagonal system of linear equations.
            </summary>
            <param name="rhs">The right-hand side vector b.</param>
            <returns>A vector x which satisties Ax = b.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.TridiagonalLUDecomposition.Inverse">
            <summary>
            Computes the inverse of the original matrix.
            </summary>
            <returns>The matrix M<sup>-1</sup>.</returns>
        </member>
        <member name="T:Meta.Numerics.Matrices.VectorBase">
            <summary>
            Implements functionality shared between row and column vectors.
            </summary>
            <seealso cref="T:Meta.Numerics.Matrices.RowVector"/>
            <seealso cref="T:Meta.Numerics.Matrices.ColumnVector"/>
        </member>
        <member name="P:Meta.Numerics.Matrices.VectorBase.Item(System.Int32)">
            <summary>
            Gets or sets the specified vector component.
            </summary>
            <param name="index">The (zero-based) component index.</param>
            <returns>The value of the specified vector component.</returns>
        </member>
        <member name="P:Meta.Numerics.Matrices.VectorBase.Dimension">
            <summary>
            Gets the dimension of the vector.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Matrices.VectorBase.Norm">
            <summary>
            Computes the magnitude of the vector.
            </summary>
            <returns>The Euclidean norm of the vector.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.VectorBase.ToArray">
            <summary>
            Returns the vector elements in an independent array.
            </summary>
            <returns>An array containing the vector element values.</returns>
        </member>
        <member name="M:Meta.Numerics.Matrices.VectorBase.GetEnumerator">
            <summary>
            Gets an enumerator of the vector components.
            </summary>
            <returns>An enumerator of the vector components.</returns>
        </member>
        <member name="T:Meta.Numerics.Messages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Messages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Messages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Messages.DimensionMismatch">
            <summary>
              Looks up a localized string similar to The requested operation is not defined for matrices of the given dimensions..
            </summary>
        </member>
        <member name="P:Meta.Numerics.Messages.InsufficientData">
            <summary>
              Looks up a localized string similar to The requested operation requires more data points than are available in the data collection..
            </summary>
        </member>
        <member name="T:Meta.Numerics.SignalProcessing.FourierNormalization">
            <summary>
            Specifies the normalization convention to be used in a forward Fourier transform.
            </summary>
            <remarks>
            <para>The most common convention in signal processing applications is <see cref="F:Meta.Numerics.SignalProcessing.FourierNormalization.None"/>.</para>
            </remarks>
        </member>
        <member name="F:Meta.Numerics.SignalProcessing.FourierNormalization.None">
            <summary>
            The series is not normalized.
            </summary>
        </member>
        <member name="F:Meta.Numerics.SignalProcessing.FourierNormalization.Unitary">
            <summary>
            The series is multiplied by 1/N<sup>1/2</sup>.
            </summary>
        </member>
        <member name="F:Meta.Numerics.SignalProcessing.FourierNormalization.Inverse">
            <summary>
            The series is multiplied by 1/N.
            </summary>
        </member>
        <member name="T:Meta.Numerics.SignalProcessing.FourierSign">
            <summary>
            Specifies the sign convention to be used in the exponent of a forward Fourier transform.
            </summary>
            <remarks>
            <para>The most common convention in signal processing applications is <see cref="F:Meta.Numerics.SignalProcessing.FourierSign.Negative"/>.</para>
            </remarks>
        </member>
        <member name="F:Meta.Numerics.SignalProcessing.FourierSign.Positive">
            <summary>
            The exponent has positive imaginary values.
            </summary>
        </member>
        <member name="F:Meta.Numerics.SignalProcessing.FourierSign.Negative">
            <summary>
            The exponent has negative imaginary values.
            </summary>
        </member>
        <member name="T:Meta.Numerics.SignalProcessing.FourierTransformer">
            <summary>
            An engine for performing Fourier transforms on complex series.
            </summary>
            <remarks>
            <para>A Fourier transform decomposes a function into a sum of different frequency components. This is
            useful for a wide array of applications.</para>
            <para>Mathematically, the DFT is an N-dimensional linear transfromation
            with coefficients that are the Nth complex roots of unity.</para>
            <img src="../images/Fourier.png" />
            <para>An instance of the FourierTransformer class performs DFTs on series of a particular length,
            given by its <see cref="P:Meta.Numerics.SignalProcessing.FourierTransformer.Length"/> property. This specialization allows certain parts of the DFT
            calculation, which are indepdent of the transformed series but dependent on the length of the series,
            to be performed only once and then re-used for all transforms of that length. This saves time and improves
            performance. If you need to perform DFTs on series with different lengths, simply create a seperate instance
            of the FourierTransform class for each required length.</para>
            <para>Many simple DFT implementations require that the series length be a power of two (2, 4, 8, 16, etc.).
            Meta.Numerics supports DFTs of any length. Our DFT implementation is fast -- order O(N log N) -- for all lengths,
            including lengths that have large prime factors.</para>
            </remarks>
            <example>
            <para>The following code performs a simple DFT and then inverts it to re-obtain the original data.</para>
            <code lang="c#">
            // Create a Fourier transformer for length-6 series
            FourierTransformer ft = new FourierTransformer(6);
            // Create a length-6 series and transform it
            Complex[] x = new Complex[] { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 };
            Complex[] xt = ft.Transform(x);
            // Re-use the same transformer to transform a different  series
            Complex[] y = new Complex[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 };
            Complex[] yt = ft.Transform(y);
            // Transform them back
            Complex[] xtt = ft.InverseTransform(xt);
            Complex[] ytt = ft.InverseTransform(yt);
            </code>
            </example>
            <seealso href="http://en.wikipedia.org/wiki/Discrete-time_Fourier_transform"/>
        </member>
        <member name="M:Meta.Numerics.SignalProcessing.FourierTransformer.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the Fourier transformer.
            </summary>
            <param name="size">The series length of the transformer, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.SignalProcessing.FourierTransformer.#ctor(System.Int32,Meta.Numerics.SignalProcessing.FourierSign,Meta.Numerics.SignalProcessing.FourierNormalization)">
            <summary>
            Initializes a new instance of the Fourier transformer with the given sign and normalization conventions.
            </summary>
            <param name="size">The series length of the transformer, which must be positive.</param>
            <param name="signConvention">The sign convention of the transformer.</param>
            <param name="normalizationConvention">The normalization convention of the transformer.</param>
            <remarks>
            <para>There are multiple conventions for both the sign of the exponent and the overall normalization of
            Fourier transforms. The default conventions for some widely used software packages are summarized in the following
            table.</para>
            <table>
                <tr><th>Software</th><th>Sign</th><th>Normalization</th></tr>
                <tr><td>Meta.Numerics</td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierSign.Negative"/></td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierNormalization.None"/></td></tr>
                <tr><td>Matlab</td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierSign.Negative"/></td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierNormalization.None"/></td></tr>
                <tr><td>Mathmatica</td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierSign.Positive"/></td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierNormalization.Unitary"/></td></tr>
                <tr><td>Numerical Recipies</td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierSign.Positive"/></td><td><see cref="F:Meta.Numerics.SignalProcessing.FourierNormalization.None"/></td></tr>
            </table>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.SignalProcessing.FourierTransformer.Length">
            <summary>
            The series length for which the transformer is specialized.
            </summary>
        </member>
        <member name="P:Meta.Numerics.SignalProcessing.FourierTransformer.NormalizationConvention">
            <summary>
            Gets the normalization convention used by the transformer.
            </summary>
        </member>
        <member name="P:Meta.Numerics.SignalProcessing.FourierTransformer.SignConvention">
            <summary>
            Gets the normalization convention used by the transformer.
            </summary>
        </member>
        <member name="M:Meta.Numerics.SignalProcessing.FourierTransformer.Transform(System.Collections.Generic.IList{Meta.Numerics.Complex})">
            <summary>
            Computes the Fourier transform of the given series.
            </summary>
            <param name="values">The series to transform.</param>
            <returns>The discrete Fourier transform of the series.</returns>
        </member>
        <member name="M:Meta.Numerics.SignalProcessing.FourierTransformer.InverseTransform(System.Collections.Generic.IList{Meta.Numerics.Complex})">
            <summary>
            Computes the inverse Fourier transform of the given series.
            </summary>
            <param name="values">The series to invert.</param>
            <returns>The inverse discrete Fourier transform of the series.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.OneWayAnovaResult">
            <summary>
            The result of a one-way ANOVA test.
            </summary>
            <remarks>
            <para>A one way ANOVA test detects the influence of a single factor on the mean of a measured variable, which is assumed
            to be normally distributed.</para>
            <para>A one way ANOVA result is returned by the static <see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(System.Collections.Generic.ICollection{Meta.Numerics.Statistics.Sample})"/>
            method.</para>
            <para>Fundamentally, a one-way ANOVA is a simple statistical test like any other, with a single test statistic (F) and
            a single associated null distribution (the <see cref="T:Meta.Numerics.Statistics.Distributions.FisherDistribution"/>), but some ANOVA users like to examine and
            report intermediate quantities used in the computation of the test.
            In particular, the sum of square deviations and degrees of freedom associated
            with the design factor and the residual, and their sum may be of interest. Each of these appear as rows in the common tabular
            representation of an ANOVA. To enable this, the class makes this information available as <see cref="T:Meta.Numerics.Statistics.AnovaRow"/> objects
            returned by the <see cref="P:Meta.Numerics.Statistics.OneWayAnovaResult.Factor"/>, <see cref="P:Meta.Numerics.Statistics.OneWayAnovaResult.Residual"/>, and <see cref="P:Meta.Numerics.Statistics.OneWayAnovaResult.Total"/> properties. This has the unfortunate
            side-effect of making the AVOVA look more complicated than it really is. If you just want the test result, you can get it
            from the <see cref="P:Meta.Numerics.Statistics.OneWayAnovaResult.Result"/> property.</para>
            </remarks>
            <example>
            <para>Suppose you have sampled the heights of aliens from three planets. Heights are approximately normally distributed
            on each planet. You want to know whether planet-of-origin affects average height. You can do a one-way ANOVA to determine
            if the planet factor affects mean height.</para>
            <code lang="C#">
            Sample group1 = new Sample(4, 5, 6);
            Sample group2 = new Sample(3, 4, 5);
            Sample group3 = new Sample(5, 6, 8, 9);
            OneWayAnovaResult anova = Sample.OneWayAnovaTest(group1, group2, group3);
            Console.WriteLine("P = {0}", anova.Result.Probability);
            </code>
            </example>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(System.Collections.Generic.ICollection{Meta.Numerics.Statistics.Sample})"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.OneWayAnovaResult.Factor">
            <summary>
            Gets design factor variance data.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.OneWayAnovaResult.Residual">
            <summary>
            Gets residual variance data.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.OneWayAnovaResult.Total">
            <summary>
            Gets total variance data.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.OneWayAnovaResult.Result">
            <summary>
            Gets the result of the F test for the influence of the factor.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.AnovaRow">
            <summary>
            A row in an analysis of variance (ANOVA) table.
            </summary>
            <remarks>
            <para>An ANOVA seperates the variance associated with one or more sources into "rows", each of which has an associated
            sum of square deviations and number of degrees of freedom.</para>
            <para>It is used in properties of the <see cref="T:Meta.Numerics.Statistics.OneWayAnovaResult"/> class.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Statistics.OneWayAnovaResult"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.AnovaRow.SumOfSquares">
            <summary>
            Gets the sum of squares contributed by the row.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.AnovaRow.DegreesOfFreedom">
            <summary>
            Gets the degrees of freedom associated with the row.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.AnovaTestRow">
            <summary>
            A row in an ANOVA table for which an F-test is available.
            </summary>
            <seealso cref="T:Meta.Numerics.Statistics.OneWayAnovaResult"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.AnovaTestRow.Result">
            <summary>
            Gets the result of an F-test measuring the significance of the row.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.TwoWayAnovaResult">
            <summary>
            Represents the result of a two-factor analysis of variance.
            </summary>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.TwoWayAnovaTest(Meta.Numerics.Statistics.Sample[0:,0:])"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.TwoWayAnovaResult.RowFactor">
            <summary>
            Gets the variance assocated with the effect of the row factor.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TwoWayAnovaResult.ColumnFactor">
            <summary>
            Gets the variance associated with the effect of the column factor. 
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TwoWayAnovaResult.Interaction">
            <summary>
            Gets the variance associated with the effect of the interaction of the row and column factors.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TwoWayAnovaResult.Residual">
            <summary>
            Gets the variance associated with the unpredicted residuals.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TwoWayAnovaResult.Total">
            <summary>
            Gets the total variance.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.BinaryContingencyTable">
            <summary>
            Represents a 2 X 2 contingency table.
            </summary>
            <remarks>
            <para>Binary contingency tables are the most common kind of contingency table. Any experiment with a treatment and
            a control group, and binary measured outcome, can be represented by a binary contingency table.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Contingency_table" />
        </member>
        <member name="M:Meta.Numerics.Statistics.BinaryContingencyTable.#ctor">
            <summary>
            Initializes a new binary contingency table.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.BinaryContingencyTable.#ctor(System.Int32[0:,0:])">
            <summary>
            Initializes a new binary contingency table with the given entries.
            </summary>
            <param name="data">A two-dimensional matrix of table entries.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.BinaryContingencyTable.OddsRatio">
            <summary>
            Computes the odds ratio of table.
            </summary>
            <remarks><para>For entries in the first row, the odds of landing in the first column are given by N[0,0] / N[0,1].
            For entries in the second row, the odds of landing in the first column are given by N[1,0] / N[1,1]. The odds
            ratio is the ratio of these two odds. An odds ratio significantly different from 1 indicates a correlation between
            row and column values.</para></remarks>
            <seealso cref="P:Meta.Numerics.Statistics.BinaryContingencyTable.LogOddsRatio"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.BinaryContingencyTable.LogOddsRatio">
            <summary>
            Computes the log of the odds ratio.
            </summary>
            <seealso cref="P:Meta.Numerics.Statistics.BinaryContingencyTable.OddsRatio"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.BinaryContingencyTable.FisherExactTest">
            <summary>
            Performs a Fisher exact test.
            </summary>
            <returns>The results of the test. The test statistic is the summed probability of all tables exhibiting equal or stronger correlations,
            and its likelyhood under the null hypothesis is the (left) probability to obtain a smaller value. Note that, in this case, the test
            statistic itself is the likelyhood.</returns>
            <remarks><para>The Fisher exact test tests for correlations between row and column entries. It is a robust, non-parametric test,
            which, unlike the &#x3C7;<sup>2</sup> test (see <see cref="M:Meta.Numerics.Statistics.ContingencyTable.PearsonChiSquaredTest"/>), can safely be used for tables
            with small, even zero-valued, entries.</para>
            <para>The Fisher test computes, under the null hypothesis of no correlation, the exact probability of all 2 X 2 tables with the
            same row and column totals as the given table. It then sums the probabilities of all tables that are as or less probable than
            the given table. In this way it determines the total probability of obtaining a 2 X 2 table which is at least as improbable
            as the given one.</para>
            <para>The test is two-sided, i.e. when considering less probable tables it does not distinguish between tables exhibiting
            the same and the opposite correlation as the given one.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Fisher_exact_test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.BinaryContingencyTable.McNemarTest">
            <summary>
            Performs a McNemar test.
            </summary>
            <returns>The result of the test.</returns>
            <remarks>
            <para>McNemar's test is appropriate to a rather specialized circumstance, so if you aren't sure this is the
            right test, it probably isn't.</para>
            <para>The circumstance to which McNemar's test applies is paired binary measurements. Each member of
            a set is measured twice, once before and once after some treatment, and each measurement has a binary
            outcome. McNemar's test can be used to determine whether the treatment had any systematic effect. The null
            hypothesis is that it the not, i.e. that any discrepancies between the first and second measurements
            were random.</para>
            </remarks>
            <see href="http://en.wikipedia.org/wiki/McNemar%27s_test"/>
        </member>
        <member name="T:Meta.Numerics.Statistics.BivariateSample">
            <summary>
            Represents a set of data points, where each data point is described by a pair of real numbers.
            </summary>
            <remarks>
            <para>A bivariate sample consists of pairs of real numbers, where each pair is an independent
            measurement. For example, if you measure the height and weight of a sample of people, the data
            could be stored as a bivariate sample. The class can compute various descriptive statistics
            for the sample, perform appropriate statistical tests on the sample data, and fit the sample
            data to various models.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.#ctor">
            <summary>
            Initializes a new bivariate sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.#ctor(System.String,System.String)">
            <summary>
            Initializes a new bivariate sample with the given variable names.
            </summary>
            <param name="xName">The name of the x-variable.</param>
            <param name="yName">The name of the y-variable.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Add(System.Double,System.Double)">
            <summary>
            Adds a data point to the sample.
            </summary>
            <param name="x">The x-value of the data point.</param>
            <param name="y">The y-value of the data point.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Add(Meta.Numerics.XY)">
            <summary>
            Adds a data point to the sample.
            </summary>
            <param name="point">The data point.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Add(System.Collections.Generic.IEnumerable{Meta.Numerics.XY})">
            <summary>
            Adds multiple data points to the sample.
            </summary>
            <param name="points">The data points.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Add(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Adds points from two lists to the sample.
            </summary>
            <param name="x">The x values of the data points.</param>
            <param name="y">The y values of the data points.</param>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The lengths of the two lists are not equal.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Remove(System.Double,System.Double)">
            <summary>
            Removes a data point from the sample.
            </summary>
            <param name="x">The x-value of the data point.</param>
            <param name="y">The y-value of the data point.</param>
            <returns>True if the given data point was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Remove(Meta.Numerics.XY)">
            <summary>
            Removes a data point from the sample.
            </summary>
            <param name="point">The point to remove.</param>
            <returns>True if the given data point was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Clear">
            <summary>
            Removes all data points from the sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Contains(System.Double,System.Double)">
            <summary>
            Determines whether the sample contains a given data point.
            </summary>
            <param name="x">The x-value of the data point.</param>
            <param name="y">The y-value of the data point.</param>
            <returns>True if the sample contains the given data point, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Contains(Meta.Numerics.XY)">
            <summary>
            Determines whether the sample contains a given data point.
            </summary>
            <param name="xy">The data point.</param>
            <returns>True if the sample contains the given data point, otherwise false.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.IsReadOnly">
            <summary>
            Gets a value indicating whether the bivariate sample is read-only.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.Copy">
            <summary>
            Copies the bivariate sample.
            </summary>
            <returns>An independent copy of the bivariate sample.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.GetEnumerator">
            <summary>
            Gets an enumerator of sample values.
            </summary>
            <returns>An enumerator of sample values.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.TransposeXY">
            <summary>
            Swaps the X and Y variables in the bivariate sample.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.X">
            <summary>
            Gets a read-only univariate sample consisting of the x-values of the data points.
            </summary>
            <remarks>
            <para>Use this method to obtain sinformation specific to the x-vales, such as their <see cref="P:Meta.Numerics.Statistics.Sample.Median"/> or
            <see cref="P:Meta.Numerics.Statistics.Sample.Variance"/>.</para>
            <para>Note that this is a fast, O(1) operation, which does not create an independent copy of the data.
            The advantage of this is that you can access x-data as a <see cref="T:Meta.Numerics.Statistics.Sample"/> as often as you like without
            worying about performance. The disadvantage of this is that the returned sample cannot be altered. If you
            need to alter x-data independent of the bivariate sample, use the <see cref="M:Meta.Numerics.Statistics.Sample.Copy"/>
            method to obtain an independent copy.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.Y">
            <summary>
            Gets a read-only univariate sample consisting of the y-values of the data points.
            </summary>
            <remarks>
            <para>Use this method to obtain sinformation specific to the y-vales, such as their <see cref="P:Meta.Numerics.Statistics.Sample.Median"/> or
            <see cref="P:Meta.Numerics.Statistics.Sample.Variance"/>.</para>
            <para>Note that this is a fast, O(1) operation, which does not create an independent copy of the data.
            The advantage of this is that you can access y-data as a <see cref="T:Meta.Numerics.Statistics.Sample"/> as often as you like without
            worying about performance. The disadvantage of this is that the returned sample cannot be altered. If you
            need to alter y-data independent of the bivariate sample, use the <see cref="M:Meta.Numerics.Statistics.Sample.Copy"/>
            method to obtain an independent copy.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.Count">
            <summary>
            Gets the number of data points.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.Covariance">
            <summary>
            Gets the covariance of the two variables.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.CorrelationCoefficient">
            <summary>
            Gets the correlation coefficient between the two variables.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.BivariateSample.PopulationCovariance">
            <summary>
            Estimates of the population covariance of two variables.
            </summary>
            <returns>An estimate, with associated uncertainty, of the population covariance.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.PearsonRTest">
            <summary>
            Performs a Pearson correlation test for association.
            </summary>
            <returns>The result of the test.</returns>
            <remarks>
            <para>This test measures the strength of the linear correlation between two variables. The
            test statistic r is simply the covariance of the two variables, scaled by their respective
            standard deviations so as to obtain a number between -1 (perfect linear anti-correlation)
            and +1 (perfect linear correlation).</para>
            <para>The Pearson test cannot reliably detect or rule out non-linear associations. For example,
            variables with a perfect quadratic association may have only a weak linear correlation. If
            you wish to test for associations that may not be linear, consider using the Spearman or
            Kendall tests instead.</para>
            <para>The Pearson correlation test requires O(N) operations.</para>
            <para>The Pearson test requires at least three bivariate values.</para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><see cref="P:Meta.Numerics.Statistics.BivariateSample.Count"/> is less than three.</exception>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.SpearmanRhoTest"/>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.KendallTauTest"/>
            <seealso href="http://en.wikipedia.org/wiki/Pearson_correlation_coefficient" />
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.SpearmanRhoTest">
            <summary>
            Performs a Spearman rank-order test of association between the two variables.
            </summary>
            <returns>The result of the test.</returns>
            <remarks>
            <para>The Spearman rank-order test of association is a non-parametric test for association between
            two variables. The test statistic rho is the correlation coefficient of the <em>rank</em> of
            each entry in the sample. It is thus invariant over monotonic reparameterizations of the data,
            and will, for example, detect a quadratic or exponential association just as well as a linear
            association.</para>
            <para>The Spearman rank-order test requires O(N log N) operations.</para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than three data points.</exception>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.PearsonRTest"/>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.KendallTauTest"/>
            <seealso href="http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.KendallTauTest">
            <summary>
            Performs a Kendall concordance test for association.
            </summary>
            <returns>The result of the test.</returns>
            <remarks>
            <para>Kendall's &#x3C4; is a non-parameteric and robust test of association
            between two variables. It simply measures the number of cases where an increase
            in one variable is associated with an increase in the other (corcordant pairs),
            compared with the number of cases where an increase in one variable is associated
            with a decrease in the other (discordant pairs).</para>
            <para>Because &#x3C4; depends only on the sign
            of a change and not its magnitude, it is not skewed by outliers exhibiting very large
            changes, nor by cases where the degree of change in one variable associated with
            a given change in the other changes over the range of the varibles. Of course, it may
            still miss an association whoose sign changes over the range of the variables. For example,
            if data points lie along a semi-circle in the plane, an increase in the first variable
            is associated with an increase in the second variable along the rising arc and and decrease in
            the second variable along the falling arc. No test that looks for single-signed correlation
            will catch this association.
            </para>
            <para>Because it examine all pairs of data points, the Kendall test requires
            O(N<sup>2</sup>) operations. It is thus impractical for very large data sets. While
            not quite as robust as the Kendall test, the Spearman test is a good fall-back in such cases.</para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><see cref="P:Meta.Numerics.Statistics.BivariateSample.Count"/> is less than two.</exception>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.PearsonRTest"/>
            <seealso cref="M:Meta.Numerics.Statistics.BivariateSample.SpearmanRhoTest"/>
            <seealso href="http://en.wikipedia.org/wiki/Kendall_tau_test" />
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.PairedStudentTTest">
            <summary>
            Performs a paired Student t-test.
            </summary>
            <returns>The result of the test.</returns>
            <remarks>
            <para>Like a two-sample, unpaired t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)" />),
            a paired t-test compares two samples to detect a difference in means.
            Unlike the unpaired version, the paired version assumes that each </para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than two data points.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.LinearRegression">
            <summary>
            Computes the best-fit linear regression from the data.
            </summary>
            <returns>The result of the fit.</returns>
            <remarks>
            <para>Linear regression assumes that the data have been generated by a function y = a + b x + e, where e is
            normally distributed noise, and determines the values of a and b that best fit the data. It also
            determines an error matrix on the parameters a and b, and does an F-test to</para>
            <para>The fit result is two-dimensional. The first parameter is the intercept a, the second is the slope b.
            The goodness-of-fit test is a F-test comparing the variance accounted for by the model to the remaining,
            unexplained variance.</para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than three data points.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.PolynomialRegression(System.Int32)">
            <summary>
            Computes the polynomial of given degree which best fits the data.
            </summary>
            <param name="m">The degree,  which must be non-negative.</param>
            <returns>The fit result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="m"/> is negative.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer data points than coefficients to be fit.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.NonlinearRegression(System.Func{System.Collections.Generic.IList{System.Double},System.Double,System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Finds the parameterized function that best fits the data.
            </summary>
            <param name="f">The parameterized function.</param>
            <param name="start">An initial guess for the parameters.</param>
            <returns>The fit result.</returns>
            <remarks>
            <para>
            In the returned <see cref="T:Meta.Numerics.Statistics.FitResult"/>, the parameters appear in the same order as in
            the supplied fit function and initial guess vector. No goodness-of-fit test is returned.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="f"/> or <paramref name="start"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are not more data points than fit parameters.</exception>
            <exception cref="T:System.DivideByZeroException">The curvature matrix is singular, indicating that the data is independent of
            one or more parameters, or that two or more parameters are linearly dependent.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.BivariateSample.LinearLogisticRegression">
            <summary>
            Computes the best-fit linear logistic regression from the data.
            </summary>
            <returns>The fit result.</returns>
            <remarks>
            <para>Linear logistic regression is a way to fit binary outcome data to a linear model.</para>
            <para>The method assumes that binary outcomes are encoded as 0 and 1. If any y-values other than
            0 and 1 are encountered, it throws an <see cref="T:System.InvalidOperationException"/>.</para>
            <para>The fit result is two-dimensional. The first parameter is a, the second b.</para>
            </remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than three data points.</exception>
            <exception cref="T:System.InvalidOperationException">There is a y-value other than 0 or 1.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.ContingencyTable">
            <summary>
            Represents a contingency table.
            </summary>
            <remarks><para>Imagine a controlled experiment in which each data point consists of two category values. For example, a
            measurement of a driver's car and his nationality, or a person's sex and employment status. Such experiments are
            typically undertaken to determine what correlation exists between the categories.</para></remarks>
            <seealso cref="T:Meta.Numerics.Statistics.BinaryContingencyTable"/>
            <seealso href="http://en.wikipedia.org/wiki/Contingency_table" />
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new contingency table.
            </summary>
            <param name="rows">The number of rows, which must be positive.</param>
            <param name="columns">The number of columns, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.#ctor(System.Int32[0:,0:])">
            <summary>
            Initializes a new contingency table with the given data set.
            </summary>
            <param name="data">A (zero-based) matrix of contingency table entries.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.ContingencyTable.Name">
            <summary>
            Gets or sets the name of the table.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.ContingencyTable.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the count in the specified cell.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
            <returns>The count in the specified cell.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.Increment(System.Int32,System.Int32)">
            <summary>
            Increments the count in the specifed cel.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.ContingencyTable.RowCount">
            <summary>
            Gets the number of rows in the table.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.ContingencyTable.ColumnCount">
            <summary>
            Gets the number of columns in the table.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.RowTotal(System.Int32)">
            <summary>
            Gets the total counts in the specified row.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <returns>The sum of all counts in the specified row.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.ColumnTotal(System.Int32)">
            <summary>
            Gets the total counts in the specified column.
            </summary>
            <param name="c">The (zero-based) column index.</param>
            <returns>The sum of all counts in the specified column.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.ContingencyTable.Total">
            <summary>
            Gets the total counts in the table.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.Probability(System.Int32,System.Int32)">
            <summary>
            Estimates the probability of the given cell in the underlying population. 
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
            <returns>The probability for a random event to occur inthe given cell.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.ProbabilityOfRow(System.Int32)">
            <summary>
            Estimates the marginal probility of the given row in the underlying population.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <returns>The probability for a random event to occur in the given row.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.ProbabilityOfColumn(System.Int32)">
            <summary>
            Estimates the marginal probility of the given column in the underlying population.
            </summary>
            <param name="c">The (zero-based) column index.</param>
            <returns>The probability for a random envent to occur in the given column.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.ProbabilityOfRowConditionalOnColumn(System.Int32,System.Int32)">
            <summary>
            Estimates the probability of the given row, conditional on the given column.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
            <returns>The probability for a random event to occur in the given row, if it appears in the given column.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.ProbabilityOfColumnConditionalOnRow(System.Int32,System.Int32)">
            <summary>
            Estimates the probability of the given row, conditional on the given column.
            </summary>
            <param name="r">The (zero-based) row index.</param>
            <param name="c">The (zero-based) column index.</param>
            <returns>The probability for a random event to occur in the given row, if it appears in the given column.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.ContingencyTable.PearsonChiSquaredTest">
            <summary>
            Performs a Pearson &#x3C7;<sup>2</sup> test for correlation in the table.
            </summary>
            <returns>The result of the test. The test statistic is &#x3C7;<sup>2</sup> and its likelyhood under the null hypothesis is
            the (right) probability to obtain a value as large or larger.</returns>
            <remarks><para>The Pearson Pearson &#x3C7;<sup>2</sup> test tests for correlation between the row and column values. If
            row and column values are uncorrelated, then the expected number of counts in a table entry is simply proportional to the
            totals for its row and column. If that number is large for all entries, then the central limit theorem suggests that the
            actual number of counts will be distributed normally with mean equal to the expected value and standard deviation equal
            to its square root. The &#x3C7;<sup>2</sup> statistic measures the departure of the actual table from this expectation
            in the uncorrelated case, and under this null hypothesis its distribution is known. Having calculated &#x3C7;<sup>2</sup>,
            then, we can compute just how unlikely it was to obtain a value as large or larger than the one obtained.</para>
            <para>In cases where either the actual or expected counts for some entries are small or zero, the assumptions of the
            Pearson &#x3C7;<sup>2</sup> test are violated and it should not be used. For 2 X 2 experiments, the
            <see cref="M:Meta.Numerics.Statistics.BinaryContingencyTable.FisherExactTest" /> is a viable alternative in these cases.</para></remarks>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution"/>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.BernoulliDistribution">
            <summary>
            Represents a Bernoulli distribution.
            </summary>
            <remarks>
            <para>A Bernoulli distribution describes a trial with two possible outcomes. These outcomes are usually called
            "success" and "failure", but the same framework is applicable to any binary set of outcomes: right or left, true or false, male or female, dead or alive, etc.
            We represent the outcomes by 1 and 0, which are the only two integers for which the Bernoulli probability
            does not vanish. The parameter p1 is the probability of obtaining outcome 1.</para>
            <para>When multiple, independent Bernoulli trials are conducted, the binomial distribution (<see cref="T:Meta.Numerics.Statistics.Distributions.BinomialDistribution"/>)
            describes the probablity of obtaining any particular number of successes.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.BinomialDistribution"/>
            <seealso href="http://mathworld.wolfram.com/BinomialDistribution.html"/>
            <seealso href="http://en.wikipedia.org/wiki/Bernoulli_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.#ctor(System.Double)">
            <summary>
            Initializes a new Bernoulli distribution.
            </summary>
            <param name="p1">The probability of outcome 1, which must lie between zero and one.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BernoulliDistribution.ExpectationValue(System.Func{System.Int32,System.Double})">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.BetaDistribution">
            <summary>
            Represents a beta distribution.
            </summary>
            <remarks>
            <para>The beta distribution is defined on the interval [0,1]. Depending on its two shape parameters, it can take on a wide
            variety of forms on this interval.</para>
            <para>If the two shape parameters are equal, the distribution is symmetric. If the first shape parameter is less than one,
            the distribution has a singularity at its left endpoint. If the first shape parameter is greater than one, the distribution
            goes to zero at its left endpoint. The second shape parameter similarly governs the distribution's behavior at its right
            endpoint.</para>
            <para>When both shape parameters are one, the beta distribution reduces to a standard uniform distribution.</para>
            <img src="../images/UniformFromBeta.png" />
            <para>Beta distributions describe the maximum and minimum values obtained from multiple, independent draws from a standard
            uniform distribution. For n draws, the maximum value is distributed as B(n,1).</para>
            <img src="../images/BetaFromUniform.png" />
            <para>Similiarly, the minimum value is distributed as B(1,n).</para>
            <para>Because of the wide variety of shapes it can take, the beta distribution is sometimes
            used as an ad hoc model to describe any distribution observed on a finite interval.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Beta_distribution"/>
            <seealso href="http://mathworld.wolfram.com/BetaDistribution.html"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new &#x3B2; distribution.
            </summary>
            <param name="alpha">The left shape parameter, which controls the form of the distribution near x=0.</param>
            <param name="beta">The right shape parameter, which controls the form of the distribution near x=1.</param>
            <remarks>
            <para>The <paramref name="alpha"/> shape parameter controls the form of the distribution near x=0. The
            <paramref name="beta"/> shape parameter controls the form of the distribution near z=1. If a shape parameter
            is less than one, the PDF diverges on the side of the distribution it controls. If a shape parameter
            is greater than one, the PDF goes to zero on the side of the distribution it controls. If the left and right
            shapre parameters are equal, the distribution is symmetric about x=1/2.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Beta_distribution" />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Alpha">
            <summary>
            Gets the left shape parameter.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Beta">
            <summary>
            Gets the right shape parameter.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the Beta distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameters.</returns>
            <remarks>
            <para>The returned fit parameters are the &#x3B1; (<see cref="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Alpha"/>) and  &#x3B2; (<see cref="P:Meta.Numerics.Statistics.Distributions.BetaDistribution.Beta"/>) parameters, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.BetaDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new Beta distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
            <exception cref="T:System.InvalidOperationException">Not all the entries in <paramref name="sample" /> lie between zero and one.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.BinomialDistribution">
            <summary>
            Represents a discrete binomial distribution.
            </summary>
            <remarks>
            <para>The binomial distribution gives the probability of obtaining k successes
            in n independent Bernoulli trials in which the probability of success in each trial is p.</para>
            <para>For a single trial, the binomial distribution reduces to a Bernoulli distribution (<see cref="T:Meta.Numerics.Statistics.Distributions.BernoulliDistribution"/>).</para>
            <para>The test statistic for a sign test (<see cref="M:Meta.Numerics.Statistics.Sample.SignTest(System.Double)"/>) is distributed according to the Bernoulli distribution.</para>
            </remarks>
            <seealso href="http://mathworld.wolfram.com/BinomialDistribution.html"/>
            <seealso href="http://en.wikipedia.org/wiki/Binomial_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.#ctor(System.Double,System.Int32)">
            <summary>
            Initializes a new binomial distribution.
            </summary>
            <param name="p">The probability of the success in a single trial, which must lie between zero and one.</param>
            <param name="n">The number of trials, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.BinomialDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.CauchyDistribution">
            <summary>
            Represents a Cauchy distribution.
            </summary>
            <remarks>
            <para>In physical applications, the Cauchy distribution is usually called a Lorentz distribution. It models
            the shape of a spectral line.</para>
            <para>The Cauchy distribution has "fat tails". In fact, it falls off at the minimum possible rate consistent
            with having a convergent integral. For this same reason, none of its moments (above the zeroth) are defined.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Cauchy_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.#ctor">
            <summary>
            Initializes a new standard Cauchy distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Cauchy distribution.
            </summary>
            <param name="mu">The centroid of the distribution.</param>
            <param name="gamma">The width parameter of the distribution.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.CauchyDistribution.FullWithAtHalfMaximum">
            <summary>
            Gets the full width at half maximum (FWHM) of the Cauchy distribution.
            </summary>
            <remarks>
            <para>The full-width at half maximum (FWHM) is the width of the distribution peak at half its maximum value.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.CauchyDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.CauchyDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.CauchyDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.CauchyDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution">
            <summary>
            Represents a &#x3C7;<sup>2</sup> distribution.
            </summary>
            <remarks>
            <para>A chi squared distribution is an asymmetrical distribution ranging from zero to infinity with a peak near its
            number of degrees of freedom &#x3BD;. It is a one-parameter distribution determined entirely by the parameter nu.</para>
            <img src="../images/ChiSquaredPlot.png" />
            <para>The figure above shows the &#x3C7;<sup>2</sup> distribution for &#x3BD; = 6, as well as the normal distribution
            with equal mean and variance for reference.</para>
            <para>The sum of the squares of &#x3BD; independent standard-normal distributed variables is distributed as &#x3C7;<sup>2</sup>
            with &#x3BD; degrees of freedom.</para>
            <img src="../images/ChiSquaredFromNormal.png" />
            <para>The &#x3C7;<sup>2</sup> distribution appears in least-squares fitting as the distribution of the sum-of-squared-deviations
            under the null hypothesis that the model explains the data. For example, the goodness-of-fit statistic returned by the
            model our model fitting methods (<see cref="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.FitToFunction(System.Func{System.Double[],`0,System.Double},System.Double[])"/>, <see cref="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.FitToLinearFunction(System.Func{`0,System.Double}[])"/>,
            <see cref="M:Meta.Numerics.Statistics.UncertainMeasurementSample.FitToLine"/>, and others) follows a &#x3C7;<sup>2</sup> distribution.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Statistics.ContingencyTable.PearsonChiSquaredTest"/>
            <seealso href="http://en.wikipedia.org/wiki/Chi-square_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.#ctor(System.Int32)">
            <summary>
            Initializes a new &#x3C7;<sup>2</sup> distribution.
            </summary>
            <param name="nu">The number of degrees of freedom, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.DegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom &#x3BD; of the distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ChiSquaredDistribution.Support">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution">
            <summary>
            Represents a discrete distribution as a continous distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.#ctor(Meta.Numerics.Statistics.Distributions.DiscreteDistribution)">
            <summary>
            Initializes a new shim that represents a discrete distribution as a continuous distribution.
            </summary>
            <param name="distribution">The discrete distiribution to represent.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.#ctor(Meta.Numerics.Statistics.Distributions.DiscreteDistribution,Meta.Numerics.Interval)">
            <summary>
            Initializes a new shim that represents a discrete distribution as a continuous distribution.
            </summary>
            <param name="distribution">The discrete distiribution to represent.</param>
            <param name="support">The continuous support interval into which the discrete support interval is to be mapped.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.ProbabilityDensity(System.Double)">
            <summary>
            Not valid for discrete distributions.
            </summary>
            <param name="x">The argument.</param>
            <returns>Throws an exception.</returns>
            <remarks>
            <para>Technically, the PDF of a discrete probability distribution consists of delta functions at the integers, each
            with a weight equal to the PMF at that integer. Since this is not representable in floating point arithmetic, calling
            this method is an invalid operation.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteAsContinuousDistribution.Support">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.DiscreteDistribution">
            <summary>
            Represents all discrete, univariate probability distrubtions.
            </summary>
            <remarks>
            <para>A discrete distribution is a distribution over the integers.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.ProbabilityMass(System.Int32)">
            <summary>
            Returns the probability of the obtaining the given value.
            </summary>
            <param name="k">The value.</param>
            <returns>The probability of obtaining the value.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.Minimum">
            <summary>
            Gets the smallest value in the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.Maximum">
            <summary>
            Gets the largest value in the distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.LeftExclusiveProbability(System.Int32)">
            <summary>
            Computes the probability of obtaining a value less than the given value.
            </summary>
            <param name="k">The value.</param>
            <returns>The total probability of obtaining a value strictly less than <paramref name="k"/>.</returns>
            <seealso cref="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.RightExclusiveProbability(System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.LeftInclusiveProbability(System.Int32)">
            <summary>
            Computes the probability of obtaining a value less than or equal to the given value.
            </summary>
            <param name="k">The value.</param>
            <returns>The total probability of obtaining a value les than or equal to <paramref name="k"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.RightExclusiveProbability(System.Int32)">
            <summary>
            Computes the probability of obtaining a value greater than the given value.
            </summary>
            <param name="k">The value.</param>
            <returns>The total probability of obtaining a value strictly greater than <paramref name="k"/>.</returns>
            <seealso cref="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.LeftExclusiveProbability(System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.InverseLeftProbability(System.Double)">
            <summary>
            Computes the value corresponding to the given percentile.
            </summary>
            <param name="P">The percentile.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.ExpectationValue(System.Func{System.Int32,System.Double})">
            <summary>
            Computes the expectation value of an artibrary function.
            </summary>
            <param name="f">The function.</param>
            <returns>The expectation value of the function.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.Mean">
            <summary>
            Gets the mean of the distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.Moment(System.Int32)">
            <summary>
            Gets a raw moment of the distribution.
            </summary>
            <param name="r">The order of the moment.</param>
            <returns>The raw moment M<sub>r</sub>.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.MomentAboutMean(System.Int32)">
            <summary>
            Gets a central moment of the distribution.
            </summary>
            <param name="r">The order of the moment.</param>
            <returns>The central moment C<sub>r</sub>.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteDistribution.GetRandomValue(System.Random)">
            <summary>
            Produces a random integer drawn from the distribution.
            </summary>
            <param name="rng">A random number generator.</param>
            <returns>A random integer drawn from the distribution.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution">
            <summary>
            Describes a discrete uniform distribution.
            </summary>
            <remarks>
            <para>In a discrete uniform distribution, each integer in the allowed range is equally probable.</para>
            <para>For example, the distribution of results for one roll of a fair die is DiscreteUniformDistribution(1,6).</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.#ctor(System.Int32,System.Int32)">
            <summary>
            Instantiates a new discrete uniform distribution with the given endpoints.
            </summary>
            <param name="a">One end-point.</param>
            <param name="b">The other end-point.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.ExpectationValue(System.Func{System.Int32,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.DiscreteUniformDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.Distribution">
            <summary>
            Represents all continuous, univariate probability distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.ProbabilityDensity(System.Double)">
            <summary>
            Returns the probability density at the given point.
            </summary>
            <param name="x">The reference point.</param>
            <returns>The probability density p(x).</returns>
            <remarks>
            <para>The probability density function (PDF) gives the relative probability of obtaining different values.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.LeftProbability(System.Double)">
            <summary>
            Returns the cumulative probability to the left of (below) the given point.
            </summary>
            <param name="x">The reference point.</param>
            <returns>The integrated probability to obtain a result below the reference point.</returns>
            <remarks>
            <para>The left probability function is commonly called the cumulative distribution function (CDF).</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.RightProbability(System.Double)">
            <summary>
            Return the cumulative probability to the right of (above) the given point.
            </summary>
            <param name="x">The reference point.</param>
            <returns>The integrated probability 1-P(x1) to obtain a result above the reference point.</returns>
            <remarks>
            <para>In survival analysis, the right probability function is commonly called the survival function, because it gives the
            fraction of the population remaining after the given time.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.InverseLeftProbability(System.Double)">
            <summary>
            Returns the point at which the cumulative distribution function attains a given value. 
            </summary>
            <param name="P">The left cumulative probability P, which must lie between 0 and 1.</param>
            <returns>The value x at which <see cref="M:Meta.Numerics.Statistics.Distributions.Distribution.LeftProbability(System.Double)"/> equals P.</returns>
            <remarks>
            <para>The inverse left probability is commonly called the quantile function. Given a quantile,
            it tells which variable value is the lower border of that quantile.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="P"/> lies outside [0,1].</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.InverseRightProbability(System.Double)">
            <summary>
            Returns the point at which the right probability function attains the given value.
            </summary>
            <param name="Q">The right cumulative probability, which must lie between 0 and 1.</param>
            <returns>The value x for which <see cref="M:Meta.Numerics.Statistics.Distributions.Distribution.RightProbability(System.Double)"/> equals Q.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.Distribution.Median">
            <summary>
            Gets the median of the distribution.
            </summary>
            <remarks>The median is the point with equal integrated probability above and below, i.e. with P(x1) = 0.5.</remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.Distribution.Support">
            <summary>
            Gets the interval over which the distribution is nonvanishing.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.ExpectationValue(System.Func{System.Double,System.Double})">
            <summary>
            Computes the expectation value of the given function.
            </summary>
            <param name="f">The function.</param>
            <returns>The expectation value of the function.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.Distribution.GetRandomValue(System.Random)">
            <summary>
            Returns a random value.
            </summary>
            <param name="rng">A random number generator.</param>
            <returns>A number distributed according to the distribution.</returns>
            <remarks>
            <para>Note that the random number generator <paramref name="rng"/> will be advanced by this method. The next call to its
            generator methods will not give the same value as it would had it not been passed to this method.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="rng"/> is null.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.ExponentialDistribution">
            <summary>
            Represents an exponential distribution.
            </summary>
            <remarks>
            <para>An exponential distribution falls off exponentially in the range from zero to infinity. It is a one-parameter
            distribution, determined entirely by its rate of fall-off.</para>
            <img src="../images/ExponentialPlot.png" />
            <para>The exponential distribution describes the distribution of decay times of radioactive particles.</para>
            <para>An exponential distribution with mean one is called a standard exponential distribution. Any exponential distribution
            can be converted to a standard exponential by reparameterizing the data into "fractions of the mean,"
            i.e. z = x / &#x3BC;.</para>
            <para>Processes resulting in events that are exponentially distributed in time are said to be "ageless" because the hazard function
            of the exponential distribution is constant. The Weibull distribution (<see cref="T:Meta.Numerics.Statistics.Distributions.WeibullDistribution"/>) is a generalization
            of the exponential distribution which the hazard function changes (typically by increasing) with time.</para>
            </remarks>
            <seealso href="WeibullDistribution"/>
            <seealso href="http://en.wikipedia.org/wiki/Exponential_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.#ctor(System.Double)">
            <summary>
            Initializes a new exponential distribution with the given mean.
            </summary>
            <param name="mu">The mean, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.#ctor">
            <summary>
            Initializes a new standard exponential distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the exponential distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameter.</returns>
            <remarks>
            <para>The returned fit parameter is &#x3BC; (the <see cref="P:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.Mean"/>).
            This is the same parameter that is required by the <see cref="M:Meta.Numerics.Statistics.Distributions.ExponentialDistribution.#ctor(System.Double)"/> constructor to
            specify a new exponential distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than two values.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="sample"/> contains non-positive values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.FisherDistribution">
            <summary>
            Represents the distribution of Fisher's F-statistic.
            </summary>
            <remarks>
            <para>The ratio of the variances of two sets of normally distributed variables is distributed according to Fisher's F-distribution.</para>
            <img src="../images/FisherFromNormal.png" />
            <para>Many test statistics are ratios of variances and are therefore distributed according to the F-distribution. These include
            the F-test (<see cref="M:Meta.Numerics.Statistics.Sample.FisherFTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>),
            the goodness-of-fit test for a multi-linear regression (<see cref="M:Meta.Numerics.Statistics.MultivariateSample.LinearRegression(System.Int32)"/>),
            and ANOVA tests (<see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(System.Collections.Generic.ICollection{Meta.Numerics.Statistics.Sample})"/>).</para>
            <para>The Fisher distribution is related to the Beta distribution (<see cref="T:Meta.Numerics.Statistics.Distributions.BetaDistribution"/>) by a simple
            variable transformation.</para>
            <img src="../images/FisherBeta.png" />
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/F_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Fisher distribution.
            </summary>
            <param name="nu1">The number of degrees of freedom in the numerator, which must be positive.</param>
            <param name="nu2">The number of degrees of freedom in the denominator, which must be positive.</param>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.FisherFTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.FisherDistribution.NumeratorDegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom in the numerator.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.FisherDistribution.DenominatorDegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom in the denominator.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.FisherDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.FisherDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.FisherDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.GammaDistribution">
            <summary>
            Represents a Gamma distribution.
            </summary>
            <remarks>
            <para>The sum of n exponentially distributed variates is a Gamma distributed variate.</para>
            <img src="../images/GammaFromExponential.png" />
            <para>When the shape parameter is an integer, the Gamma distribution is also called the Erlang distribution. When
            the shape parameter is one, the Gamma distribution reduces to the exponential distribution.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.ExponentialDistribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of a Gamma distribution with the given parameters.
            </summary>
            <param name="shape">The shape parameter, which must be positive.</param>
            <param name="scale">The scale parameter, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the standard Gamma distribution.
            </summary>
            <param name="shape">The shape parameter, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.ShapeParameter">
            <summary>
            Gets the shape parameter for the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.ScaleParameter">
            <summary>
            Gets the scale parameter for the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the Gamma distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameters.</returns>
            <remarks>
            <para>The returned fit parameters are the <see cref="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.ShapeParameter"/> and <see cref="P:Meta.Numerics.Statistics.Distributions.GammaDistribution.ScaleParameter"/>, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.GammaDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new Gamma distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="sample"/> contains non-positive values.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.GeometricDistribution">
            <summary>
            Represents a geometric distribution.
            </summary>
            <remarks>
            <para>The probability of obtaining each integer value in a geometric distribution is lower than the probability of obtaining
            the previous value by a constant factor. The probability thus decreases geometricly with the value, giving the distribution its name.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.#ctor(System.Double)">
            <summary>
            Initializes a new geometric distribution.
            </summary>
            <param name="p">The probabability of the value zero.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GeometricDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.GumbelDistribution">
            <summary>
            Represents a Gumbel distribution.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Gumbel_distribution"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.#ctor">
            <summary>
            Initializes a new standard Gumbel distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Gumbel distribution with the given parameters.
            </summary>
            <param name="location">The location parameter.</param>
            <param name="scale">The scale parameter, which must be positive.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="scale"/> is negative or zero.</exception>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.LocationParameter">
            <summary>
            Gets the location parameter of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.ScaleParameter">
            <summary>
            Gets the scale parameter of the distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.GumbelDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution">
            <summary>
            Represents the distribution of the Kolmogorov-Smirnov D statistic.
            </summary>
            <remarks><para>The D statistic in a Kolmogorov-Smirnov test is distributed (under the null hypothesis) according to a Kolmogorov disribution, in
            the limit of a large sample size.</para></remarks>
            <seealse cref="M:Meta.Numerics.Statistics.Sample.KolmogorovSmirnovTest(Meta.Numerics.Statistics.Distributions.Distribution)" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.#ctor">
            <summary>
            Initializes a new asymptotic Kolmogorov distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.Median">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KolmogorovExactDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.KuiperDistribution">
            <summary>
            Represents the asymptotic distribution of Kuiper's V statistic.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.#ctor">
            <summary>
            Initializes a new Kuiper distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KuiperDistribution.Support">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KuiperDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.KuiperDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperExactDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.KuiperExactDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.LogisticDistribution">
            <summary>
            Represents a logistic distribution.
            </summary>
            <remarks>
            <para>Like the normal distribution, the logistic distribution is a symmetric, unimodal distribution
            distribution with exponentially supressed tails.</para>
            <para>A logistic distribution with mean zero and standard deviation one is called a standard logistic distribution. Any logistic distribution
            can be converted to a standard logistic distribution by reparameterzing into z = (x-m)/s.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Logistic_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.#ctor">
            <summary>
            Initializes a new standard logistic distribution.
            </summary>
            <remarks>
            <para>The standard logistic distribution has zero mean and a unit width parameter.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new logistic distribution with the given mean and width parameters.
            </summary>
            <param name="m">The mean.</param>
            <param name="s">The width parameter.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LogisticDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LogisticDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.LognormalDistribution">
            <summary>
            Represents a log-normal distribution.
            </summary>
            <remarks>
            <para>The logrithm of a log-normal distributed variable is distributed normally.</para>
            <img src="../images/LogNormalFromNormal.png" />
            <para>The log-normal distribution is commonly used in financial engineering as a model of stock prices.
            If the rate of return on an asset is distributed normally, then its price will be distributed log-normally.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.NormalDistribution"/>
            <seealso href="http://en.wikipedia.org/wiki/Log-normal_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a log-normal distribution.
            </summary>
            <param name="mu">The mean of the underlying normal distribution.</param>
            <param name="sigma">The standard deviation of the underlying normal distribution.</param>
            <remarks>
            <para>Note that the values of &#x3BC; and  &#x3C3; parameters are
            <em>not</em> the mean and standard deviation of the log-normal distribution.
            They are the mean and standard deviation of their logrithms z = ln x. This is
            the standard method of characterizing a log-normal distribution.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.#ctor">
            <summary>
            Initializes a standard log-normal distribution.
            </summary>
            <remarks>
            <para>A standard log-normal distribution has &#x3BC; = 0 and &#x3C3; = 1.
            It is the log transform of the standard normal distribution.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Mu">
            <summary>
            Gets the value of the &#x3BC; parameter.
            </summary>
            <remarks>
            <para>Note that the value of this parameter is not the mean of the distribution.
            It is the value given to the distribution constructor (<see cref="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.#ctor(System.Double,System.Double)"/>),
            which is the mean of the underlying normal distribution.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Sigma">
            <summary>
            Gets the value of the &#x3C3; parameter.
            </summary>
            <remarks>
            <para>Note that the value of this parameter is not the standard deviation of the distribution.
            It is the value given to the distribution constructor (<see cref="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.#ctor(System.Double,System.Double)"/>),
            which is the sandard deviation of the underlying normal distribution.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the log-normal distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameters.</returns>
            <remarks>
            <para>The returned fit parameters are the &#x3BC; (<see cref="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Mu"/>) and &#x3C3; (<see cref="P:Meta.Numerics.Statistics.Distributions.LognormalDistribution.Sigma"/>) parameters, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.LognormalDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new log-normal distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="sample"/> contains non-positive values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution">
            <summary>
            Represents the distribution of the Mann-Whitney test statistic.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new Mann-Whitney distribution.
            </summary>
            <param name="m">The number of elements in the first sample.</param>
            <param name="n">The number of elements in the second sample.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MannWhitneyExactDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.MomentMath">
            <summary>
            Contains methods for converting between different kinds of moments.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.RawToCentral(System.Double[])">
            <summary>
            Converts raw moments to central moments.
            </summary>
            <param name="M">A set of raw moments.</param>
            <returns>The corresponding set of central moments.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="M"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth raw moment is not one.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.CentralToRaw(System.Double,System.Double[])">
            <summary>
            Converts central moments to raw moments.
            </summary>
            <param name="mu">The mean.</param>
            <param name="C">A set of central moments.</param>
            <returns>The corresponding set of central moments.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="C"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth central moment is not one, or the first central moment is not zero.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.CumulantToRaw(System.Double[])">
            <summary>
            Converts cumulants to raw moments.
            </summary>
            <param name="K">A set of cumulants.</param>
            <returns>The corresponding set of raw moments.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="K"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth cumulant is not zero.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.CumulantToCentral(System.Double[])">
            <summary>
            Converts cumulants to central moments.
            </summary>
            <param name="K">A set of cumulants.</param>
            <returns>The corresponding set of central moments.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="K"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth cumulant is not zero.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.RawToCumulant(System.Double[])">
            <summary>
            Converts raw moments to cumulants.
            </summary>
            <param name="M">A set of raw moments.</param>
            <returns>The corresponding set of cumulants.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="M"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth raw moment is not one.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.MomentMath.CentralToCumulant(System.Double,System.Double[])">
            <summary>
            Converts central moments to cumulants.
            </summary>
            <param name="mu">The mean.</param>
            <param name="C">A set of central moments.</param>
            <returns>The corresponding set of cumulants.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="C"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The zeroth central moment is not one, or the first central moment is not zero.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution">
            <summary>
            Represents a negative binomial distribution.
            </summary>
            <remarks>
            <para>Consider a series of independent, repeated Bernoulli trials, each of which results in success with probability p or failure
            with probabilty 1-p. If one repeats the trials until r failures occur, the negative binomial distribution gives the probability
            of having seen k successes before the rth failure.</para>
            <para>Keep in mind that there are several different conventions for the meaning of r, p, and k. The most common are that
            k denotes the number of successes before the rth failure (used here and in the referenced Wikipedia article), and that
            k denotes the number of failures before the rth success (used by Mathmatica). Since these two conventions simply
            switch success and failure, they can be interconverted by interchanging p and 1-p.</para>
            </remarks>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.BernoulliDistribution"/>
            <seealso href="https://en.wikipedia.org/wiki/Negative_binomial_distribution"/>
            <seealso href="http://mathworld.wolfram.com/NegativeBinomialDistribution.html"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new negative binomial distribution.
            </summary>
            <param name="r">The number of failures required, which must be positive.</param>
            <param name="p">The probability of success for each trial, which must lie between 0 and 1.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.LeftInclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NegativeBinomialDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.NormalDistribution">
            <summary>
            Represents a normal (Gaussian) distribution.
            </summary>
            <remarks>
            <para>A normal distribution is a bell-shaped curve centered at its mean and falling off symmetrically on each side. It is
            a two-parameter distribution determined by giving its mean and standard deviation, i.e. its center and width. Its range is the
            entire real number line, but the tails, i.e. points more than a few standard deviations from the means, fall off extremely rapidly.</para>
            <img src="../images/NormalPlot.png" />
            <para>A normal distribution with mean zero and standard deviation one is called a standard normal distribution. Any normal distribution
            can be converted to a standard normal distribution by reparameterzing the data in terms of "standard deviations from the mean",
            i.e. z = (x - &#x3BC;) / &#x3C3;.</para>
            <para>Normal distribution appear in many contexts. In practical work, the normal distribution is often used as a crude
            model for the distribution of any continuous parameter that tends to cluster near its average, for example human height
            and weight. In more refined theoretical work, the normal distribution often emerges as a limiting distribution. For example,
            it can be shown that, if a large number of errors affect a measurement, then for nearly any underlying distribution
            of error terms, the distribution of total error tends to a normal distribution.</para>
            <para>The normal distribution is sometimes called a Gaussian distribtuion, after the mathematician Friedrich Gauss.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Normal_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new normal distribution with the given mean and standard deviation.
            </summary>
            <param name="mu">The mean.</param>
            <param name="sigma">The standard deviation, which must be positive.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sigma"/> is less than or equal to zero.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.#ctor">
            <summary>
            Initializes a new standard normal distribution.
            </summary>
            <remarks>The standard normal distribution has mean zero and standard deviation one.</remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.Median">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the normal distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameters.</returns>
            <remarks>
            <para>The returned fit parameters are the &#x3BC; (<see cref="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.Mean"/>) and &#x3C3; (<see cref="P:Meta.Numerics.Statistics.Distributions.NormalDistribution.StandardDeviation"/>) parameters, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new normal distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.ParetoDistribution">
            <summary>
            Represents a Pareto or power law distribution.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Pareto_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Pareto distribution.
            </summary>
            <param name="mu">The scale parameter, which must be positive.</param>
            <param name="alpha">The shape parameter, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.ScaleParameter">
            <summary>
            Gets the scale parameter of the Pareto distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.ShapeParameter">
            <summary>
            Gets the shape parameter of the Pareto distribution.
            </summary>
            <remarks>
            <para>For a given shape parameter &#x3B1;, the probability density falls off as x<sup>-(&#x3B1;+1)</sup>.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.GiniCoefficient">
            <summary>
            Gets the Gini coefficient corresponding to the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.ParetoDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.ParetoDistribution.Support">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.PearsonRDistribution">
            <summary>
            Represents the distribution of Pearsons's r statistic.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the Pearson r distribution for the given number of pairs.
            </summary>
            <param name="n">The number of pairs, which must be three or more.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.Support">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PearsonRDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.PoissonDistribution">
            <summary>
            Represented a Poisson distribution.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.#ctor(System.Double)">
            <summary>
            Creates a new instance of a Poisson distribution.
            </summary>
            <param name="mu">The mean, which must be positive.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.ProbabilityMass(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Minimum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Maximum">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.PoissonDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.LeftInclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.LeftExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.RightExclusiveProbability(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.PoissonDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.StudentDistribution">
            <summary>
            Represents the distribution of Student't t statistic.
            </summary>
            <remarks><para>The mean of n independent standard-normal distributed variables, divided by their root mean square,
            is distributed according a Student distribution with n degrees of freedom. Since this is the form of the expression
            for the mean of a sample divided by its standard deviation, the Student distribution expresses the distribution of
            sample means arround the population mean, for a normally distributed population.</para></remarks>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)"/>
            <seealso href="http://en.wikipedia.org/wiki/Student_t_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.#ctor(System.Double)">
            <summary>
            Initializes a new Student distribution.
            </summary>
            <param name="nu">The number of degrees of freedom, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.StudentDistribution.DegreesOfFreedom">
            <summary>
            Gets the number of degrees of freedom.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.StudentDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.StudentDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.StudentDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.StudentDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.StudentDistribution.Median">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.TriangularDistribution">
            <summary>
            Represents a triangular distribution.
            </summary>
            <remarks>
            <para>Like a uniform distribution, a triangular distribution is confined to a finite interval. Unlike a
            uniform distribution, a triangular distribution is not uniform across the interval.</para>
            <para>Triangular distributions are often used in project planning, where a maximum, minimum, and most
            likely value for some quantity is known or supposed.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Triangular_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new triangular distribution.
            </summary>
            <param name="a">One inflection point of the distribution.</param>
            <param name="b">A second inflection point of the distribution.</param>
            <param name="c">A third inflection point of the distribution.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.TriangularDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.TriangularDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.TriangularDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.TriangularDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.UniformDistribution">
            <summary>
            Represents a uniform distribution over an interval.
            </summary>
            <seealso href="http://en.wikipedia.org/wiki/Uniform_distribution_(continuous)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.#ctor(Meta.Numerics.Interval)">
            <summary>
            Initializes a new uniform distribution on the given interval.
            </summary>
            <param name="range">The range of the distribution.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.#ctor">
            <summary>
            Initializes a new standard uniform distribution.
            </summary>
            <remarks>
            <para>A standard uniform distribution is uniform on the interval [0,1].</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UniformDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.StandardDeviation">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.ExcessKurtosis">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.Median">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UniformDistribution.Support">
            <inheritdoc />
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.UnivariateDistribution">
            <summary>
            Represents a probability distribution over a single variable.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Mean">
            <summary>
            Gets the mean of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Variance">
            <summary>
            Gets the variance of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.StandardDeviation">
            <summary>
            Gets the standard deviation of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Skewness">
            <summary>
            Gets the skewness of the distribution.
            </summary>
            <remarks>
            <para>The skewness of a distribution is a measurement of its asymmetry about its mean.
            It is the third moment about the mean, measured in units of the cubed standard deviation.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.ExcessKurtosis">
            <summary>
            Gets the excess kurtosis of the distribution.
            </summary>
            <remarks>
            <para>The excess kurtosis of a distribution is a measurement of the fatness of its tails relative
            to the normal distribution.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Moment(System.Int32)">
            <summary>
            Computes a raw moment of the distribution.
            </summary>
            <param name="r">The order of the moment to compute.</param>
            <returns>The rth raw moment of the distribution.</returns>
            <seealso cref="M:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Moment(System.Int32)" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.MomentAboutMean(System.Int32)">
            <summary>
            Computes a central moment of the distribution.
            </summary>
            <param name="r">The order of the moment to compute.</param>
            <returns>The rth central moment of the distribution.</returns>
            <seealso cref="M:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Moment(System.Int32)" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.UnivariateDistribution.Cumulant(System.Int32)">
            <summary>
            Computes a cumulant of the distribution.
            </summary>
            <param name="r">The index of the cumulant to compute.</param>
            <returns>The rth cumulant of the distribution.</returns>
            <seealso href="http://en.wikipedia.org/wiki/Cumulant"/>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.WaldDistribution">
            <summary>
            Represents a Wald distribution.
            </summary>
            <remakrs>
            <para>The Wald distribution, also called the inverse Gaussian distribution, is the distribution of first
            passage times for a random walk.</para>
            <para>This can be phrased in terms of the Gambler's ruin problem: given an initial endowment x, a gambler
            repeatedly plays a game in which he wins 1 dollar with probability p and looses one dollar with probability
            q = 1 - p. If q > p, he will eventually loose all his endowment. What is the probability distribution that
            he will do so after exactly t games?</para>
            </remakrs>
            <seealso href="http://en.wikipedia.org/wiki/Inverse_Gaussian_distribution"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Wald distribution.
            </summary>
            <param name="mean">The mean value, which must be positive.</param>
            <param name="shape">The shape parameter, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.ShapeParameter">
            <summary>
            Gets the shape parameter of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.Skewness">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.Cumulant(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Determines the parameters of the Wald distribution that best fits a sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The fit.</returns>
            <remarks>
            <para>The returned fit parameters are the <see cref="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.Mean"/> and <see cref="P:Meta.Numerics.Statistics.Distributions.WaldDistribution.ShapeParameter"/>, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.WaldDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new Wald distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="sample"/> contains non-positive values.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.Distributions.WeibullDistribution">
            <summary>
            Represents a Weibull distribution.
            </summary>
            <remarks>
            <para>The Weibull distribution is a generalized form of the exponential distriubtion
            for which the decay probability is not constant, but instead increases with time
            (for shape parameters greater than one) or, less commonly, decreases with time (for
            shape parameters less than one). When the shape parameter is one, the Weibull
            distribution reduces to the exponential distribution.</para>
            <para>The Weibull distribution is commonly used in engineering applications to
            model the time-to-failure of industrial componets.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Weibull_distribution" />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new Weibull distribution.
            </summary>
            <param name="scale">The scale parameter, which must be positive.</param>
            <param name="shape">The shape parameter, which must be positive.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.ScaleParameter">
            <summary>
            Gets the scale parameter of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.ShapeParameter">
            <summary>
            Gets the shape parameter of the distribution.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.Support">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.ProbabilityDensity(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.LeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.RightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.InverseLeftProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.InverseRightProbability(System.Double)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.Mean">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.Median">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.Moment(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.MomentAboutMean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.Variance">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.GetRandomValue(System.Random)">
            <inheritdoc />
        </member>
        <member name="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.FitToSample(Meta.Numerics.Statistics.Sample)">
            <summary>
            Computes the Weibull distribution that best fits the given sample.
            </summary>
            <param name="sample">The sample to fit.</param>
            <returns>The best fit parameters.</returns>
            <remarks>
            <para>The returned fit parameters are the <see cref="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.ShapeParameter"/> and <see cref="P:Meta.Numerics.Statistics.Distributions.WeibullDistribution.ScaleParameter"/>, in that order.
            These are the same parameters, in the same order, that are required by the <see cref="M:Meta.Numerics.Statistics.Distributions.WeibullDistribution.#ctor(System.Double,System.Double)"/> constructor to
            specify a new Weibull distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sample"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"><paramref name="sample"/> contains non-positive values.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="sample"/> contains fewer than three values.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.LinearRegressionFitResult">
            <summary>
            Describes the result of a linear regression.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.LinearRegressionFitResult.Intercept">
            <summary>
            Gets the best fit value of the intercept and its associated uncertainty.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.LinearRegressionFitResult.Slope">
            <summary>
            Gets the best-fit value of the slope and its associated uncertainty.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.LinearRegressionFitResult.Residuals">
            <summary>
            Returns the residuals.
            </summary>
            <returns>A bivariate sample of residuals of the fit.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.LinearRegressionFitResult.Predict(System.Double)">
            <summary>
            Predicts the Y value at a new X value.
            </summary>
            <param name="x">The new X value.</param>
            <returns>The predicted value of Y and its associated uncertainty.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.LinearRegressionFitResult.R">
            <summary>
            Gets the Pearson R test of linear correlation.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.LinearRegressionFitResult.F">
            <summary>
            Gets the Fisher F test for the linear regression.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.LinearRegressionFitResult.Anova">
            <summary>
            Gets an analysis of variance for the linear regression.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.FitResult">
            <summary>
            Represents the result of a fit procedure.
            </summary>
            <remarks>
            <para>All fit methods in the Meta.Numerics library return their results as an instance of the FitResult class.
            This includes methods that fit a sample to a distribution
            (e.g. <see cref="M:Meta.Numerics.Statistics.Distributions.NormalDistribution.FitToSample(Meta.Numerics.Statistics.Sample)"/>),
            regression methods for bivariate and multivariate data (e.g. <see cref="M:Meta.Numerics.Statistics.BivariateSample.LinearLogisticRegression"/>),
            and least-squares fits of data with error bars to a model function (e.g. <see cref="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.FitToFunction(System.Func{System.Double[],`0,System.Double},System.Double[])"/>).
            </para>
            <para>A FitResult instance contains not only the parameter values, but also covariances and a goodness-of-fit test.</para> 
            <para>The vector of best-fit parameter values can be obtained as an array using the <see cref="P:Meta.Numerics.Statistics.FitResult.Parameters"/> method.
            Individual parameter values can be obtained using the <see cref="M:Meta.Numerics.Statistics.FitResult.Parameter(System.Int32)"/> method; this method gives not only a best-fit
            value but also an uncertainty by returning a <see cref="T:Meta.Numerics.UncertainValue"/>.</para>
            <para>The matrix of covariances can be obtained using the <see cref="P:Meta.Numerics.Statistics.FitResult.CovarianceMatrix"/> method. Covariances between
            specific pairs of parameters van be obtained using the <see cref="M:Meta.Numerics.Statistics.FitResult.Covariance(System.Int32,System.Int32)"/> method.</para>
            <para>The goodness-of-fit test result stored in the <see cref="P:Meta.Numerics.Statistics.FitResult.GoodnessOfFit"/> measures the quality of the fit.
            For fits to distributions, it is a Kolmogorov-Smirnov test. For regressions, it is an F-test. For fits to
            data with error bars, it is a chi-square test.</para>
            <para>Fits are done using the maximum likelyhood method, with results corrected for any small-sample bias.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Maximum_likelihood"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.FitResult.Dimension">
            <summary>
            Gets the number of fit parameters.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.FitResult.Parameters">
            <summary>
            Gets the best fit parameter set.
            </summary>
            <value>A read-only vector containing the best-fit parameter values.</value>
        </member>
        <member name="M:Meta.Numerics.Statistics.FitResult.Parameter(System.Int32)">
            <summary>
            Get an estimate of a fit parameter.
            </summary>
            <param name="n">The (zero-based) parameter number.</param>
            <returns>An estimate of the parameter.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is not within [0,<see cref="P:Meta.Numerics.Statistics.FitResult.Dimension"/>-1].</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.FitResult.Covariance(System.Int32,System.Int32)">
            <summary>
            Gets the covariance of two fit parameters.
            </summary>
            <param name="n">The (zero-based) number of the fist parameter.</param>
            <param name="m">The (zero-based) number of the second parameter.</param>
            <returns>The covariance of the two fit parameters.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> or <paramref name="m"/> is not within [0,<see cref="P:Meta.Numerics.Statistics.FitResult.Dimension"/>-1].</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.FitResult.CorrelationCoefficient(System.Int32,System.Int32)">
            <summary>
            Gets the coefficient of correlation between two fit parameters.
            </summary>
            <param name="n">The (zero-based) number of the first parameter.</param>
            <param name="m">The (zero-based) number of the second parameter.</param>
            <returns>The correlation coefficient between the two parameters.</returns>
            <remarks>
            <para>The correlation coefficient between two parameters is a re-scaling of their covariance to a number
            between -1 and 1 that indicates the strength of their correlation.</para>
            <para>The correlation coefficient is also called the Pearson R coefficient.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> or <paramref name="m"/> is not within [0,<see cref="P:Meta.Numerics.Statistics.FitResult.Dimension"/>-1].</exception>
        </member>
        <member name="P:Meta.Numerics.Statistics.FitResult.CovarianceMatrix">
            <summary>
            Gets the covariance matrix containing the variances and covariances for all fit parameters.
            </summary>
            <returns>The covariance matrix.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.FitResult.GoodnessOfFit">
            <summary>
            Gets a test of the quality of the fit.
            </summary>
            <remarks>
            <para>Which test is used to evaluate goodness-of-fit depends on the type of fit that was performed.</para>
            <para>If no goodness-of-fit test was performed as a part of the fit, this property will be null.</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Statistics.Histogram">
            <summary>
            Represents a histogram.
            </summary>
            <remarks>
            <para>A histogram stores the number of occurances of a value (called the count) within a set of ranges (called bins). It is the
            natural system to store discrete univariate data. The natural system to store continuous univariate data is the <see cref="T:Meta.Numerics.Statistics.Sample"/>
            class, but often histograms are also used for continuous data, for example because there is too much data to record each value
            individually.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Histogram"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Histogram.#ctor(System.Int32)">
            <summary>
            Creates a histogram with the given number of bins.
            </summary>
            <param name="binCount">The number of bins.</param>
            <remarks>
            <para>By default, the bin borders are the integers, i.e. values in [0, 1) fall into bin 0, values in [1, 2) fall
            into bin 1, etc.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="binCount"/> is less than 1.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Histogram.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Create a histogram with the given bin borders.
            </summary>
            <param name="binBorders">A list of bin borders.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="binBorders"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="binBorders"/> has less than two values, or the values are not ordered.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Histogram.Add(System.Double)">
            <summary>
            Adds a new value to the histogram.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Histogram.Clear">
            <summary>
            Sets all bin counts to zero.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Histogram.Bins">
            <summary>
            Gets a collection of histogram bins.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Histogram.TotalCounts">
            <summary>
            Gets the total number of counts in the histogram.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Histogram.BelowRangeBin">
            <summary>
            Gets a bin for all values below the histogram range.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Histogram.AboveRangeBin">
            <summary>
            Gets a bin for all values above the histogram range.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Histogram.Range">
            <summary>
            The range of values in the histogram.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Histogram.ChiSquaredTest(Meta.Numerics.Statistics.Distributions.DiscreteDistribution)">
            <summary>
            Performs a  &#x3C7;<sup>2</sup> test comparing the histogram to the given distribution.
            </summary>
            <param name="distribution">The distribution against which to test the histogram.</param>
            <returns>The test result.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.HistogramBin">
            <summary>
            Represents one bin in a histogram.
            </summary>
            <seealso cref="T:Meta.Numerics.Statistics.Histogram"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.HistogramBin.Counts">
            <summary>
            Gets or sets the number of counts in the bin.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.HistogramBin.Range">
            <summary>
            Gets the range of values stored in the bin.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.HistogramBin.Increment">
            <summary>
            Increments (increases by one) the bin count.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.HistogramBin.Deincrement">
            <summary>
            De-increments (reduces by one) the bin count.
            </summary>
            <exception cref="T:System.InvalidOperationException">The bin count was already zero.</exception>
        </member>
        <member name="T:Meta.Numerics.Statistics.HistogramBinsCollection">
            <summary>
            Represents a collection of histogram bins.
            </summary>
            <seealso cref="T:Meta.Numerics.Statistics.Histogram"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.HistogramBinsCollection.Item(System.Int32)">
            <summary>
            Gets the given histogram bin.
            </summary>
            <param name="index">The bin number.</param>
            <returns>The specified bin.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.HistogramBinsCollection.Count">
            <summary>
            Gets the number of histogram bins in the collection.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.InsufficientDataException">
            <summary>
            The exception that is thrown when an operation is attempted with less than the minimum required data.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.InsufficientDataException.#ctor">
            <summary>
            Initializes a new insufficient data exception.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.InsufficientDataException.#ctor(System.String)">
            <summary>
            Inititalizes a new insufficient data exception with the given exception message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.InsufficientDataException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new insufficient data exception with the given exception message and inner exception.
            </summary>
            <param name="message">The exeption message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="T:Meta.Numerics.Statistics.MultivariateSample">
            <summary>
            Represents a multivariate sample.
            </summary>
            <remarks>
            <para>A multivariate sample is simply a sample in which more than one number is associated with each
            data point. A study which records only the height of each subject could use the <see cref="T:Meta.Numerics.Statistics.Sample"/>
            class to store its data, but a study which records the income and height of each subject should use
            MutlivariateSample class. In addition to descriptive statistics, this class offers tests for studying
            the associations between the recorded variables, and routines for fitting the sample to a model.
            </para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.#ctor(System.Int32)">
            <summary>
            Initializes a new multivariate sample.
            </summary>
            <param name="dimension">The dimension of the sample space, that is, the number of variables
            recorded for each sample entry.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dimension"/> is less than one.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.#ctor(System.String[])">
            <summary>
            Initializes a new multivariate sample with the given variable names.
            </summary>
            <param name="names">The names of the variables.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.MultivariateSample.Dimension">
            <summary>
            Gets the dimension of the sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Add(System.Double[])">
            <summary>
            Adds an entry to the sample.
            </summary>
            <param name="values">The values associated with the entry.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Add(System.Collections.Generic.IList{System.Double})">
            <summary>
            Adds an entry to the sample.
            </summary>
            <param name="values">The values associated with the entry.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="values"/> does not match the
            dimension of the multivariate sample.</exception>
            <exception cref="T:System.InvalidOperationException">The multivariate sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Remove(System.Double[])">
            <summary>
            Removes an entry from the sample.
            </summary>
            <param name="value">The values associated with the entry to remove.</param>
            <returns>Whether the entry was found and removed.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Remove(System.Collections.Generic.IList{System.Double})">
            <summary>
            Removes an entry from the sample.
            </summary>
            <param name="values">The values associated with the entry to remove.</param>
            <returns>Whether the entry was found and removed.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The dimension of <paramref name="values"/> does not match the
            dimension of the multivariate sample.</exception>
            <exception cref="T:System.InvalidOperationException">The multivariate sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Contains(System.Double[])">
            <summary>
            Determines whether the sample contains a given entry.
            </summary>
            <param name="values">The values associated with the entry to search for.</param>
            <returns>Whether the sample contains the given entry.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Contains(System.Collections.Generic.IList{System.Double})">
            <summary>
            Determines whether the sample contains a given entry.
            </summary>
            <param name="values">The values associated with the entry to search for.</param>
            <returns>Whether the sample contains the given entry.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Clear">
            <summary>
            Removes all entries from the sample.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.MultivariateSample.Count">
            <summary>
            Gets the number of enties in the sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Column(System.Int32)">
            <summary>
            Gets the indicated column as a univariate <see cref="T:Meta.Numerics.Statistics.Sample"/>.
            </summary>
            <param name="c">The (zero-based) column index.</param>
            <returns>A read-only <see cref="T:Meta.Numerics.Statistics.Sample"/> containing all values in the indicated column.</returns>
            <remarks>
            <para>Use this method to obtain column-specific information, such as the <see cref="P:Meta.Numerics.Statistics.Sample.Median"/> or
            <see cref="P:Meta.Numerics.Statistics.Sample.Variance"/> of the column.</para>
            <para>Note that this is a fast, O(1) operation, which does not create an independent copy of the column.
            The advantage of this is that you can access columns as independent samples as often as you like without
            worying about performance. The disadvantage of this is that the returned sample cannot be altered. If you
            need to alter values in a column independent of the multi-variate sample, use the <see cref="M:Meta.Numerics.Statistics.Sample.Copy"/>
            method to obtain an independent copy of the column.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.TwoColumns(System.Int32,System.Int32)">
            <summary>
            Gets the indicated columns as a <see cref="T:Meta.Numerics.Statistics.BivariateSample"/>.
            </summary>
            <param name="cx">The (zero-based) column index of the X variable.</param>
            <param name="cy">The (zero-based) column index of the Y variable.</param>
            <returns>A read-only <see cref="T:Meta.Numerics.Statistics.BivariateSample"/> consisting of the indicated columns..</returns>
            <remarks>
            <para>Use this method to obtain information specific to the two columns, such as the <see cref="P:Meta.Numerics.Statistics.BivariateSample.Covariance"/>,
            or to perform tests specific to the two columns, such as a <see cref="M:Meta.Numerics.Statistics.BivariateSample.PearsonRTest"/>.</para>
            <para>Note that this is a fast, O(1) operation, which does not create independent copies of the columns.
            The advantage of this is that you can access pairs of columns as bivariate samples as often as you like without
            worying about performance. The disadvantage of this is that the returned bivariate sample cannot be altered. If you
            need to alter values independent of the multi-variate sample, use the <see cref="M:Meta.Numerics.Statistics.BivariateSample.Copy"/>
            method to obtain an independent copy of the bivariate sample.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Columns(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Gets the indicated columns as a multivariate sample.
            </summary>
            <param name="columnIndexes">A list of column indexes.</param>
            <returns>A read-only <see cref="T:Meta.Numerics.Statistics.MultivariateSample"/> consisting of the indicated columns.</returns>
            <remarks>
            <para>Use this method to perform multivariate analyses, such as regression and principal component analyis, using
            only a subset of the variables in the original multivariate sample.</para>
            <para>Note that this is a fast operation, which does not create independent copies of the columns.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Columns(System.Int32[])">
            <summary>
            Gets the indicated columns as a multivariate sample.
            </summary>
            <param name="columnIndexes">A list of columns indexes.</param>
            <returns>A read-only <see cref="T:Meta.Numerics.Statistics.MultivariateSample"/> consisting of the indicated columns.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Copy">
            <summary>
            Copies the multivariate sample.
            </summary>
            <returns>An independent copy of the multivariate sample.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Moment(System.Int32[])">
            <summary>
            Computes the given sample raw moment.
            </summary>
            <param name="powers">The power to which each component should be raised.</param>
            <returns>The specified moment.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.Moment(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Computes the given sample raw moment.
            </summary>
            <param name="powers">The power to which each component should be raised.</param>
            <returns>The specified moment.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="powers"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The length of <paramref name="powers"/> is not
            equal to the <see cref="P:Meta.Numerics.Statistics.MultivariateSample.Dimension"/> of the multivariate sample.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.MomentAboutMean(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Computes the given sample central moment.
            </summary>
            <param name="powers">The power to which each component should be raised.</param>
            <returns>The specified moment.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="powers"/> is null.</exception>
            <exception cref="T:Meta.Numerics.DimensionMismatchException">The length of <paramref name="powers"/> is not
            equal to the <see cref="P:Meta.Numerics.Statistics.MultivariateSample.Dimension"/> of the multivariate sample.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.MomentAboutMean(System.Int32[])">
            <summary>
            Computes the given sample central moment.
            </summary>
            <param name="powers">The power to which each component should be raised.</param>
            <returns>The specified moment.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.LinearRegression(System.Int32)">
            <summary>
            Performs a linear regression analysis.
            </summary>
            <param name="outputIndex">The index of the variable to be predicted.</param>
            <returns>The result of the regression.</returns>
            <remarks>
            <para>Linear regression finds the linear combination of the other variables
            that best predicts the output variable.</para>
            <img src="../images/LinearRegressionEquation.png" />
            <para>The noise term epsilon is assumed to be drawn from the same normal distribution
            for each data point. Note that the model makes no assumptions about the distribution
            of the x's; it merely asserts a particular underlying relationship between the x's and
            the y.</para>
            <h4>Inputs and Outputs</h4>
            <para>In the returned fit result, the indices of the parameters correspond to indices
            of the coefficients. The intercept parameter has the index of the output variable.
            Thus if a linear regression analaysis is done on a 4-dimensional multivariate sample
            to predict variable number 2, the coefficients of variables 0, 1, and 3 will be
            parameters 0, 1, and 3, of the returned fit result, and the intercept will be
            parameter 2.</para>
            <para>If you want to include fewer input variables in your regression, use the
            <see cref="M:Meta.Numerics.Statistics.MultivariateSample.Columns(System.Collections.Generic.IList{System.Int32})"/> method to create a multivariate sample that includes only
            the variables you want to use in your regression.</para>
            <para>The correlation matrix among fit parameters is also returned with the fit
            result, as is an F-test for the goodness of the fit. If the result of the F-test
            is not significant, no conclusions should be drawn from the regression
            coefficients.</para>
            <h4>Regression vs. Correlation</h4>
            <para>If a given coefficient is significantly positive, then a change in the value
            of the corresponding input variable, <i>holding all other input variables constant</i>,
            will tend to increase the output variable. Note that italicized condition means
            that, when there is more than one input variable, a linear regression coefficient measures
            something different than a linear correlation coefficient.</para>
            <para>Suppose, for example, we take a large number of measurements
            of water temperature, plankton concentration, and fish density in a large number of
            different locations. A simple correlation analysis might indicate that fish density is
            positively correlated with both water temperature and plankton concentration. But
            a regression analysis might reveal that increasing water temperature actually
            decreases the fish density. This seeming paradoxical situation might occur
            because fish do much better with more plankton, and plankton do much better at higher
            temperatures, and this positive knock-on effect of temperature on fish is larger than the
            negative direct effect.</para>
            <para>If we are in a situation where we can control the input
            variables independently -- for example we are running an aquarium -- we would ceratainly
            want to know the specific effect of one variable -- that our fishes would actually prefer us to turn
            down the temperature while maintaining a high plankton level -- rather than the observed
            effect as a variable changes along with all the others that tend to change with it.
            This does not mean that the correlation analysis is wrong -- higher temperatures
            are indeed associated with higher fish densitites in our hypothetical data set. It
            simply means that you need to be careful to ask the right question for your purpose.</para>
            <para>In most cases, it is indeed the specific effect of one variable when others are
            held constant that we seek. In a controlled experiment, the confounding effects of
            other variables are removed by the experimental design, either by random
            assignment or specific controls. In an observational experiment, though,
            confounding effects can be, and often are, large, and correlation analysis is
            not sufficient. It is worthwhile keeping this in find in politically charged
            debates in which easily observed correlations are likely to be bandied about as
            evidence, while a more difficult regression analysis that would actually be required
            to support an assertion is left undone.</para>
            <h4>Cavets</h4>
            <para>It can occur that two theoretically independent variables are so closely
            correlated in the observational data that a regression analsysis cannot reliably
            tease out the independent effect of each. In that case, a fit using only one
            of the variables will be as good or nearly as good as a fit using both, and
            the covariance between their corresponding linear regression coefficients will
            be large. In a situation like this, you should be wary of drawing any conclusions
            about their seperate effects.</para>
            <para>It can also occur that an input variable or a set of input variables is indeed good
            predictor of an output variable, but via a complex and non-linear relationship that
            a linear regression analysis will completely miss.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="outputIndex"/> is outside the range of allowed indexes.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer entries than the dimension of the multivariate sample.</exception>
            <exception cref="T:System.DivideByZeroException">The curvature matrix is singular, indicating that the data is independent of
            one or more parameters, or that two or more parameters are linearly dependent.</exception>
            <seealso cref="M:Meta.Numerics.Statistics.MultivariateSample.LinearRegression(System.Int32)"/>
            <seealso href="http://en.wikipedia.org/wiki/Linear_regression"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.LogisticLinearRegression(System.Int32)">
            <summary>
            Performs a linear logistic regression analysis.
            </summary>
            <param name="outputIndex">The index of the column to predict.</param>
            <returns>A logistic multi-linear model fit. The kth parameter is the slope of the multi-linear model with respect to
            the kth column, except for k equal to the <paramref name="outputIndex"/>, for which it is the intercept.</returns>
            <remarks>Logistic linear regression is suited to situations where multiple input variables, either continuous or binary indicators, are used to predict
            the value of a binary output variable. Like a linear regression, a logistic linear regression tries to find a model that predicts the output variable using
            a linear combination of input variables. Unlike a simple linear regression, the model does not assume that this linear
            function predicts the output directly; instead it assumes that this function value is then fed into a logit link function, which
            maps the real numbers into the interval (0, 1), and interprets the value of this link function as the probability of obtaining success value
            for the output variable.</remarks>
            <exception cref="T:System.InvalidOperationException">The column to be predicted contains values other than 0 and 1.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are not more rows in the sample than columns.</exception>
            <exception cref="T:System.DivideByZeroException">The curvature matrix is singular, indicating that the data is independent of
            one or more parameters, or that two or more parameters are linearly dependent.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.GetEnumerator">
            <summary>
            Gets an enumerator over the sample entries.
            </summary>
            <returns>An iterator over the sample entries.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.MultivariateSample.IsReadOnly">
            <summary>
            Gets a value indicating whether the multivariate sample can be modified.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.MultivariateSample.PrincipalComponentAnalysis">
            <summary>
            Performs a principal component analysis of the data.
            </summary>
            <returns>The result of the principal component analysis.</returns>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">The number of data entries (<see cref="P:Meta.Numerics.Statistics.MultivariateSample.Count"/>) is
            less than the number of variables (<see cref="P:Meta.Numerics.Statistics.MultivariateSample.Dimension"/>).</exception>
            <seealso cref="M:Meta.Numerics.Statistics.MultivariateSample.PrincipalComponentAnalysis"/>
        </member>
        <member name="T:Meta.Numerics.Statistics.PrincipalComponentAnalysis">
            <summary>
            Represents a principal component analysis.
            </summary>
            <remarks>
            <para>Principal component analysis (PCA) is a form of factor analysis. It attempts to identify a small number number of factors
            such that, by specifing only values of these few factors for each row, the value of each variable can be accurately
            predicted.</para>
            <para>Mathematically, PCA constructs an alternative set of orthonormal basis vectors for a multi-variate data set. These
            basis vectors, called principal components, are ordered by the total variance explained by each.</para>
            <para>Suppose, for example, you measure the value of different possessions possessions for a sample of people:
            home value, car value, furniture value, etc. You might expect that much of the variation in these numbers can
            be explained by one underlying factor, which you might call "richness". If this is true, then a PCA analysis will
            show that the most principal component explains a very large faction of the total variance, and the other less
            principal components will explain only small fractions of the total variance.</para>
            <para>Note that PCA is not invariant with respect to the re-scaling of individual variables.</para>
            <para>Note that PCA is an exploratory technique, not a hypothesis test.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponentAnalysis.Dimension">
            <summary>
            Gets the number of components.
            </summary>
            <remarks>
            <para>The number of components is equal to the number of variables used in the analysis.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponentAnalysis.Count">
            <summary>
            Gets the number of data entries.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.PrincipalComponentAnalysis.MinimumDimension(System.Double)">
            <summary>
            Gets the minimum number of principal components that must be included to explain the given fraction of the total variance.
            </summary>
            <param name="P">The fraction of the variance to explain, which must lie between zero and one.</param>
            <returns>The required number of components.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.PrincipalComponentAnalysis.Component(System.Int32)">
            <summary>
            Gets the requested principal component.
            </summary>
            <param name="componentIndex">The (zero-based) index of the principal component.</param>
            <returns>The requested principal component.</returns>
            <remarks>
            <para>Principal components are ordered by strength. The most principal component, i.e. the component which explains
            the most variance, has index zero. The least principal component has the highest index.</para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="componentIndex"/> lies outside the range [0, <see cref="P:Meta.Numerics.Statistics.PrincipalComponentAnalysis.Dimension"/>-1].</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.PrincipalComponentAnalysis.TransformedSample">
            <summary>
            Represents the original data in terms of principal components.
            </summary>
            <returns>A multivariate sample whose columns are the weights of each principal component in each entry of the
            originally analyzed sample.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.PrincipalComponent">
            <summary>
            Represents a component of a principal component analysis.
            </summary>
            <seealso cref="T:Meta.Numerics.Statistics.PrincipalComponentAnalysis"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponent.Index">
            <summary>
            Gets the index of the principal component.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponent.Analysis">
            <summary>
            Gets the principal component analysis to which the component belongs.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponent.Weight">
            <summary>
            Gets the weight of the component.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponent.VarianceFraction">
            <summary>
            Gets the fraction of the total variance accounted for by the principal component.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.PrincipalComponent.CumulativeVarianceFraction">
            <summary>
            Gets the fraction of the total variance accounted for by the principal component and all strong principal components.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.PrincipalComponent.NormalizedVector">
            <summary>
            Gets the normalized component vector.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.PrincipalComponent.ScaledVector">
            <summary>
            Gets the scaled component vector.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.Sample">
            <summary>
            Represents a set of data points, where each data point consists of a single real number.
            </summary>
            <remarks>
            <para>A univariate sample is a data set which records one number for each independent
            observation. For example, data from a study which measured the weight of each subject could be
            stored in the Sample class. The class offers descriptive statistics for the sample, estimates
            of descriptive statistics of the underlying population distribution, and statistical
            tests to compare the sample distribution to other sample distributions or theoretical models.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.#ctor">
            <summary>
            Initializes a new, empty sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.#ctor(System.String)">
            <summary>
            Initializes a new, empty sample with the given name.
            </summary>
            <param name="name">The name of the sample.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Initializes a new sample from a list of values.
            </summary>
            <param name="values">Values to add to the sample.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is null.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.#ctor(System.Double[])">
            <summary>
            Initializes a new sample from a list of values.
            </summary>
            <param name="values">Values to add to the sample.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Name">
            <summary>
            Gets or sets the name of the sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Add(System.Double)">
            <summary>
            Adds a value to the sample.
            </summary>
            <param name="value">The value to add.</param>
            <exception cref="T:System.InvalidOperationException">The sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Add(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Adds multiple values to the sample.
            </summary>
            <param name="values">An enumerable set of the values to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Add(System.Double[])">
            <summary>
            Adds multiple values to the sample.
            </summary>
            <param name="values">An arbitrary number of values.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Remove(System.Double)">
            <summary>
            Removes a given value from the sample.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>True if the value was found and removed, otherwise false.</returns>
            <exception cref="T:System.InvalidOperationException">The sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Clear">
            <summary>
            Remove all values from the sample.
            </summary>
            <exception cref="T:System.InvalidOperationException">The sample is read-only.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Transform(System.Func{System.Double,System.Double})">
            <summary>
            Transforms all values using a user-supplied function.
            </summary>
            <param name="transformFunction">The function used to transform the values.</param>
            <remarks>
            <para>For example, to replace all values with their logarithms, apply a transform using <see cref="M:System.Math.Log(System.Double)"/>.</para>
            <para>If the supplied transform function throws an excaption, or returns infinite or NaN values, the transformation
            may be incomplete or the data corrupted.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="transformFunction"/> is <see langword="null"/>.</exception>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.IsReadOnly">
            <summary>
            Gets a value indicating whether the sample is read-only.
            </summary>
            <value><see langword="true"/> if the sample is read-only, otherwise <see langword="false"/>.</value>
            <remarks>
            <para>If a sample is read-only and you need to make changes to it, you can use <see cref="M:Meta.Numerics.Statistics.Sample.Copy"/> to
            obtain a modifyable copy.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Contains(System.Double)">
            <summary>
            Determines whether the sample contains the given value.
            </summary>
            <param name="value">The value to check for.</param>
            <returns>True if the sample contains <paramref name="value"/>, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Copy">
            <summary>
            Copies the sample.
            </summary>
            <returns>An independent copy of the sample.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Count">
            <summary>
            Gets the number of values in the sample.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Mean">
            <summary>
            Gets the sample mean.
            </summary>
            <remarks>
            <para>The mean is the average of all values in the sample.</para>
            </remarks>
            <seealso cref="P:Meta.Numerics.Statistics.Sample.PopulationMean"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Variance">
            <summary>
            Gets the sample variance.
            </summary>
            <remarks>
            <para>This is the actual variance of the sample values, not the infered variance
            of the underlying population; to obtain the latter use <see cref="P:Meta.Numerics.Statistics.Sample.PopulationVariance" />.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.StandardDeviation">
            <summary>
            Gets the sample standard deviation.
            </summary>
            <remarks>
            <para>This is the actual standard deviation of the sample values, not the infered standard
            deviation of the underlying population; to obtain the latter use
            <see cref="P:Meta.Numerics.Statistics.Sample.PopulationStandardDeviation" />.</para>
            </remarks>        
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Skewness">
            <summary>
            Gets the sample skewness.
            </summary>
            <remarks>
            <para>Skewness is the third central moment, measured in units of the appropriate power of the standard deviation.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.Moment(System.Int32)">
            <summary>
            Computes the given sample moment.
            </summary>
            <param name="n">The order of the moment to compute.</param>
            <returns>The <paramref name="n"/>th moment of the sample.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.MomentAboutMean(System.Int32)">
            <summary>
            Computes the given sample moment about its mean.
            </summary>
            <param name="n">The order of the moment to compute.</param>
            <returns>The <paramref name="n"/>th moment about its mean of the sample.</returns>
            <remarks>
            <para>This method computes the central momements of the sample data, not the estiamted
            central moments of the underlying population; to obtain the latter, use <see cref="M:Meta.Numerics.Statistics.Sample.PopulationMomentAboutMean(System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Median">
            <summary>
            Gets the sample median.
            </summary>
            <seealso href="https://en.wikipedia.org/wiki/Median"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.InterquartileRange">
            <summary>
            Gets the interquartile range of sample measurmements.
            </summary>
            <remarks>The interquartile range is the interval between the 25th and the 75th percentile.</remarks>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.InverseLeftProbability(System.Double)"/>
            <seealso href="https://en.wikipedia.org/wiki/Interquartile_range"/>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Minimum">
            <summary>
            Gets the smallest value in the sample.
            </summary>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">The sample contains no data.</exception>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.Maximum">
            <summary>
            Gets the largest value in the sample.
            </summary>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">The sample contains no data.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.LeftProbability(System.Double)">
            <summary>
            Gets the fraction of values equal to or less than the given value.
            </summary>
            <param name="value">The reference value.</param>
            <returns>The fraction of values in the sample that are less than or equal to the given reference value.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.InverseLeftProbability(System.Double)">
            <summary>
            Gets the sample value corresponding to a given percentile score.
            </summary>
            <param name="P">The percentile, which must lie between zero and one.</param>
            <returns>The corresponding value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="P"/> lies outside [0,1].</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><see cref="P:Meta.Numerics.Statistics.Sample.Count"/> is less than two.</exception>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.PopulationMean">
            <summary>
            Gets an estimate of the population mean from the sample.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.PopulationVariance">
            <summary>
            Gets an estimate of the population variance from the sample.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.Sample.PopulationStandardDeviation">
            <summary>
            Gets an estimate of the population standard deviation from the sample.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.PopulationMoment(System.Int32)">
            <summary>
            Estimates the given population moment using the sample.
            </summary>
            <param name="n">The order of the moment.</param>
            <returns>An estimate of the <paramref name="n"/>th moment of the population.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.PopulationMomentAboutMean(System.Int32)">
            <summary>
            Estimates the given population moment about the mean using the sample.
            </summary>
            <param name="n">The order of the moment.</param>
            <returns>An estimate, with uncertainty, of the <paramref name="n"/>th moment about the mean
            of the underlying population.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="n"/> is negative.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.ZTest(System.Double,System.Double)">
            <summary>
            Performs a z-test.
            </summary>
            <param name="referenceMean">The mean of the comparison population.</param>
            <param name="referenceStandardDeviation">The standard deviation of the comparison population.</param>
            <returns>A test result indicating whether the sample mean is significantly different from that of the comparison population.</returns>
            <remarks>
            <para>A z-test determines whether the sample is compatible with a normal population with known mean and standard deviation.
            In most cases, Student's t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)"/>), which does not assume a known population standard deviation,
            is more appropriate.</para>
            </remarks>
            <example>
            <para>Suppose a standardized test exists, for which it is known that the mean score is 100 and the standard deviation is 15
            across the entire population. The test is administered to a small sample of a subpopulation, who obtain a mean sample score of 95.
            You can use the z-test to determine how likely it is that the subpopulation mean really is lower than the population mean,
            that is that their slightly lower mean score in your sample is not merely a fluke.</para>
            </example>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><see cref="P:Meta.Numerics.Statistics.Sample.Count"/> is zero.</exception>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.ZTest(System.Double,System.Double,Meta.Numerics.Statistics.TestType)">
            <summary>
            Performs a z-test with the given sidedness.
            </summary>
            <param name="referenceMean">The mean of the comparison population.</param>
            <param name="referenceStandardDeviation">he standard deviation of the comparison population.</param>
            <param name="type">The sidedness of the test to perform.</param>
            <returns>A test result indicating whether the sample mean is significantly different from that of the comparison population
            in the direction indicated by <paramref name="type"/>.</returns>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.ZTest(System.Double,System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)">
            <summary>
            Tests whether the sample mean is compatible with the reference mean.
            </summary>
            <param name="referenceMean">The reference mean.</param>
            <returns>The result of the test. The test statistic is a t-value. If t &gt; 0, the one-sided likelyhood
            to obtain a greater value under the null hypothesis is the (right) propability of that value. If t &lt; 0, the
            corresponding one-sided likelyhood is the (left) probability of that value. The two-sided likelyhood to obtain
            a t-value as far or farther from zero as the value obtained is just twice the one-sided likelyhood.</returns>
            <remarks>
            <para>The test statistic of Student's t-test is the difference between the sample mean and the reference mean,
            measured in units of the sample mean uncertainty. Under the null hypothesis that the sample was drawn from a normally
            distributed population with the given reference mean, this statistic can be shown to follow a Student distribution
            (<see cref="T:Meta.Numerics.Statistics.Distributions.StudentDistribution"/>). If t is far from zero, with correspondingly small left or right tail probability,
            then the sample is unlikely to have been drawn from a population with the given reference mean.</para>
            <para>Because the distribution of a t-statistic assumes a normally distributed population, this
            test should only be used only on sample data compatible with a normal distribution. The sign test (<see cref="M:Meta.Numerics.Statistics.Sample.SignTest(System.Double)"/>)
            is a non-parametric alternative that can be used to test the compatibility of the sample median with an assumed population median.</para>
            </remarks>
            <example>
            <para>In some country, the legal limit blood alcohol limit for drivers is 80 on some scale. Because they
            have noticed that the results given by their measuring device fluctuate, the police perform three
            seperate measurements on a suspected drunk driver.
            They obtain the results 81, 84, and 93. They argue that, because all three results exceed the
            limit, the court should be very confident that the driver's blood alcohol level did, in fact, exceed
            the legal limit. You are the driver's lawyer. Can you make an argument to that the court shouldn't be so
            sure?</para>
            <para>Here is some code that computes the probability of obtaining such high measured values,
            assuming that the true level is exactly 80.</para>
            <code lang="c#">
            Sample values = new Sample();
            values.Add(81, 84, 93);
            TestResult result = values.StudentTTest(80);
            return(result.RightProbability);
            </code>
            <para>What level of statistical confidence do you think should a court require in order to pronounce a defendant guilty?</para>
            </example>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than two data points in the sample.</exception>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.StudentDistribution" />
            <seealso href="https://en.wikipedia.org/wiki/Student%27s_t-test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double,Meta.Numerics.Statistics.TestType)">
            <summary>
            Tests whether the sample mean differs from the reference mean in the specified direction.
            </summary>
            <param name="referenceMean">The reference mean.</param>
            <param name="type">The sidedness of the test to perform.</param>
            <returns>A test result indicating whether the sample mean is significantly different from the reference mean
            in the direction indicated by <paramref name="type"/>.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.SignTest(System.Double)">
            <summary>
            Tests whether the sample median is compatible with the given reference value.
            </summary>
            <param name="referenceMedian">The reference median.</param>
            <returns>The result of the test.</returns>
            <remarks>
            <para>The sign test is a non-parametric alternative to the Student t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)"/>).
            It tests whether the sample is consistent with the given refernce median.</para>
            <para>The null hypothesis for the test is that the median of the underlying population from which the sample is
            drawn is the reference median. The test statistic is simply number of sample values that lie above the median. Since
            each sample value is equally likely to be below or above the population median, each draw is an independent Bernoulli
            trial, and the total number of values above the population median is distributed accordng to a binomial distribution
            (<see cref="T:Meta.Numerics.Statistics.Distributions.BinomialDistribution"/>).</para>
            <para>The left probability of the test result is the chance of the sample median being so low, assuming the sample to have been
            drawn from a population with the reference median. The right probability of the test result is the chance of the sample median
            being so high, assuming the sample to have been drawn from a population with the reference median.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.StudentTTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)">
            <summary>
            Tests whether one sample mean is compatible with another sample mean.
            </summary>
            <param name="a">The first sample, which must contain at least two entries.</param>
            <param name="b">The second sample, which must contain at least two entries.</param>
            <returns>The result of the test. The statistic is the Student's t and the probability
            is the chance of obtaining such an extreme value of t if the two samples are drawn
            from the same distribution.</returns>
            <remarks>
            <para>Given two samples, a back-of-the-envelope way to determine whether their means differ in a statistically
            significant way is to compare their <see cref="P:Meta.Numerics.Statistics.Sample.PopulationMean"/> values. If their error bars overlap, they
            are probably statistically compatible; if they do not, the difference in means is probably statistically
            significant. Student's t-test is a way to refine this back-of-the-envelope procedure into a statistical test
            that can determine exactly how likely a given seperation of means is under the null hypothesis that the
            two samples are drawn from the same distribution.</para>
            <para>The t-statistic is proportional to the mean of <paramref name="a"/> minus the mean of <paramref name="b"/>,
            so t > 0 indicates that <paramref name="a"/> has a greater mean.</para>
            <para>Student's t-test was one of the first statistical tests. It was described by William Sealy Gosset,
            a chemist who worked for the Guiness brewing company. Since Guiness was concerned that other breweries might take
            advantage of a technique published by one of its chemists, Gosset published his work under the pseudonym Student.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException"><paramref name="a"/> or <paramref name="b"/> contains less than two values.</exception>
            <seealso href="https://en.wikipedia.org/wiki/Student's_t-test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.MannWhitneyTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)">
            <summary>
            Tests whether one sample median is compatible with another sample median.
            </summary>
            <param name="a">The fisrt sample.</param>
            <param name="b">The second sample.</param>
            <returns>The result of the test. The statistic is the Mann-Whitney U value and the probability
            is the chance of obtaining such an extreme value of U if the two samples are drawn from the
            same distribution.</returns>
            <remarks>
            <para>The Mann-Whitney test is a non-parametric alternative to Student's t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>).
            Essentially, it supposes that the medians of the two samples are equal and tests
            the likelihood of this null hypothesis. Unlike the t-test, it does not assume that the sample distributions are normal.</para>
            </remarks>
            <seealso href="http://en.wikipedia.org/wiki/Mann-Whitney_U_test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(Meta.Numerics.Statistics.Sample[])">
            <summary>
            Performs a one-way analysis of variance (ANOVA).
            </summary>
            <param name="samples">The samples to compare.</param>
            <returns>ANOVA data, including an F-test comparing the between-group variance to
            the within-group variance.</returns>
            <remarks>
            <para>The one-way ANOVA is an extension of the Student t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>)
            to more than two groups. The test's null hypothesis is that all the groups' data are drawn
            from the same distribution. If the null hypothesis is rejected, it indicates
            that at least one of the groups differs significantly from the others.</para>
            <para>Given more than two groups, you should use an ANOVA to test for differences
            in the means of the groups rather than perform multiple t-tests. The reason
            is that each t-test incurs a small risk of a false positive, so multiple t-tests increase
            the total risk of a false positive. For example, given a 95% confidence requirement,
            there is only a 5% chance that an individual t-test will incorrectly diagnose a significant
            difference. But given 5 samples, there are 5 * 4 / 2 = 10 t-tests to be
            performed, giving about a 40% chance that at least one of them will incorrectly
            diagnose a significant difference! The ANOVA avoids the accumulation of risk
            by performing a single test at the required confidence level to test for
            any significant differences between the groups.</para>
            <para>A one-way ANOVA performed on just two samples is equivilent to a
            t-test (<see cref="M:Meta.Numerics.Statistics.Sample.StudentTTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)" />).</para>
            <para>ANOVA is an acronym for "Analysis of Variance". Do not be confused
            by the name and by the use of a ratio-of-variances test statistic: an
            ANOVA is primarily (although not exclusively) sensitive to changes in the
            <i>mean</i> between samples. The variances being compared by the test are not the
            variances of the individual samples; instead the test compares the variance of
            all samples considered together as one single, large sample to the variances of the samples
            considered individually. If the means of some groups differ significantly,
            then the variance of the unified sample will be much larger than the vairiances of the
            individual samples, and the test will signal a significant difference. Thus the
            test uses variance as a tool to detect shifts in mean, not because it
            is interesed in the individual sample variances per se.</para>
            <para>ANOVA is most appropriate when the sample data are continuous and approximately normal,
            and the samples are distinguished by a nominal variable. For example, given
            a random sampling of the heights of members of five different political parties,
            a one-way ANOVA would be an appropriate test of the whether the different
            parties tend to attract people with different heights.</para>
            <para>Given a continuous independent variable, binning in order to define
            groups and perform an ANOVA is generally not appropriate.
            For exapmple, given the incomes and heights of a large number of people,
            dividing these people into low-height, medium-height, and high-height groups
            and performing an ANOVA of the income of people in each group is not a
            good way to test whether height influences income.
            In a case like this, it would be better to put the data into a <see cref="T:Meta.Numerics.Statistics.BivariateSample"/> and
            perform a test of association, such as a <see cref="M:Meta.Numerics.Statistics.BivariateSample.PearsonRTest" />,
            <see cref="M:Meta.Numerics.Statistics.BivariateSample.SpearmanRhoTest" />, or <see cref="M:Meta.Numerics.Statistics.BivariateSample.KendallTauTest" />
            between the two variables. If you have measurements
            of additional variables for each indiviual, a <see cref="M:Meta.Numerics.Statistics.MultivariateSample.LinearRegression(System.Int32)" />
            analysis would allow you to adjust for the confounding effects of the other variables. If you
            define arbitrary bins of continuously variable data in order to form groups, then your
            ANOVA results will depend on your choice of bins.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="samples"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="samples"/> contains fewer than two samples.</exception>
            <seealso href="https://en.wikipedia.org/wiki/Analysis_of_variance"/>
            <seealso href="https://en.wikipedia.org/wiki/One-way_analysis_of_variance"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(System.Collections.Generic.ICollection{Meta.Numerics.Statistics.Sample})">
            <summary>
            Performs a one-way analysis of variance (ANOVA).
            </summary>
            <param name="samples">The samples to compare.</param>
            <returns>ANOVA data, including an F-test comparing the between-group variance to
            the within-group variance.</returns>
            <remarks>
            <para>For detailed information, see <see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(Meta.Numerics.Statistics.Sample[])"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.TwoWayAnovaTest(Meta.Numerics.Statistics.Sample[0:,0:])">
            <summary>
            Performs a two-way analysis of variance.
            </summary>
            <param name="samples">A two-dimensional array of samples, all of which must have equal counts.</param>
            <returns>The result of the analysis.</returns>
            <remarks>
            <para>A two-way ANOVA analyzes the effects of two seperate input factors, each with
            two or more nominal values, on a continuous output variable.</para>
            <para>The only design supported is complete and balanced: samples must exist
            for all combinations of treatment factors, and each of those samples must
            contain the same number of data points. These samples are passed to the method
            as a two-dimensional array <paramref name="samples"/>, whose (i, j)th entry
            contains the sample with ith ith row factor value and jth column factor value.</para>
            <para>For more information on ANOVA tests and when to use them, see the remarks for
            <see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(Meta.Numerics.Statistics.Sample[])"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="samples"/> is null, or one of its entries is null.</exception>
            <exception cref="T:System.InvalidOperationException">The design is not complete or balanced.</exception>
            <seealso href="https://en.wikipedia.org/wiki/Two-way_analysis_of_variance"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.KruskalWallisTest(System.Collections.Generic.IList{Meta.Numerics.Statistics.Sample})">
            <summary>
            Performs a Kruskal-Wallis test on the given samples.
            </summary>
            <param name="samples">The set of samples to compare.</param>
            <returns>The result of the test.</returns>
            <remarks>
            <para>For detailed information, see <see cref="M:Meta.Numerics.Statistics.Sample.KruskalWallisTest(Meta.Numerics.Statistics.Sample[])"/>.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.KruskalWallisTest(Meta.Numerics.Statistics.Sample[])">
            <summary>
            Performs a Kruskal-Wallis test on the given samples.
            </summary>
            <param name="samples">The set of samples to compare.</param>
            <returns>The result of the test.</returns>
            <remarks>
            <para>Kruskal-Wallis tests for differences between the samples. It is a non-parametric alternative to the
            one-way ANOVA (<see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(Meta.Numerics.Statistics.Sample[])"/>), which is more appropriate when the data far from
            normally distributed.</para>
            <para>The test is essentially a one-way ANOVA performed on the <i>ranks</i> of sample values instead of the sample
            values themselves.</para>
            <para>A Kruskal-Wallis test on two samples is equivilent to a Mann-Whitney test (see <see cref="M:Meta.Numerics.Statistics.Sample.MannWhitneyTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>).</para>
            <para>As with a normal ANOVA, it is not appropriate to bin a continuous independent variable in order to form
            groups for a Kruskal-Wallis test. Kruskal-Wallis addresses the non-normality of the dependent variable, not
            the non-discreteness of the independent variable.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="samples"/> is <see langword="null"/>.</exception>
            <see cref="M:Meta.Numerics.Statistics.Sample.OneWayAnovaTest(Meta.Numerics.Statistics.Sample[])"/>
            <see href="https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.KolmogorovSmirnovTest(Meta.Numerics.Statistics.Distributions.Distribution)">
            <summary>
            Tests whether the sample is compatible with the given distribution.
            </summary>
            <param name="distribution">The test distribution.</param>
            <returns>The test result. The test statistic is the D statistic and the probability is the chance of
            obtaining such a large value of D under the assumption that the sample is drawn from the given distribution.</returns>
            <remarks>
            <para>The null hypothesis of the Kolmogorov-Smirnov (KS) test is that the sample is drawn from the given continuous distribution.
            The test statsitic D is the maximum deviation of the sample's empirical distribution function (EDF) from
            the distribution's cumulative distribution function (CDF). A high value of the test statistic, corresponding
            to a low right tail probability, indicates that the sample distribution disagrees with the given distribution
            to a degree unlikely to arise from statistical fluctuations.</para>
            <para>For small sample sizes, we compute the null distribution of D exactly. For large sample sizes, we use an accurate
            asympototic approximation. Therefore it is safe to use this method for all sample sizes.</para>
            <para>A variant of this test, <see cref="M:Meta.Numerics.Statistics.Sample.KolmogorovSmirnovTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)"/>, allows you to non-parametrically
            test whether two samples are drawn from the same underlying distribution, without having to specify that distribution.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="distribution"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There is no data in the sample.</exception>
            <seealso cref="T:Meta.Numerics.Statistics.Distributions.KolmogorovDistribution"/>
            <seealso href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.KuiperTest(Meta.Numerics.Statistics.Distributions.Distribution)">
            <summary>
            Tests whether the sample is compatible with the given distribution.
            </summary>
            <param name="distribution">The test distribution.</param>
            <returns>The test result. The test statistic is the V statistic and the chance to obtain such a large
            value of V under the assumption that the sample is drawn from the given distribution.</returns>
            <remarks>
            <para>Like the Kolmogorov-Smirnov test ((<see cref="M:Meta.Numerics.Statistics.Sample.KolmogorovSmirnovTest(Meta.Numerics.Statistics.Distributions.Distribution)"/>,
            Kuiper's test compares the EDF of the sample to the CDF of the given distribution.</para>
            <para>For small sample sizes, we compute the null distribution of V exactly. For large sample sizes, we use an accurate
            asympototic approximation. Therefore it is safe to use this method for all sample sizes.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="distribution"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There is no data in the sample.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Kuiper%27s_test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.KolmogorovSmirnovTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)">
            <summary>
            Tests whether the sample is compatible with another sample.
            </summary>
            <param name="a">One sample.</param>
            <param name="b">The other sample.</param>
            <returns>The test result. The test statistic is the D statistic and the likelyhood is the right probability
            to obtain a value of D as large or larger than the one obtained.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">One or both of the samples is empty.</exception>
            <seealso href="http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.FisherFTest(Meta.Numerics.Statistics.Sample,Meta.Numerics.Statistics.Sample)">
            <summary>
            Tests whether the variances of two samples are compatible.
            </summary>
            <param name="a">The first sample.</param>
            <param name="b">The second sample.</param>
            <returns>The result of the test.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.GetEnumerator">
            <summary>
            Gets an enumerator of sample values.
            </summary>
            <returns>An enumerator of sample values.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.Sample.MaximumLikelihoodFit(System.Func{System.Collections.Generic.IList{System.Double},Meta.Numerics.Statistics.Distributions.Distribution},System.Collections.Generic.IList{System.Double})">
            <summary>
            Performs a maximum likelihood fit.
            </summary>
            <param name="factory">A function that returns a distribution when given its defining parameters.</param>
            <param name="start">An initial guess for the defining parameters.</param>
            <returns>The result of the fit, containg the parameters that result in the best fit,
            covariance matrix among those parameters, and a test of the goodness of fit.</returns>
            <seealso href="http://en.wikipedia.org/wiki/Maximum_likelihood"/>
        </member>
        <member name="T:Meta.Numerics.Statistics.TestResult">
            <summary>
            Represents the result of a statistical test.
            </summary>
            <remarks>
            <para>A statistical test compares a data set to a model (or to another data set) and computes a single, real
            number, called the test statistic, which measures how much the data set differs from model (or the other data set).
            The key to a useful statistical test is that the distribution of the test statistic, under the assumption that
            the model actually explains the data (or that the other data set is drawn from the same distribution) is known.
            This assumption is called the null hypothesis.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.Statistic">
            <summary>
            Gets the value of the test statistic.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.Distribution">
            <summary>
            Gets the distribution of the test statistic under the null hypothesis.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.LeftProbability">
            <summary>
            Get the probability, under the null hypothesis, of obtaining a test statistic value as small or smaller than the one actually obtained. 
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.RightProbability">
            <summary>
            Get the probability, under the null hypothesis, of obtaining a test statistic value as large as or larger than the one actually obtained. 
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.Type">
            <summary>
            Gets a value indicating the type of statistical test.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.TestResult.Probability">
            <summary>
            Gets the probability of such an extreme value of the satistic.
            </summary>
            <value>The P-value of the test-statistic.</value>
        </member>
        <member name="T:Meta.Numerics.Statistics.TestType">
            <summary>
            Describes the sidedness of a statistical test.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Statistics.TestType.LeftTailed">
            <summary>
            The P-value gives the probability of obtaining a value as low as observed.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Statistics.TestType.RightTailed">
            <summary>
            The P-value gives the probability of obtaining a value as high as observed.
            </summary>
        </member>
        <member name="F:Meta.Numerics.Statistics.TestType.TwoTailed">
            <summary>
            The P-values gives the probabily of obtain a value as large in absolute value as observed.
            </summary>
        </member>
        <member name="T:Meta.Numerics.Statistics.TimeSeries">
            <summary>
            Represents an ordered series of data points.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.#ctor">
            <summary>
            Initializes a new, empty time series.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.#ctor(System.Double[])">
            <summary>
            Initializes a new time series with the given values.
            </summary>
            <param name="values">The first values in the time series.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.TimeSeries.Count">
            <summary>
            Gets the number of points in the time series.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Add(System.Double)">
            <summary>
            Adds a point to the time series.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Add(System.Double[])">
            <summary>
            Adds multiple points to the time series.
            </summary>
            <param name="values">The values to be added.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Clear">
            <summary>
            Removes all points from the time series.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Contains(System.Double)">
            <summary>
            Determines whether the time series contains a value.
            </summary>
            <param name="value">The value to look up.</param>
            <returns>True if the value appears in the time series, otherwise false.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.TimeSeries.Item(System.Int32)">
            <summary>
            Gets or sets the value of the time series at a given index.
            </summary>
            <param name="index">The index of the value.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.IndexOf(System.Double)">
            <summary>
            Finds the index at which a value occurs.
            </summary>
            <param name="value">The value to find.</param>
            <returns>An index at which <paramref name="value"/> occurs,
            or -1 if the value does not occur in the time series.</returns>
        </member>
        <member name="P:Meta.Numerics.Statistics.TimeSeries.Mean">
            <summary>
            Gets the mean of the time series.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance(System.Int32)">
            <summary>
            Computes the autocovariance of the series at the given lag.
            </summary>
            <param name="lag">The lag at which to compute the autocovariance.</param>
            <returns>The value of the autocovariance at the given lag.</returns>
            <remarks>
            <para>In a length-N time series, there are N-k lag-k observations. Nonetheless,
            the definition of the lag-k autocovariance requires division by N, not N-k. This
            counterintuitive convention insures that the autocovariance has desirable
            positive definiteness properties and agrees with the computation via FFT.</para>
            <para>The computation of an autocovariance via this method is O(N). If
            you need to compute more than a handfull of autocovariances, it is
            more efficient to call the <see cref="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance"/>, which
            computes all of them in O(N log N).</para>
            <para>While the sample autocovariance does converge to the population
            autocovariance in the large-N limit, this convergence is very slow. If you
            want the value of the population covariance, use <see cref="M:Meta.Numerics.Statistics.TimeSeries.PopulationStatistics"/>
            to obtain a much better estimate.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance">
            <summary>
            Computes the autocovariance for all lags.
            </summary>
            <returns>An array of autocovariance values, with the array index equal to the lag index.</returns>
            <remarks>
            <para>The computation of the autocovariance for a given lag is an O(N) operation.
            Naively, the computation of the autocovariance for all N possible lags is an
            O(N^2) operation; this is in fact the cost of N invoations of <see cref="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance(System.Int32)"/>.
            However, it is possible using Fourier techniques to simultaneously compute
            the autocovariance for all possible lags in O(N log N) operations. This method
            uses this Fourier technique and should be called if you require the autocovariance
            for more than a handfull of lag values.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance(System.Int32)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.PowerSpectrum">
            <summary>
            Computes the power spectrum of the time series.
            </summary>
            <returns>An array giving the power in each frequency bin.</returns>
            <remarks>
            <para>For a time series of length n, the index k gives the
            power near period n / k, or frequency k / n. (For example,
            for a year-long monthly time series, the value at index 1
            is proportional to the yearly variation, the value at the index 4
            is proportional to the quarterly variation, and the value at index 12
            is proportional to the monthly variation.) The zeroth
            entry is proportional to the unfluctuating component of
            the signal, i.e. the mean.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.PopulationStatistics">
            <summary>
            Computes estimates for the moments of the population from which the time series is drawn.
            </summary>
            <returns>A collection of population statistics.</returns>
            <remarks>
            <para>Just as is the case for the variance of a simple <see cref="T:Meta.Numerics.Statistics.Sample"/>,
            the sample autocovariances of a time series
            are not unbiased estimates of the autocovariances of the population from which
            the series is drawn. Additional computations must be performed to calculate
            unbiased estimates and error estimates for the time series mean and autocovariances.</para>
            <para>Unlike the case of a sime <see cref="T:Meta.Numerics.Statistics.Sample"/>, these computations are complicated
            and the same computation is relevant for all moments. Therefore, the computation is performed
            once by this method, which returns a object from which all population statistics can be
            quickly queried.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.AsSample">
            <summary>
            Gets a sample containing the time-series values.
            </summary>
            <returns>A read-only sample containing the time-series value.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.FitToMA1">
            <summary>
            Fits an MA(1) model to the time series.
            </summary>
            <returns>The fit with parameters lag-1 coefficient, mean, and standard deviation.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.FitToAR1">
            <summary>
            Fits an AR(1) model to the time series.
            </summary>
            <returns>The fit with parameters lag-1 coefficient, mean, and standard deviation.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Difference">
            <summary>
            Recomputes the time series as the differences between sequential values of the original series.
            </summary>
            <remarks>
            <para>Differencing decreases the number of values in the series by one.</para>
            </remarks>
            <seealso cref="M:Meta.Numerics.Statistics.TimeSeries.Integrate(System.Double)"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.Integrate(System.Double)">
            <summary>
            Recomputes the time series as the sums of seqential values of the original series.
            </summary>
            <param name="c">The constant to be added to the first value.</param>
            <seealso cref="M:Meta.Numerics.Statistics.TimeSeries.Difference"/>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.LjungBoxTest">
            <summary>
            Performs a Ljung-Box test for non-correlation.
            </summary>
            <returns>The result of the test.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeries.LjungBoxTest(System.Int32)">
            <summary>
            Performs a Ljung-Box test for non-correlation with the given number of lags.
            </summary>
            <param name="kMax">The number of lag times to test.</param>
            <returns>The result of the test.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.TimeSeriesPopulationStatistics">
            <summary>
            Contains estimates of the moments of the population from which a time series is drawn.
            </summary>
            <remarks>
            <para>This class is returned by the method <see cref="M:Meta.Numerics.Statistics.TimeSeries.PopulationStatistics"/>;
            see the documentation of that method for an explanation of its purpose.</para>
            </remarks>
        </member>
        <member name="P:Meta.Numerics.Statistics.TimeSeriesPopulationStatistics.Mean">
            <summary>
            Gets the best estimate, with uncertainty, of the mean of the time series.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.TimeSeriesPopulationStatistics.Autocovariance(System.Int32)">
            <summary>
            Returns the autocovariance for the given lag.
            </summary>
            <param name="k">The lag index, which must lie between 0 and n-1.</param>
            <returns>The best estimate, with uncertainty, of the lag-<paramref name="k"/>
            autocovariance of the population.</returns>
            <remarks>
            <para>Note that, unlike the sample autocovariance (<see cref="M:Meta.Numerics.Statistics.TimeSeries.Autocovariance"/>),
            and unlike the true population autocovariance, the estimated population autocovariance
            is not guaranteed to be positive definite when expressed as a matrix C<sub>i,j</sub>
            = c[|i-j|].</para>
            </remarks>
        </member>
        <member name="T:Meta.Numerics.Statistics.UncertainMeasurement`1">
            <summary>
            Represents an experimental data point that is a function of an arbitrary variable.
            </summary>
            <typeparam name="T">The type of the ordinate (independent variable) characterizing the data point.</typeparam>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.#ctor(`0,Meta.Numerics.UncertainValue)">
            <summary>
            Initializes a new data point with the given values for the ordinate and uncertain abcissa.
            </summary>
            <param name="x">The ordinate.</param>
            <param name="y">The abcissa.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.#ctor(`0,System.Double,System.Double)">
            <summary>
            Initializes a new data point with the given values for the ordinate, abcissa, and uncertainty.
            </summary>
            <param name="x">The ordinate.</param>
            <param name="y">The best estimate of the abcissa.</param>
            <param name="dy">The uncertainty in the abcissa.</param>
        </member>
        <member name="P:Meta.Numerics.Statistics.UncertainMeasurement`1.X">
            <summary>
            Gets or sets the value of the ordinate (independent variable).
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.UncertainMeasurement`1.Y">
            <summary>
            Gets or sets the uncertain value of the abcissa (the depdent variable).
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.op_Equality(Meta.Numerics.Statistics.UncertainMeasurement{`0},Meta.Numerics.Statistics.UncertainMeasurement{`0})">
            <summary>
            Determines whether two data points are equal.
            </summary>
            <param name="d1">The first data point.</param>
            <param name="d2">The second data point.</param>
            <returns>True if the data points are equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.op_Inequality(Meta.Numerics.Statistics.UncertainMeasurement{`0},Meta.Numerics.Statistics.UncertainMeasurement{`0})">
            <summary>
            Determines whether two data points are not equal.
            </summary>
            <param name="d1">The first data point.</param>
            <param name="d2">The second data point.</param>
            <returns>True if the data points are not equal, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.Equals(System.Object)">
            <summary>
            Determines whether the object represents the same data point.
            </summary>
            <param name="obj">The object.</param>
            <returns>True if the object represents the same data point, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurement`1.GetHashCode">
            <summary>
            Gets a hash code for the data point.
            </summary>
            <returns>A hash code for the data point.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.UncertainMeasurementSample`1">
            <summary>
            Represents a set of measurements.
            </summary>
            <typeparam name="T">The type of independent variable associated with each measurement.</typeparam>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.#ctor">
            <summary>
            Initializes a new, empty data set.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Add(Meta.Numerics.Statistics.UncertainMeasurement{`0})">
            <summary>
            Adds a new data point to the set.
            </summary>
            <param name="datum">The data point.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Add(`0,System.Double,System.Double)">
            <summary>
            Adds a new data point to the set.
            </summary>
            <param name="x">The value of the ordinate (independent variable).</param>
            <param name="y">The value of the abcissa (dependent variable).</param>
            <param name="dy">The uncertainty of the abcissa (dependent variable).</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Add(System.Collections.Generic.IEnumerable{Meta.Numerics.Statistics.UncertainMeasurement{`0}})">
            <summary>
            Adds a series of data points to the set.
            </summary>
            <param name="data">The data points.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Remove(Meta.Numerics.Statistics.UncertainMeasurement{`0})">
            <summary>
            Removes a data point from the set.
            </summary>
            <param name="datum">The data point to remove.</param>
            <returns>True if the data point was found and removed; otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Contains(Meta.Numerics.Statistics.UncertainMeasurement{`0})">
            <summary>
            Determines whether the set contains the given data point.
            </summary>
            <param name="datum">The data point.</param>
            <returns>True if the set contains the given data point, otherwise false.</returns>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Clear">
            <summary>
            Removes all data points from the set.
            </summary>
        </member>
        <member name="P:Meta.Numerics.Statistics.UncertainMeasurementSample`1.Count">
            <summary>
            Gets the size of the data set.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.FitToLinearFunction(System.Func{`0,System.Double}[])">
            <summary>
            Fits the data to a linear combination of fit functions.
            </summary>
            <param name="functions">The component functions.</param>
            <returns>A fit result containing the best-fit coefficients of the component functions and a &#x3C7;<sup>2</sup> test
            of the quality of the fit.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functions"/> is null.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer data points than fit parameters.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.FitToFunction(System.Func{System.Double[],`0,System.Double},System.Double[])">
            <summary>
            Fits the data to an arbitrary parameterized function.
            </summary>
            <param name="function">The fit function.</param>
            <param name="start">An initial guess at the parameters.</param>
            <returns>A fit result containing the best-fitting function parameters
            and a &#x3C7;<sup>2</sup> test of the quality of the fit.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> or <paramref name="start"/> are <see langword="null"/>.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer data points than fit parameters.</exception>
            <exception cref="T:System.DivideByZeroException">The curvature matrix is singular, indicating that the data is independent of
            one or more parameters, or that two or more parameters are linearly dependent.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample`1.GetEnumerator">
            <summary>
            Gets an enumerator over the measurements.
            </summary>
            <returns>An enumerator over the measurements.</returns>
        </member>
        <member name="T:Meta.Numerics.Statistics.UncertainMeasurementSample">
            <summary>
            Represents a set of <see cref="T:Meta.Numerics.Statistics.UncertainMeasurement`1"/> measurements.
            </summary>
            <remarks>
            <para>This class adds functionality to the <see cref="T:Meta.Numerics.Statistics.UncertainMeasurementSample"/> class which applies when
            the independent variable (X variable) is a single real number. This includes fitting to a constant, line,
            or polynomial.</para>
            </remarks>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.#ctor">
            <summary>
            Initializes a new, empty data set.
            </summary>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.#ctor(System.Collections.Generic.IEnumerable{Meta.Numerics.Statistics.UncertainMeasurement{System.Double}})">
            <summary>
            Initializes a new data set with the specified data.
            </summary>
            <param name="data">An enumerator over the <see cref="T:Meta.Numerics.Statistics.UncertainMeasurement`1" />s to place in the set.</param>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.FitToConstant">
            <summary>
            Fits the data to a constant value.
            </summary>
            <returns>A fit result containing the best combined value and a &#x3C7;<sup>2</sup> test of the quality of the fit.</returns>
            <remarks><para>This method provides a simple way to </para></remarks>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than one data points.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.FitToProportionality">
            <summary>
            Fit the data to a proportionality relationship.
            </summary>
            <returns>A fit result containing the best-fit proportionality constant parameter and a &#x3C7;<sup>2</sup> test of the
            quality of the fit.</returns>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than one data points.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.FitToLine">
            <summary>
            Fits the data to a line.
            </summary>
            <returns>A fit result containing the best-fit intercept and slope parameters and a &#x3C7;<sup>2</sup> test of
            the quality of the fit.</returns>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are fewer than two data points.</exception>
        </member>
        <member name="M:Meta.Numerics.Statistics.UncertainMeasurementSample.FitToPolynomial(System.Int32)">
            <summary>
            Fits the data to a polynomial.
            </summary>
            <param name="order">The order of the polynomial to fit.</param>
            <returns>A fit result containg the best-fit polynomial coefficients, in order of ascending power from 0 to <paramref name="order"/>,
            and a &#x3C7;<sup>2</sup> test of the quality of the fit.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="order"/> is negative.</exception>
            <exception cref="T:Meta.Numerics.Statistics.InsufficientDataException">There are more polynomial coefficients than data points.</exception>
        </member>
    </members>
</doc>
